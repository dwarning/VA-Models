/*
Verilog-A definition of BSIM4 based on version 4.8
Enhancements List:
trap-assisted junction model
Mobmod=0~6
Substrate R network
Wpemod: Wpe stress effects
Vth DITS extra parameters: dvtp2,3,4,5
mtrlMod with mtrlCompatMod
Igate model: igcmod=2 [abc]igs, [abc]igd, dlcigd, other default val changes
rbodymod =2
gidlMod GISL:agisl, bgisl, cgisl, egisl, rgisl, kgisl, and fgisl

Limitations:
PNlim, Fetlim, such junction/fet current limitation function not implemented
noise:lintnoi, tnoic, rnoic not required to support
.option scale, scalem not applied to this VA model

Extra model parameters:
_ckt_gmin: model param to pass netlist level gmin to va for diode current
min:       model param changed to minsd to avoid to conflict with va builtin function min()
verbose:   model param to print debug information (default: 0)
type:      polarity 1: nmos(default), -1:pmos

Golden Simulator:
HSPICE -- J-2014.09-SP2-1 for testing

Note:
BSIM4.8 was originally released as C code, but this verilogA code is downloaded from https://github.com/cogenda/VA-BSIM48

License:
Attribution-NonCommercial 4.0 International (CC-BY-NC 4.0)
*/

/**********
 * Copyright 2001 Regents of the University of California. All rights reserved.
 * Author:  Weidong Liu
 * Authors: Xuemei Xi, Kanyu M. Cao, Hui Wan, Mansun Chan, Chenming Hu.
 * Project Director: Prof. Chenming Hu.
 **********/
`include "disciplines.vams"
`include "constants.vams"

`define DEFAULT_TNOM 25
`define N_MINLOG 1.0e-38

`ifdef insideADMS
    `define INITIAL_INSTANCE @(initial_instance)
`else
    `define INITIAL_INSTANCE
`endif

`define Gmin $simparam("gmin",1e-12) // Only for pseudo-body network nodes, tiny one to avoid accuracy issue

`define EPS0 8.85418e-12
`define EPSOX 3.453133e-11
`define EPSSI 1.03594e-10
`define DELTA 1.0e-9
`define DELTA_1 0.02
`define DELTA_2 0.02
`define DELTA_3 0.02
`define DELTA_4 0.02
`define MM 3
`define EXP_THRESHOLD 34.0
`define MIN_EXP 1.713908431e-15
`define MAX_EXP 5.834617425e14
`define MAX_EXPL 2.688117142e+43
`define MIN_EXPL 3.720075976e-44
`define EXPL_THRESHOLD 100.0

// For now, set NOISE to 0 to disable noise.
`define NOISE 1
//`define NOISE_DERIVATIVES 1
`define KboQ `P_K / `P_Q
`define NMOS 1
`define PMOS -1
`define DEXP(A,B)                                                        \
    if (A > `EXP_THRESHOLD)                                          \
        B = `MAX_EXP*(1.0+(A)-`EXP_THRESHOLD);                       \
    else if (A < -`EXP_THRESHOLD)                                    \
        B = `MIN_EXP;                                                \
    else                                                             \
        B = exp(A);

`define DEXP2(A,B,C)                                                     \
    if (A > `EXP_THRESHOLD) begin                                    \
        B = `MAX_EXP*(1.0+(A)-`EXP_THRESHOLD);                       \
        C = `MAX_EXP;                                                \
    end                                                              \
    else if (A < -`EXP_THRESHOLD) begin                              \
        B = `MIN_EXP;                                                \
        C = 0;                                                       \
    end else begin                                                   \
        B = exp(A);                                                  \
        C = B;                                                       \
    end


/*
 * The macros to calculate the subroutines to process the geometry dependent
 * parasitics for BSIM4, which calculates Ps, Pd, As, Ad, and Rs and  Rd
 * for multi-fingers and varous GEO and RGEO options.
 */
`define BSIM4NumFingerDiff(nf, minSD, nuIntD, nuEndD, nuIntS, nuEndS) \
    if ((nf%2) != 0) begin \
        nuEndD = 1.0; \
        nuEndS = 1.0; \
        nuIntD = 2.0 * max((nf - 1.0) / 2.0, 0.0); \
        nuIntS = nuIntD; \
    end \
    else begin \
        if (minSD == 1) begin \
            nuEndD = 2.0; \
            nuIntD = 2.0 * max((nf / 2.0 - 1.0), 0.0); \
            nuEndS = 0.0; \
            nuIntS = nf; \
        end \
        else begin \
            nuEndD = 0.0; \
            nuIntD = nf; \
            nuEndS = 2.0; \
            nuIntS = 2.0 * max((nf / 2.0 - 1.0), 0.0); \
        end \
    end

`define BSIM4PAeffGeo(nf, geo, minSD, Weffcj, DMCG, DMCI, DMDG, Ps, Pd, As, Ad) \
    if (geo < 9) \
        `BSIM4NumFingerDiff(nf, minSD, nuIntD, nuEndD, nuIntS, nuEndS) \
    T0 = DMCG + DMCI; \
    T1 = DMCG + DMCG; \
    T2 = DMDG + DMDG; \
    PSiso = T0 + T0 + Weffcj; \
    PDiso = PSiso; \
    PSsha = T1; \
    PDsha = T1; \
    PSmer = T2; \
    PDmer = T2; \
    ASiso = T0 * Weffcj; \
    ADiso = ASiso; \
    ASsha = DMCG * Weffcj; \
    ADsha = ASsha; \
    ASmer = DMDG * Weffcj; \
    ADmer = ASmer; \
    case (geo) \
        0: begin \
            Ps = nuEndS * PSiso + nuIntS * PSsha; \
            Pd = nuEndD * PDiso + nuIntD * PDsha; \
            As = nuEndS * ASiso + nuIntS * ASsha; \
            Ad = nuEndD * ADiso + nuIntD * ADsha; \
        end \
        1: begin \
            Ps = nuEndS * PSiso + nuIntS * PSsha; \
            Pd = (nuEndD + nuIntD) * PDsha; \
            As = nuEndS * ASiso + nuIntS * ASsha; \
            Ad = (nuEndD + nuIntD) * ADsha; \
        end \
        2: begin \
            Ps = (nuEndS + nuIntS) * PSsha; \
            Pd = nuEndD * PDiso + nuIntD * PDsha; \
            As = (nuEndS + nuIntS) * ASsha; \
            Ad = nuEndD * ADiso + nuIntD * ADsha; \
        end \
        3: begin \
            Ps = (nuEndS + nuIntS) * PSsha; \
            Pd = (nuEndD + nuIntD) * PDsha; \
            As = (nuEndS + nuIntS) * ASsha; \
            Ad = (nuEndD + nuIntD) * ADsha; \
        end \
        4: begin \
            Ps = nuEndS * PSiso + nuIntS * PSsha; \
            Pd = nuEndD * PDmer + nuIntD * PDsha; \
            As = nuEndS * ASiso + nuIntS * ASsha; \
            Ad = nuEndD * ADmer + nuIntD * ADsha; \
        end \
        5: begin \
            Ps = (nuEndS + nuIntS) * PSsha; \
            Pd = nuEndD * PDmer + nuIntD * PDsha; \
            As = (nuEndS + nuIntS) * ASsha; \
            Ad = nuEndD * ADmer + nuIntD * ADsha; \
        end \
        6: begin \
            Ps = nuEndS * PSmer + nuIntS * PSsha; \
            Pd = nuEndD * PDiso + nuIntD * PDsha; \
            As = nuEndS * ASmer + nuIntS * ASsha; \
            Ad = nuEndD * ADiso + nuIntD * ADsha; \
        end \
        7: begin \
            Ps = nuEndS * PSmer + nuIntS * PSsha; \
            Pd = (nuEndD + nuIntD) * PDsha; \
            As = nuEndS * ASmer + nuIntS * ASsha; \
            Ad = (nuEndD + nuIntD) * ADsha; \
        end \
        8: begin \
            Ps = nuEndS * PSmer + nuIntS * PSsha; \
            Pd = nuEndD * PDmer + nuIntD * PDsha; \
            As = nuEndS * ASmer + nuIntS * ASsha; \
            Ad = nuEndD * ADmer + nuIntD * ADsha; \
        end \
        9: begin \
            Ps = PSiso + (nf - 1.0) * PSsha; \
            Pd = nf * PDsha; \
            As = ASiso + (nf - 1.0) * ASsha; \
            Ad = nf * ADsha; \
        end \
        10: begin \
            Ps = nf * PSsha; \
            Pd = PDiso + (nf - 1.0) * PDsha; \
            As = nf * ASsha; \
            Ad = ADiso + (nf - 1.0) * ADsha; \
        end \
        default: \
        $strobe("Warning: (instance X*) Specified GEO=%d not matched (BSIM4PAeffGeo)", geo); \
    endcase


/* function to compute poly depletion effect */
`define BSIM4polyDepletion(phi, ngate, epsgate,coxe, Vgs, Vgs_eff, dVgs_eff_dVg)   \
    if ((ngate > 1.0e18) && (ngate < 1.0e25) && (Vgs > phi) && (epsgate!=0)) begin \
        T9 = 1.0e6 * `P_Q * epsgate * ngate / (coxe * coxe); \
        T8 = Vgs - phi;   \
        T4 = sqrt(1.0 + 2.0 * T8 / T9);  \
        T2 = 2.0 * T8 / (T4 + 1.0);  \
        T3 = 0.5 * T2 * T2 / T9; \
        T7 = 1.12 - T3 - 0.05; \
        T6 = sqrt(T7 * T7 + 0.224); \
        T5 = 1.12 - 0.5 * (T7 + T6); \
        Vgs_eff = Vgs - T5; \
        dVgs_eff_dVg = 1.0 - (0.5 - 0.5 / T4) * (1.0 + T7 / T6);  \
    end  \
    else begin \
        Vgs_eff = Vgs; \
        dVgs_eff_dVg = 1.0; \
    end


`define BSIM4RdsEndIso(Weffcj, Rsh, DMCG, DMCI, DMDG, nuEnd, rgeo, Type, Rend) \
    if (Type == 1) begin \
        case (rgeo) \
            1, 2, 5: begin \
                if (nuEnd == 0.0) \
                    Rend = 0.0; \
                else \
                    Rend = Rsh * DMCG / (Weffcj * nuEnd); \
            end \
            3, 4, 6: begin \
                if ((DMCG + DMCI) == 0.0) begin \
                    $strobe("(DMCG + DMCI) can not be equal to zero\n"); \
                    if (DMCG == 0.0) \
                        DMCG = 0.2e-6; \
                    if (DMCI == 0.0) \
                        DMCI = 0.2e-6; \
                end \
                if ( (nuEnd == 0.0) || ((DMCG+DMCI)==0.0)) \
                    Rend = 0.0; \
                else \
                    Rend = Rsh * Weffcj / (3.0 * nuEnd * (DMCG + DMCI)); \
            end \
            default:  \
            $strobe("Warning: (instance X*) Specified RGEO = %d not matched (BSIM4RdsEndIso)\n", \
                     rgeo); \
        endcase \
    end \
    else begin \
        case (rgeo) \
            1, 3, 7: begin \
                if (nuEnd == 0.0) \
                    Rend = 0.0; \
                else \
                    Rend = Rsh * DMCG / (Weffcj * nuEnd); \
            end \
            2, 4, 8: begin \
                if ((DMCG + DMCI) == 0.0) begin \
                    $strobe("(DMCG + DMCI) can not be equal to zero\n"); \
                    if (DMCG == 0.0) \
                        DMCG = 0.2e-6; \
                    if (DMCI == 0.0) \
                        DMCI = 0.2e-6; \
                end \
                if ( (nuEnd == 0.0) || ((DMCG+DMCI)==0.0)) \
                    Rend = 0.0; \
                else \
                    Rend = Rsh * Weffcj / (3.0 * nuEnd * (DMCG + DMCI)); \
            end \
            default: \
            $strobe("Warning: (instance X*) Specified RGEO=%d not matched (BSIM4RdsEndIso type !=1)\n", rgeo); \
        endcase \
    end


`define BSIM4RdsEndSha(Weffcj, Rsh, DMCG, DMCI, DMDG, nuEnd, rgeo, Type, Rend) \
    begin \
        if (Type == 1) begin \
            case (rgeo) \
                1, 2, 5: begin \
                    if (nuEnd == 0.0) \
                        Rend = 0.0; \
                    else \
                        Rend = Rsh * DMCG / (Weffcj * nuEnd); \
                end \
                3, 4, 6: begin \
                    if (DMCG == 0.0) begin \
                        $strobe("DMCG can not be equal to zero\n"); \
                        DMCG = 0.2e-6; \
                    end \
                    if (nuEnd == 0.0) \
                        Rend = 0.0; \
                    else \
                        Rend = Rsh * Weffcj / (6.0 * nuEnd * DMCG); \
                end \
                default: \
                $strobe("Warning: (instance X*) Specified RGEO=%d not matched (BSIM4RdsEndSha)\n", rgeo); \
            endcase \
        end \
        else begin \
            case (rgeo) \
                1, 3, 7: begin \
                    if (nuEnd == 0.0) \
                        Rend = 0.0; \
                    else \
                        Rend = Rsh * DMCG / (Weffcj * nuEnd); \
                end \
                2, 4, 8: begin \
                    if (DMCG == 0.0) begin \
                        $strobe("DMCG can not be equal to zero\n"); \
                        DMCG = 0.2e-6; \
                    end \
                    if (nuEnd == 0.0) \
                        Rend = 0.0; \
                    else \
                        Rend = Rsh * Weffcj / (6.0 * nuEnd * DMCG); \
                end \
                default: \
                $strobe("Warning: (instance X*) Specified RGEO=%d not matched (BSIM4RdsEndSha type !=1)\n", rgeo); \
            endcase \
        end \
    end


`define BSIM4RdseffGeo(nf, geo, rgeo, minSD, Weffcj, Rsh, DMCG, DMCI, DMDG, Type, Rtot) \
    begin \
        if (geo < 9) begin \
            `BSIM4NumFingerDiff(nf, minSD, nuIntD, nuEndD, nuIntS, nuEndS) \
            if (Type == 1) begin \
                if (nuIntS == 0.0) \
                    Rint = 0.0; \
                else \
                    Rint = Rsh * DMCG / ( Weffcj * nuIntS); \
            end \
            else begin \
                if (nuIntD == 0.0) \
                    Rint = 0.0; \
                else        \
                    Rint = Rsh * DMCG / ( Weffcj * nuIntD); \
            end \
        end \
        case (geo) \
            0: begin \
                if (Type == 1) \
                    `BSIM4RdsEndIso(Weffcj, Rsh, DMCG, DMCI, DMDG, nuEndS, \
                   rgeo, 1, Rend) \
                else \
                    `BSIM4RdsEndIso(Weffcj, Rsh, DMCG, DMCI, DMDG, nuEndD, \
                   rgeo, 0, Rend) \
            end \
            1: begin \
                if (Type == 1) \
                    `BSIM4RdsEndIso(Weffcj, Rsh, DMCG, DMCI, DMDG, nuEndS, \
                   rgeo, 1, Rend) \
                else \
                    `BSIM4RdsEndSha(Weffcj, Rsh, DMCG, DMCI, DMDG, nuEndD, \
                   rgeo, 0, Rend) \
            end \
            2: begin \
                if (Type == 1) \
                    `BSIM4RdsEndSha(Weffcj, Rsh, DMCG, DMCI, DMDG, nuEndS, \
                   rgeo, 1, Rend) \
                else   \
                    `BSIM4RdsEndIso(Weffcj, Rsh, DMCG, DMCI, DMDG, nuEndD, \
                   rgeo, 0, Rend) \
            end \
            3: begin \
                if (Type == 1) \
                    `BSIM4RdsEndSha(Weffcj, Rsh, DMCG, DMCI, DMDG, nuEndS, \
                   rgeo, 1, Rend) \
                else  \
                    `BSIM4RdsEndSha(Weffcj, Rsh, DMCG, DMCI, DMDG, nuEndD, \
                   rgeo, 0, Rend) \
            end \
            4: begin \
                if (Type == 1) \
                    `BSIM4RdsEndIso(Weffcj, Rsh, DMCG, DMCI, DMDG, nuEndS, \
                  rgeo, 1, Rend) \
                else \
                    Rend = Rsh * DMDG / Weffcj; \
            end \
            5: begin \
                if (Type == 1) \
                    `BSIM4RdsEndSha(Weffcj, Rsh, DMCG, DMCI, DMDG, nuEndS, \
                  rgeo, 1, Rend) \
                else  \
                    Rend = Rsh * DMDG / (Weffcj * nuEndD); \
            end \
            6: begin \
                if (Type == 1) \
                    Rend = Rsh * DMDG / Weffcj; \
                else   \
                    `BSIM4RdsEndIso(Weffcj, Rsh, DMCG, DMCI, DMDG, nuEndD, \
                   rgeo, 0, Rend) \
            end \
            7: begin \
                if (Type == 1) \
                    Rend = Rsh * DMDG / (Weffcj * nuEndS); \
                else  \
                    `BSIM4RdsEndSha(Weffcj, Rsh, DMCG, DMCI, DMDG, nuEndD, \
                   rgeo, 0, Rend) \
            end \
            8: begin \
                Rend = Rsh * DMDG / Weffcj; \
            end \
            9: begin  /* all wide contacts assumed for geo = 9 and 10 */ \
                if (Type == 1) begin \
                    Rend = 0.5 * Rsh * DMCG / Weffcj; \
                    if (nf == 2.0) \
                        Rint = 0.0; \
                    else \
                        Rint = Rsh * DMCG / (Weffcj * (nf - 2.0)); \
                end \
                else begin \
                    Rend = 0.0; \
                    Rint = Rsh * DMCG / (Weffcj * nf); \
                end \
            end \
            10: begin \
                if (Type == 1) begin \
                    Rend = 0.0; \
                    Rint = Rsh * DMCG / (Weffcj * nf); \
                end \
                else begin \
                    Rend = 0.5 * Rsh * DMCG / Weffcj; \
                    if (nf == 2.0) \
                        Rint = 0.0; \
                    else \
                        Rint = Rsh * DMCG / (Weffcj * (nf - 2.0)); \
                end \
            end \
            default: \
            $strobe("Warning: (instance X*) Specified GEO=%d not matched (BSIM4RdseffGeo)", \
                     geo); \
        endcase \
        if (Rint <= 0.0) \
            Rtot = Rend; \
        else if (Rend <= 0.0) \
            Rtot = Rint; \
        else \
            Rtot = Rint * Rend / (Rint + Rend); \
        if (Rtot==0.0) \
            $strobe("Warning: (instance X*) Zero resistance returned from RdseffGeo\n"); \
    end

//  Macros for the model/instance parameters
//
//  MPRxx    model    parameter real
//  MPIxx    model    parameter integer
//  IPRxx    instance parameter real
//  IPIxx    instance parameter integer
//     ||
//     cc    closed lower bound, closed upper bound
//     oo    open   lower bound, open   upper bound
//     co    closed lower bound, open   upper bound
//     oc    open   lower bound, closed upper bound
//     cz    closed lower bound=0, open upper bound=inf
//     oz    open   lower bound=0, open upper bound=inf
//     nb    no bounds
//     ex    no bounds with exclude
//     sw    switch(integer only, values  0=false  and  1=true)
//     ty    switch(integer only, values -1=p-type and +1=n-type)
//
//  IPM   instance parameter mFactor(multiplicity, implicit for LRM2.2)
//  OPP   operating point parameter, includes units and description for printing
//
`define OPP(nam,uni,des)               (*units=uni,                   desc=des*)           real    nam ;

`define MPRnb(nam,def,uni,        des) (*units=uni,                   desc=des*) parameter real    nam=def ;
`define MPRex(nam,def,uni,exc,    des) (*units=uni,                   desc=des*) parameter real    nam=def exclude exc ;
`define MPRcc(nam,def,uni,lwr,upr,des) (*units=uni,                   desc=des*) parameter real    nam=def from[lwr:upr] ;
`define MPRoo(nam,def,uni,lwr,upr,des) (*units=uni,                   desc=des*) parameter real    nam=def from(lwr:upr) ;
`define MPRco(nam,def,uni,lwr,upr,des) (*units=uni,                   desc=des*) parameter real    nam=def from[lwr:upr) ;
`define MPRoc(nam,def,uni,lwr,upr,des) (*units=uni,                   desc=des*) parameter real    nam=def from(lwr:upr] ;
`define MPRcz(nam,def,uni,        des) (*units=uni,                   desc=des*) parameter real    nam=def from[  0:inf);
`define MPRoz(nam,def,uni,        des) (*units=uni,                   desc=des*) parameter real    nam=def from(  0:inf);

`define MPInb(nam,def,uni,        des) (*units=uni,                   desc=des*) parameter integer nam=def ;
`define MPIex(nam,def,uni,exc,    des) (*units=uni,                   desc=des*) parameter integer nam=def exclude exc ;
`define MPIcc(nam,def,uni,lwr,upr,des) (*units=uni,                   desc=des*) parameter integer nam=def from[lwr:upr] ;
`define MPIoo(nam,def,uni,lwr,upr,des) (*units=uni,                   desc=des*) parameter integer nam=def from(lwr:upr) ;
`define MPIco(nam,def,uni,lwr,upr,des) (*units=uni,                   desc=des*) parameter integer nam=def from[lwr:upr) ;
`define MPIoc(nam,def,uni,lwr,upr,des) (*units=uni,                   desc=des*) parameter integer nam=def from(lwr:upr] ;
`define MPIcz(nam,def,uni,        des) (*units=uni,                   desc=des*) parameter integer nam=def from[  0:inf);
`define MPIoz(nam,def,uni,        des) (*units=uni,                   desc=des*) parameter integer nam=def from(  0:inf);

`define MPIsw(nam,def,uni,        des) (*units=uni,                   desc=des*) parameter integer nam=def from[  0:  1] ;
`define MPIty(nam,def,uni,        des) (*units=uni,                   desc=des*) parameter integer nam=def from[ -1:  1] exclude 0 ;

`define IPRnb(nam,def,uni,        des) (*units=uni, type="instance",  desc=des*) parameter real    nam=def ;
`define IPRex(nam,def,uni,exc,    des) (*units=uni, type="instance",  desc=des*) parameter real    nam=def exclude exc ;
`define IPRcc(nam,def,uni,lwr,upr,des) (*units=uni, type="instance",  desc=des*) parameter real    nam=def from[lwr:upr] ;
`define IPRoo(nam,def,uni,lwr,upr,des) (*units=uni, type="instance",  desc=des*) parameter real    nam=def from(lwr:upr) ;
`define IPRco(nam,def,uni,lwr,upr,des) (*units=uni, type="instance",  desc=des*) parameter real    nam=def from[lwr:upr) ;
`define IPRoc(nam,def,uni,lwr,upr,des) (*units=uni, type="instance",  desc=des*) parameter real    nam=def from(lwr:upr] ;
`define IPRcz(nam,def,uni,        des) (*units=uni, type="instance",  desc=des*) parameter real    nam=def from[  0:inf);
`define IPRoz(nam,def,uni,        des) (*units=uni, type="instance",  desc=des*) parameter real    nam=def from(  0:inf);

`define IPInb(nam,def,uni,        des) (*units=uni, type="instance",  desc=des*) parameter integer nam=def ;
`define IPIex(nam,def,uni,exc,    des) (*units=uni, type="instance",  desc=des*) parameter integer nam=def exclude exc ;
`define IPIcc(nam,def,uni,lwr,upr,des) (*units=uni, type="instance",  desc=des*) parameter integer nam=def from[lwr:upr] ;
`define IPIoo(nam,def,uni,lwr,upr,des) (*units=uni, type="instance",  desc=des*) parameter integer nam=def from(lwr:upr) ;
`define IPIco(nam,def,uni,lwr,upr,des) (*units=uni, type="instance",  desc=des*) parameter integer nam=def from[lwr:upr) ;
`define IPIoc(nam,def,uni,lwr,upr,des) (*units=uni, type="instance",  desc=des*) parameter integer nam=def from(lwr:upr] ;
`define IPIcz(nam,def,uni,        des) (*units=uni, type="instance",  desc=des*) parameter integer nam=def from[  0:inf);
`define IPIoz(nam,def,uni,        des) (*units=uni, type="instance",  desc=des*) parameter integer nam=def from(  0:inf);

module bsim4va(d, g, s, b);

    analog function real BSIM4DioIjthVjmEval;

        input Nvtm, Ijth, Isb, XExpBV;
        real  Nvtm, Ijth, Isb, XExpBV;
        real  Tb, Tc, EVjmovNv;

        begin
            Tc = XExpBV;
            Tb = 1.0 + Ijth / Isb - Tc;
            EVjmovNv = 0.5 * (Tb + sqrt(Tb * Tb + 4.0 * Tc));
            BSIM4DioIjthVjmEval = Nvtm * ln(EVjmovNv);
        end
    endfunction


    //
    //   Node definitions
    //
    inout      d, g, s, b;
    electrical d, g, s, b,di, si,gi, gm,bi,sbulk,dbulk;

    branch (d,di) br_v_d_di, br_i_d_di;
    branch (s,si) br_v_s_si, br_i_s_si;

    // The parameter "type" should be set for N/P-MOSFET
    // based on modelcard type (but can be overridden by netlist).
    `MPIcc( verbose        ,0              ,""            ,0           ,1           ,"debug flag to print DBG msg" )
    `MPIcc( type           ,1              ,""            ,-1          ,1           ,"NMOS=1 PMOS=-1" )
    `IPRoz( l              ,10u            ,"m"                                     ,"Length" )
    `IPRoz( w              ,10u            ,"m"                                     ,"Total width including fingers" )
    `IPIco( nf             ,1              ,""            ,1           ,inf         ,"Number of fingers" )
    `IPRcz( nrs            ,1.0            ,""                                      ,"Number of squares in source" )
    `IPRcz( nrd            ,1.0            ,""                                      ,"Number of squares in drain" )
    `IPRcz( as             ,0.0            ,""                                      ,"Source to Substrate Junction Area" )
    `IPRcz( ad             ,0.0            ,""                                      ,"Drain to Substrate Junction Area" )
    `IPRcz( ps             ,0.0            ,""                                      ,"Source to Substrate Junction Perimeter" )
    `IPRcz( pd             ,0.0            ,""                                      ,"Drain to Substrate Junction Perimeter" )
    `IPIcc( rgeomod        ,0              ,""            ,0           ,8           ,"Geometry-dependent source/drain resistance,  0: RSH-based, 1: Holistic" )
    `IPIcc( minsd          ,0              ,""            ,0           ,1           ,"Minimize either D or S" )
    `IPIcc( off            ,0              ,""            ,0           ,1           ,"Device is initially off" )
    `MPIcc( trnqsmod       ,0              ,""            ,0           ,1           ,"Transient NQS model selector" )
    `MPIcc( acnqsmod       ,0              ,""            ,0           ,1           ,"AC NQS model selector" )
    `MPIcc( rgatemod       ,0              ,""            ,0           ,3           ,"Gate resistance model selector" )
    `MPIcc( rbodymod       ,0              ,""            ,0           ,2           ,"Distributed body R model" )
    `MPIcc( geomod         ,0              ,""            ,0           ,10          ,"Geo dependent parasitics model" )
    `MPIcc( capmod         ,2              ,""            ,0           ,2           ,"Capacitance model selector" )
    `MPIcc( diomod         ,1              ,""            ,0           ,1           ,"Diode IV model selector" )
    `MPIcc( rdsmod         ,0              ,""            ,0           ,1           ,"Bias-dep S/D resistance model" )
    `MPIcc( level          ,54             ,""            ,0           ,100         ,"Ignored, for Spice compatibility" )
    `MPIcc( mobmod         ,0              ,""            ,0           ,1           ,"Mobility model selector" )
    `MPIcc( tempmod        ,0              ,""            ,0           ,1           ,"Temperature model" )
    `MPIcc( permod         ,1              ,""            ,0           ,1           ,"Pd and Ps model selector" )
    `MPIcc( fnoimod        ,1              ,""            ,0           ,1           ,"Flicker noise model selector" )
    `MPIcc( tnoimod        ,0              ,""            ,0           ,1           ,"Thermal noise model selector" )
    `MPIcc( igcmod         ,0              ,""            ,0           ,1           ,"Gate-to-channel Ig model select" )
    `MPIcc( igbmod         ,0              ,""            ,0           ,1           ,"Gate-to-body Ig model selector" )
    `MPIcc( paramchk       ,1              ,""            ,0           ,1           ,"Model parameter checking" )
    `MPIcc( binunit        ,1              ,""            ,0           ,1           ,"Bin unit selector" )

    `MPRcc( version ,4.8              ,""            ,0.0           ,5.0         ,"Parameter for model version")
    `MPRoc( toxe  ,3.0e-9              ,"m"         ,0.0           ,1.0e-6      ,"Electrical gate oxide")
    `MPRcc( toxp  ,3.0e-9              ,"m"         ,0.0           ,1.0e-6      ,"Physical gate oxide thickness")
    `MPRcc( toxm  ,3.0e-9              ,"m"            ,0.0           ,1.0e-6      ,"tox at which parameters are extracted")
    `MPRoc( toxref  ,3.0e-9              ,"m"            ,0.0           ,1.0          ,"Target tox value")
    `MPRcc( dtox  ,0.0              ,"m"            ,0.0           ,1.0            ,"Defined as (toxe - toxp)")
    `MPRcc( epsrox  ,3.9              ,""            ,0.0           ,6.0          ,"Rel dielectric constant gate oxide")
    `MPRcc( cdsc  ,2.4e-4              ,"F/m2"            ,0.0           ,1.0            ,"Drain/Source and channel coupling cap")
    `MPRcc( cdscb  ,0.0              ,"F/(Vm2)"            ,0.0           ,1.0           ,"Body-bias dependence of cdsc")
    `MPRcc( cdscd  ,0.0              ,"F/(Vm2)"            ,0.0           ,1.0           ,"Drain-bias dependence of cdsc")
    `MPRcc( cit  ,0.0              ,"F/m2"            ,0.0           ,1.0             ,"Interface state capacitance")
    `MPRcc( nfactor  ,1.0              ,""            ,0.0           ,5.0         ,"Subthreshold swing Coefficient")
    `MPRcc( xj  ,1.5e-7              ,"m"            ,0.0           ,1.0              ,"Junction depth")
    `MPRcc( vsat  ,8.0e4              ,"m/s"            ,0.0           ,1.0e8            ,"Saturation velocity at tnom")
    `MPRcc( at  ,3.3e4              ,""            ,0.0           ,1.0e8              ,"Temperature coefficient of vsat")
    `MPRcc( a0  ,1.0              ,""            ,0.0           ,10.0              ,"Non-uniform depletion width effect coeff")
    `MPRcc( ags  ,0.0              ,"1/V"            ,0.0           ,1.0             ,"Gate bias coeff of Abulk.")
    `MPRcc( a1  ,0.0              ,"1/V"            ,0.0           ,1.0              ,"Non-saturation effect coeff")
    `MPRcc( a2  ,1.0              ,""            ,0.0           ,10.0              ,"Non-saturation effect coeff")
    `MPRcc( keta  ,-0.047              ,"1/V"            ,-1.0           ,1.0            ,"Body-bias coeff of non-u deplet width")
    `MPRcc( nsub  ,6.0e16              ,"cm-3"            ,0.0           ,1.0e19            ,"Substrate doping concentration")
    `MPRcc( ndep  ,1.7e17              ,"cm-3"            ,0.0           ,1.0e20            ,"Channel doping conc at the depl edge")
    `MPRcc( nsd  ,1.0e20              ,"cm-3"            ,0.0           ,1.0e30             ,"S/D doping concentration")
    `MPRcc( phin  ,0.0              ,"V"            ,0.0           ,1.0            ,"Adjusting parameter for surface potential")
    `MPRcc( ngate  ,0.0             ,"cm-3"            ,0.0           ,1.0e24           ,"Poly-gate doping concentration")
    `MPRcc( gamma1  ,0.0              ,""            ,0.0           ,1.0          ,"Vth body coeff")
    `MPRcc( gamma2  ,0.0              ,""            ,0.0           ,1.0          ,"Vth body coeff")
    `MPRcc( vbx  ,0.0              ,"V"            ,0.0           ,1.0             ,"Vth transition body Voltage")
    `MPRcc( vbm  ,-3.0              ,"V"            ,-10.0           ,10.0             ,"Maximum body voltage")
    `MPRcc( xt  ,1.55e-7             ,"m"            ,0.0           ,1.0              ,"Doping depth")
    `MPRcc( k1  ,0.5              ,"V-1/2"            ,0.0           ,5.0              ,"Bulk effect coeff 1")
    `MPRcc( kt1  ,-0.11              ,""            ,-1.0           ,1.0             ,"Temperature coeff of Vth")
    `MPRcc( kt1l  ,0.0              ,""            ,0.0           ,1.0            ,"Temperature coeff of Vth")
    `MPRcc( kt2  ,0.022             ,""            ,-1.0           ,1.0             ,"Body-coeff of kt1")
    `MPRcc( k2  ,0.0              ,""            ,-1.0           ,1.0              ,"Bulk effect coeff 2")
    `MPRcc( k3  ,80.0              ,""            ,0.0           ,1000.0           ,"Narrow width effect coeff")
    `MPRcc( k3b  ,0.0              ,"1/V"            ,0.0           ,1.0             ,"Body effect coeff of k3")
    `MPRcc( w0  ,2.5e-6              ,"m"            ,0.0           ,1.0              ,"Narrow width effect parameter")
    `MPRcc( dvtp0  ,0.0              ,"m"            ,0.0           ,1.0           ,"1st parm for Vth shift due to pocket")
    `MPRcc( dvtp1  ,0.0              ,""            ,0.0           ,1.0           ,"2nd parm for Vth shift due to pocket")
    `MPRcc( lpe0  ,1.74e-7          ,"m"            ,0.0           ,1.0            ,"Eq. length of pocket region at zero bias")
    `MPRcc( lpeb  ,0.0              ,"m"            ,0.0           ,1.0            ,"Eq. length accounting for body")
    `MPRcc( dvt0  ,2.2              ,""            ,0.0           ,10.0            ,"Short channel effect coeff. 0")
    `MPRcc( dvt1  ,0.53              ,""            ,0.0           ,3.0            ,"Short channel effect coeff. 1")
    `MPRcc( dvt2  ,-0.032           ,""            ,-1.0           ,1.0            ,"Short channel effect coeff. 2")
    `MPRcc( dvt0w  ,0.0              ,""            ,0.0           ,1.0           ,"Narrow Width coeff. 0")
    `MPRcc( dvt1w  ,5.3e6              ,""            ,0.0           ,1e9           ,"Narrow Width effect coeff. 1")
    `MPRcc( dvt2w  ,-0.032              ,""            ,-1.0           ,1.0           ,"Narrow Width effect coeff. 2")
    `MPRcc( drout  ,0.56              ,""            ,0.0           ,1.0           ,"DIBL coeff of output resistance")
    `MPRcc( dsub  ,0.56              ,""            ,0.0           ,10.0            ,"DIBL coeff in the subthreshold region")
    `MPRcc( vth0  ,0.7              ,"V"            ,-3.0           ,3.0            ,"Threshold voltage")
    `MPRcc( ua  ,1e-9              ,""            ,0.0           ,1.0              ,"Linear gate dependence of mobility")
    `MPRcc( ua1  ,1.0e-9              ,""            ,0.0           ,1.0             ,"Temperature coeff of ua")
    `MPRcc( ub  ,1e-19              ,""            ,0.0           ,1.0              ,"Quadratic gate dependence of mobility")
    `MPRcc( ub1  ,-1.0e-18             ,""            ,-1.0           ,1.0             ,"Temperature coeff of ub")
    `MPRcc( uc  ,-0.0465              ,""            ,-1.0           ,1.0              ,"Body-bias dependence of mobility")
    `MPRcc( uc1  ,0.056            ,""            ,-1.0           ,1.0             ,"Temperature coeff of uc")
    `MPRcc( u0  ,0.067              ,"m^2/((Vs)"            ,0.0           ,1.0              ,"Low-field mobility at Tnom")
    `MPRcc( eu  ,1.67              ,""            ,0.0           ,10.0              ,"Mobility exponent")
    `MPRcc( ute  ,-1.5             ,""            ,-3.0           ,3.0             ,"Temperature coeff of mobility")
    `MPRcc( voff  ,-0.08              ,"V"            ,-1.0           ,1.0            ,"Threshold voltage offset")
    `MPRcc( minv  ,0.0              ,""            ,0.0           ,1.0            ,"Fitting parm for moderate inv in Vgsteff")
    `MPRcc( voffl  ,0.0              ,""            ,0.0           ,1.0           ,"Length dependence parm for Vth offset")
    `MPRcc( tnom  ,27.0              ,"C"            ,-200.0           ,300.0            ,"Parameter measurement temperature")
    `MPRcc( cgso  ,0.0              ,"F"            ,0.0           ,1.0            ,"Gate-source overlap capacitance per width")
    `MPRcc( cgdo  ,0.0              ,"F"            ,0.0           ,1.0            ,"Gate-drain overlap capacitance per width")
    `MPRcc( cgbo  ,0.0              ,"F"            ,0.0           ,1.0            ,"Gate-bulk overlap capacitance per length")
    `MPRcc( xpart  ,0.0              ,""            ,0.0           ,1.0           ,"Channel charge partitioning")
    `MPRcc( delta  ,0.01              ,"V"            ,0.0           ,1.0           ,"Effective Vds parameter")
    `MPRcc( rsh  ,0.0              ,"Ohm"            ,0.0           ,1.0e3             ,"Source-drain sheet resistance")
    `MPRcc( rdsw  ,200.0              ,"Ohm"            ,0.0           ,1.0e4            ,"Source-drain resistance per width")
    `MPRcc( rdswmin  ,0.0              ,"Ohm"            ,0.0           ,1.0         ,"Source-drain res per width at high Vg")
    `MPRcc( rsw  ,100.0              ,"Ohm"            ,0.0           ,1.0e4             ,"Source resistance per width")
    `MPRcc( rdw  ,100.0              ,"Ohm"            ,0.0           ,1.0e4             ,"Drain resistance per width")
    `MPRcc( rdwmin  ,0.0              ,"Ohm"            ,0.0           ,1.0          ,"Drain res per width at high Vg")
    `MPRcc( rswmin  ,0.0              ,"Ohm"            ,0.0           ,1.0          ,"Source res per width at high Vg")
    `MPRcc( prwg  ,1.0              ,"1/V"            ,0.0           ,10.0            ,"Gate-bias effect on parasitic resistance")
    `MPRcc( prwb  ,0.0              ,"V-1/2"            ,0.0           ,1.0            ,"Body-effect on parasitic resistance")
    `MPRcc( prt  ,0.0              ,""            ,0.0           ,1.0             ,"Temperature coeff of parasitic resistance")
    `MPRcc( eta0  ,0.08              ,""            ,0.0           ,1.0            ,"Subthreshold region DIBL coeff")
    `MPRcc( etab  ,-0.07              ,"1/V"            ,-1.0           ,1.0            ,"Subthreshold region DIBL coeff")
    `MPRcc( pclm  ,1.3              ,""            ,0.0           ,10.0            ,"Channel length modulation Coefficient")
    `MPRcc( pdiblc1  ,0.39              ,""            ,0.0           ,1.0         ,"Drain-induced barrier lowering coeff")
    `MPRcc( pdiblc2  ,0.0086            ,""            ,0.0           ,1.0         ,"Drain-induced barrier lowering coeff")
    `MPRcc( pdiblcb  ,0.0              ,"1/V"            ,-1.0           ,1.0         ,"Body-eff on drain-ind barrier lowering")
    `MPRcc( fprout  ,0.0              ,""            ,0.0           ,1.0          ,"Rout degradation coeff for pocket dev")
    `MPRcc( pdits  ,0.0              ,""            ,0.0           ,1.0           ,"Coefficient for drain-induced Vth shifts")
    `MPRcc( pditsl  ,0.0              ,"1/m"            ,0.0           ,1.0e8          ,"L dep of drain-induced Vth shifts")
    `MPRcc( pditsd  ,0.0              ,"1/V"            ,0.0           ,1.0          ,"Vds dep of drain-induced Vth shifts")
    `MPRcc( pscbe1  ,4.24e8              ,"V/m"            ,0.0           ,1.0e10          ,"Substrate current body-effect coeff")
    `MPRcc( pscbe2  ,1.0e-5              ,"m/V"            ,0.0           ,1.0          ,"Substrate current body-effect coeff")
    `MPRcc( pvag  ,0.0              ,""            ,0.0           ,1.0            ,"Gate dep of output resistance parameter")
    `MPRcc( jss  ,1.0e-4              ,""            ,0.0           ,1.0             ,"Bottom S jun rev sat current density")
    `MPRcc( jsws  ,0.0              ,""            ,0.0           ,1.0            ,"Iso edge sidewall S junc rev sat current")
    `MPRcc( jswgs  ,0.0              ,""            ,0.0           ,1.0           ,"Gate edge S jun rev sat current density")
    `MPRcc( pbs  ,1.0              ,"V"            ,0.0           ,3.0             ,"Source junction built-in potential")
    `MPRoc( njs  ,1.0              ,""            ,0.0           ,10.0             ,"Source junction emission coeff")
    `MPRcc( xtis  ,3.0              ,""            ,0.0           ,10.0            ,"Source junction current temperature exp")
    `MPRcc( mjs  ,0.5              ,""            ,0.0           ,1.0             ,"Source bottom junction cap grading coeff")
    `MPRcc( pbsws  ,1.0              ,"V"            ,0.0           ,3.0           ,"Source sidewall jun cap built in pot")
    `MPRcc( mjsws  ,0.33              ,""            ,0.0           ,1.0           ,"Source sidewall jun cap grading coeff")
    `MPRcc( pbswgs  ,1.0              ,""            ,0.0           ,3.0          ,"S (g side) swall jun cap built in")
    `MPRcc( mjswgs  ,0.33              ,""            ,0.0           ,1.0          ,"S (g side) swall jun cap grading coeff")
    `MPRcc( cjs  ,5.0e-4              ,"F"            ,0.0           ,1.0             ,"S bottom jun capacitance per unit area")
    `MPRcc( cjsws  ,5.0e-10              ,"F"            ,0.0           ,1.0           ,"S sidewall jun cap per unit periphery")
    `MPRcc( cjswgs  ,5.0e-10              ,"F"            ,0.0           ,1.0          ,"S (g side) swall jun cap per unit")
    `MPRcc( jsd  ,1.0e-4            ,""            ,0.0           ,1.0             ,"Bottom D jun rev sat current density")
    `MPRcc( jswd  ,0.0              ,""            ,0.0           ,1.0            ,"Iso edge swall drain jun rev sat current")
    `MPRcc( jswgd  ,0.0              ,""            ,0.0           ,1.0           ,"Gate edge d jun rev sat current density")
    `MPRcc( pbd  ,1.0              ,"V"            ,0.0           ,3.0             ,"Drain junction built-in potential")
    `MPRcc( njd  ,0.0              ,""            ,0.0           ,1.0             ,"Drain junction emission coeff")
    `MPRcc( xtid  ,0.0              ,""            ,0.0           ,10.0            ,"D junction current temperature exponent")
    `MPRcc( mjd  ,0.5              ,""            ,0.0           ,1.0             ,"Drain bottom junc cap grading coeff")
    `MPRcc( pbswd  ,1.0              ,"V"            ,0.0           ,3.0           ,"Drain swall jun cap built in potential")
    `MPRcc( mjswd  ,0.33              ,""            ,0.0           ,1.0           ,"Drain swall jun cap grading coeff")
    `MPRcc( pbswgd  ,1.0              ,"V"            ,0.0           ,3.0          ,"Drain (g side) swall jun cap built in")
    `MPRcc( mjswgd  ,0.33              ,""            ,0.0           ,1.0          ,"D (g side) swall jun cap grading coeff")
    `MPRcc( cjd  ,5.0e-4              ,""            ,0.0           ,1.0             ,"D bottom jun capacitance per unit area")
    `MPRcc( cjswd  ,5.0e-10              ,""            ,0.0           ,1.0           ,"Drain swall jun cap per unit periphery")
    `MPRcc( cjswgd  ,5.0e-10              ,""            ,0.0           ,1.0          ,"Drain (g side) swall jun cap per unit")
    `MPRcc( vfbcv  ,-1.0              ,"V"            ,-3.0           ,3.0           ,"Flat Band Voltage parm for capmod=0")
    `MPRcc( vfb  ,-1.0              ,"V"            ,-3.0           ,3.0             ,"Flat Band Voltage")
    `MPRcc( tpb  ,0.0              ,""            ,0.0           ,1.0             ,"Temperature coeff of pb")
    `MPRcc( tcj  ,0.0              ,""            ,0.0           ,1.0             ,"Temperature coeff of cj")
    `MPRcc( tpbsw  ,0.0              ,""            ,0.0           ,1.0           ,"Temperature coeff of pbsw")
    `MPRcc( tcjsw  ,0.0              ,""            ,0.0           ,1.0           ,"Temperature coeff of cjsw")
    `MPRcc( tpbswg  ,0.0              ,""            ,0.0           ,1.0          ,"Temperature coeff of pbswg")
    `MPRcc( tcjswg  ,0.0              ,""            ,0.0           ,1.0          ,"Temperature coeff of cjswg")
    `MPRcc( acde  ,1.0              ,"m/V"            ,0.0           ,1.0            ,"Exp coeff for finite charge thickness")
    `MPRcc( moin  ,15.0              ,""            ,0.0           ,100.0            ,"Coeff for gate-bias dep surf potential")
    `MPRcc( noff  ,1.0              ,""            ,0.0           ,3.0            ,"C-V turn-on/off parameter")
    `MPRcc( voffcv  ,0.0              ,"V"            ,-1.0           ,1.0          ,"C-V lateral-shift parameter")
    `MPRcc( dmcg  ,0.0              ,"m"            ,0.0           ,1.0            ,"Distance of Mid-Contact to Gate edge")
    `MPRcc( dmci  ,0.0              ,"m"            ,0.0           ,1.0            ,"Distance of Mid-Contact to Isolation")
    `MPRcc( dmdg  ,0.0              ,"m"            ,0.0           ,1.0            ,"Distance of Mid-Diffusion to Gate edge")
    `MPRcc( dmcgt  ,0.0              ,"m"            ,0.0           ,1.0           ,"Dist of Mid-Contact to Gate edge in Test")
    `MPRcc( xgw  ,0.0              ,"m"            ,0.0           ,1.0             ,"Dist from gate contact center to dev edge")
    `MPRcc( xgl  ,0.0              ,"m"            ,0.0           ,1.0             ,"Variation in Ldrawn")
    `MPRcc( rshg  ,0.1              ,"Ohm"            ,0.0           ,100.0            ,"Gate sheet resistance")
    `MPRoc( ngcon  ,1.0              ,""            ,0.0           ,1.0e4           ,"Number of gate contacts")
    `MPRcc( xrcrg1  ,12.0              ,""            ,0.0           ,100.0          ,"1st fitting parm the bias-dependent Rg")
    `MPRcc( xrcrg2  ,1.0              ,""            ,0.0           ,10.0          ,"2nd fitting parm the bias-dependent Rg")
    `MPRcc( lint  ,0.0              ,"m"            ,0.0           ,1.0            ,"Length reduction parameter")
    `MPRcc( ll  ,0.0              ,"m"            ,0.0           ,1.0              ,"Length reduction parameter")
    `MPRcc( llc  ,0.0              ,"m"            ,0.0           ,1.0             ,"Length reduction parameter for CV")
    `MPRcc( lln  ,1.0              ,"m"            ,0.0           ,10.0             ,"Length reduction parameter")
    `MPRcc( lw  ,0.0              ,"m"            ,0.0           ,1.0              ,"Length reduction parameter")
    `MPRcc( lwc  ,0.0              ,"m"            ,0.0           ,1.0             ,"Length reduction parameter for CV")
    `MPRcc( lwn  ,0.0              ,"m"            ,0.0           ,1.0             ,"Length reduction parameter")
    `MPRcc( lwl  ,0.0              ,"m"            ,0.0           ,1.0             ,"Length reduction parameter")
    `MPRcc( lwlc  ,0.0              ,"m"            ,0.0           ,1.0            ,"Length reduction parameter for CV")
    `MPRcc( lmin  ,0.0              ,"m"            ,0.0           ,1.0            ,"Minimum length for the model")
    `MPRcc( lmax  ,1.0              ,"m"            ,0.0           ,10.0            ,"Maximum length for the model")
    `MPRcc( wr  ,1.0              ,""            ,0.0           ,10.0              ,"Width dependence of rds")
    `MPRcc( wint  ,0.0              ,"m"            ,0.0           ,1.0            ,"Width reduction parameter")
    `MPRcc( dwg  ,0.0              ,""            ,0.0           ,1.0             ,"Width reduction parameter")
    `MPRcc( dwb  ,0.0              ,""            ,0.0           ,1.0             ,"Width reduction parameter")
    `MPRcc( wl  ,0.0              ,"m"            ,0.0           ,1.0              ,"Width reduction parameter")
    `MPRcc( wlc  ,1.0              ,"m"            ,0.0           ,10.0             ,"Width reduction parameter for CV")
    `MPRcc( wln  ,1.0              ,"m"            ,0.0           ,10.0             ,"Width reduction parameter")
    `MPRcc( ww  ,0.0              ,"m"            ,0.0           ,1.0              ,"Width reduction parameter")
    `MPRcc( wwc  ,0.0              ,"m"            ,0.0           ,1.0             ,"Width reduction parameter for CV")
    `MPRcc( wwn  ,1.0              ,"m"            ,0.0           ,10.0             ,"Width reduction parameter")
    `MPRcc( wwl  ,0.0              ,"m"            ,0.0           ,1.0             ,"Width reduction parameter")
    `MPRcc( wwlc  ,0.0              ,"m"            ,0.0           ,1.0            ,"Width reduction parameter for CV")
    `MPRcc( wmin  ,0.0              ,"m"            ,0.0           ,1.0            ,"Minimum width for the model")
    `MPRcc( wmax  ,1.0              ,"m"            ,0.0           ,10.0            ,"Maximum width for the model")
    `MPRcc( b0  ,0.0              ,"m"            ,-1.0           ,1.0              ,"Abulk narrow width parameter")
    `MPRcc( b1  ,0.0              ,"m"            ,0.0           ,1.0              ,"Abulk narrow width parameter")
    `MPRcc( cgsl  ,0.0              ,"F"            ,0.0           ,1.0            ,"New C-V model parameter")
    `MPRcc( cgdl  ,0.0              ,"F"            ,0.0           ,1.0            ,"New C-V model parameter")
    `MPRcc( ckappas  ,0.6              ,"V"            ,0.0           ,3.0         ,"S/G overlap C-V parameter")
    `MPRcc( ckappad  ,0.6              ,"V"            ,0.0           ,3.0         ,"D/G overlap C-V parameter")
    `MPRcc( cf  ,0.0              ,"F"            ,0.0           ,1.0              ,"Fringe capacitance parameter")
    `MPRcc( clc  ,1.0e-7              ,"F"            ,0.0           ,1.0             ,"Vdsat parameter for C-V model")
    `MPRcc( cle  ,0.6              ,"F"            ,0.0           ,2.0             ,"Vdsat parameter for C-V model")
    `MPRcc( dwc  ,0.0              ,"m"            ,0.0           ,1.0             ,"Delta W for C-V model")
    `MPRcc( dlc  ,0.0              ,"m"            ,0.0           ,1.0             ,"Delta L for C-V model")
    `MPRcc( xw  ,0.0              ,"m"            ,-1.0           ,1.0              ,"W offset for chan width due to mask/etch")
    `MPRcc( xl  ,0.0              ,"m"            ,-1.0           ,1.0              ,"L offset for chan length due to mask/etch")
    `MPRcc( dlcig  ,0.0              ,"m"            ,0.0           ,1.0           ,"Delta L for Igs model")
    `MPRcc( dlcigd  ,0.0              ,"m"            ,0.0           ,1.0          ,"Delta L for Igd model")
    `MPRcc( dwj  ,0.0              ,""            ,0.0           ,1.0             ,"Delta W for S/D junctions")
    `MPRcc( alpha0  ,0.0              ,"m/V"            ,0.0           ,1.0          ,"substrate current model parameter")
    `MPRcc( alpha1  ,0.0              ,"1/V"            ,0.0           ,1.0          ,"substrate current model parameter")
    `MPRcc( beta0  ,0.0              ,"1/V"            ,0.0           ,100.0           ,"substrate current model parameter")
    `MPRcc( agidl  ,0.0              ,"mS"            ,0.0           ,1.0           ,"Pre-exponential constant for GIDL")
    `MPRcc( bgidl  ,2.3e9              ,"V/m"            ,0.0           ,1.0e10           ,"Exponential constant for GIDL")
    `MPRcc( cgidl  ,0.5              ,"V3"            ,0.0           ,1.0           ,"Parm for body-bias dependence of GIDL")
    `MPRcc( egidl  ,0.8              ,"V"            ,0.0           ,1.0           ,"Fitting parameter for Bandbending")
    `MPRcc( aigc  ,1.36e-2              ,""            ,0.0           ,1.0            ,"Parameter for Igc")
    `MPRcc( bigc  ,1.71e-3              ,""            ,0.0           ,1.0            ,"Parameter for Igc")
    `MPRcc( cigc  ,0.075              ,""            ,0.0           ,1.0            ,"Parameter for Igc")
    `MPRcc( aigsd  ,0.0              ,""            ,0.0           ,1.0           ,"Parameter for Igs d")
    `MPRcc( bigsd  ,0.0              ,""            ,0.0           ,1.0           ,"Parameter for Igs d")
    `MPRcc( cigsd  ,0.0              ,""            ,0.0           ,1.0           ,"Parameter for Igs d")
    `MPRcc( aigbacc  ,9.49e-4              ,""            ,0.0           ,1.0         ,"Parameter for Igb")
    `MPRcc( bigbacc  ,1.71e-3              ,""            ,0.0           ,1.0         ,"Parameter for Igb")
    `MPRcc( cigbacc  ,0.075              ,"1/V"            ,0.0           ,1.0         ,"Parameter for Igb")
    `MPRcc( aigbinv  ,1.11e-2              ,""            ,0.0           ,1.0         ,"Parameter for Igb")
    `MPRcc( bigbinv  ,9.49e-4              ,""            ,0.0           ,1.0         ,"Parameter for Igb")
    `MPRcc( cigbinv  ,0.006              ,"1/V"            ,0.0           ,1.0         ,"Parameter for Igb")
    `MPRcc( nigc  ,1.0              ,""            ,0.0           ,3.0            ,"Parameter for Igc slope")
    `MPRcc( nigbinv  ,3.0              ,""            ,0.0           ,5.0         ,"Parameter for Igbinv slope")
    `MPRcc( nigbacc  ,1.0              ,""            ,0.0           ,3.0         ,"Parameter for Igbacc slope")
    `MPRcc( ntox  ,1.0              ,""            ,0.0           ,3.0            ,"Exponent for Tox ratio")
    `MPRcc( eigbinv  ,1.1              ,"V"            ,0.0           ,3.0         ,"Parm for the Si bandgap for Igbinv")
    `MPRcc( pigcd  ,1.0              ,""            ,0.0           ,3.0           ,"Parameter for Igc partition")
    `MPRcc( poxedge  ,1.0              ,""            ,0.0           ,3.0         ,"Factor for the gate edge Tox")
    `MPRcc( ijthsfwd  ,0.1              ,"A"            ,0.0           ,1.0        ,"Forw S diode forw limiting current")
    `MPRcc( ijthdfwd  ,0.1              ,"A"            ,0.0           ,1.0        ,"Forw D diode forward limiting current")
    `MPRcc( ijthsrev  ,0.1              ,"A"            ,0.0           ,1.0        ,"Rev S diode forward limiting current")
    `MPRcc( ijthdrev  ,0.1              ,"A"            ,0.0           ,1.0        ,"Rev D diode forward limiting current")
    `MPRcc( xjbvs  ,1.0              ,""            ,0.0           ,100.0           ,"Fitting parm for S diode brkdown current")
    `MPRcc( xjbvd  ,1.0              ,""            ,0.0           ,100.0           ,"Fitting parm for D diode brkdwn current")
    `MPRcc( bvs  ,10.0              ,"V"            ,0.0           ,500.0             ,"Source diode breakdown voltage")
    `MPRcc( bvd  ,10.0              ,"V"            ,0.0           ,500.0             ,"Drain diode breakdown voltage")
    `MPRcc( gbmin  ,1.0e-12          ,""            ,0.0           ,1.0           ,"Minimum body conductance")
    `MPRcc( rbdb  ,50.0              ,"Ohm"            ,0.0           ,1000.0            ,"Resistance between bNode and dbNode")
    `MPRcc( rbpb  ,50.0              ,"Ohm"            ,0.0           ,1000.0            ,"Resistance between bNodePrime and bNode")
    `MPRcc( rbsb  ,50.0              ,"Ohm"            ,0.0           ,1000.0            ,"Resistance between bNode and sbNode")
    `MPRcc( rbps  ,50.0              ,"Ohm"            ,0.0           ,1000.0            ,"Resistance between bNodePrime and sbNode")
    `MPRcc( rbpd  ,50.0              ,"Ohm"            ,0.0           ,1000.0            ,"Resistance between bNodePrime and bNode")
    `MPRnb( lcdsc  ,0.0              ,""                                           ,"Length dependence of cdsc")
    `MPRnb( lcdscb  ,0.0              ,""                                          ,"Length dependence of cdscb")
    `MPRnb( lcdscd  ,0.0              ,""                                          ,"Length dependence of cdscd")
    `MPRnb( lcit  ,0.0              ,""                                            ,"Length dependence of cit")
    `MPRnb( lnfactor  ,0.0              ,""                                        ,"Length dependence of nfactor")
    `MPRnb( lxj  ,0.0              ,""                                             ,"Length dependence of xj")
    `MPRnb( lvsat  ,0.0              ,""                                           ,"Length dependence of vsat")
    `MPRnb( lat  ,0.0              ,""                                             ,"Length dependence of at")
    `MPRnb( la0  ,0.0              ,""                                             ,"Length dependence of a0")
    `MPRnb( lags  ,0.0              ,""                                            ,"Length dependence of ags")
    `MPRnb( la1  ,0.0              ,""                                             ,"Length dependence of a1")
    `MPRnb( la2  ,0.0              ,""                                             ,"Length dependence of a2")
    `MPRnb( lketa  ,0.0              ,""                                           ,"Length dependence of keta")
    `MPRnb( lnsub  ,0.0              ,""                                           ,"Length dependence of nsub")
    `MPRnb( lndep  ,0.0              ,""                                           ,"Length dependence of ndep")
    `MPRnb( lnsd  ,0.0              ,""                                            ,"Length dependence of nsd")
    `MPRnb( lphin  ,0.0              ,""                                           ,"Length dependence of phin")
    `MPRnb( lngate  ,0.0              ,""                                          ,"Length dependence of ngate")
    `MPRnb( lgamma1  ,0.0              ,""                                         ,"Length dependence of gamma1")
    `MPRnb( lgamma2  ,0.0              ,""                                         ,"Length dependence of gamma2")
    `MPRnb( lvbx  ,0.0              ,""                                            ,"Length dependence of vbx")
    `MPRnb( lvbm  ,0.0              ,""                                            ,"Length dependence of vbm")
    `MPRnb( lxt  ,0.0              ,""                                             ,"Length dependence of xt")
    `MPRnb( lk1  ,0.0              ,""                                             ,"Length dependence of k1")
    `MPRnb( lkt1  ,0.0              ,""                                            ,"Length dependence of kt1")
    `MPRnb( lkt1l  ,0.0              ,""                                           ,"Length dependence of kt1l")
    `MPRnb( lkt2  ,0.0              ,""                                            ,"Length dependence of kt2")
    `MPRnb( lk2  ,0.0              ,""                                             ,"Length dependence of k2")
    `MPRnb( lk3  ,0.0              ,""                                             ,"Length dependence of k3")
    `MPRnb( lk3b  ,0.0              ,""                                            ,"Length dependence of k3b")
    `MPRnb( lw0  ,0.0              ,""                                             ,"Length dependence of w0")
    `MPRnb( ldvtp0  ,0.0              ,""                                          ,"Length dependence of dvtp0")
    `MPRnb( ldvtp1  ,0.0              ,""                                          ,"Length dependence of dvtp1")
    `MPRnb( llpe0  ,0.0              ,""                                           ,"Length dependence of lpe0")
    `MPRnb( llpeb  ,0.0              ,""                                           ,"Length dependence of lpeb")
    `MPRnb( ldvt0  ,0.0              ,""                                           ,"Length dependence of dvt0")
    `MPRnb( ldvt1  ,0.0              ,""                                           ,"Length dependence of dvt1")
    `MPRnb( ldvt2  ,0.0              ,""                                           ,"Length dependence of dvt2")
    `MPRnb( ldvt0w  ,0.0              ,""                                          ,"Length dependence of dvt0w")
    `MPRnb( ldvt1w  ,0.0              ,""                                          ,"Length dependence of dvt1w")
    `MPRnb( ldvt2w  ,0.0              ,""                                          ,"Length dependence of dvt2w")
    `MPRnb( ldrout  ,0.0              ,""                                          ,"Length dependence of drout")
    `MPRnb( ldsub  ,0.0              ,""                                           ,"Length dependence of dsub")
    `MPRnb( lvth0  ,0.0              ,""                                           ,"Length dependence of vto")
    `MPRnb( lua  ,0.0              ,""                                             ,"Length dependence of ua")
    `MPRnb( lua1  ,0.0              ,""                                            ,"Length dependence of ua1")
    `MPRnb( lub  ,0.0              ,""                                             ,"Length dependence of ub")
    `MPRnb( lub1  ,0.0              ,""                                            ,"Length dependence of ub1")
    `MPRnb( luc  ,0.0              ,""                                             ,"Length dependence of uc")
    `MPRnb( luc1  ,0.0              ,""                                            ,"Length dependence of uc1")
    `MPRnb( lu0  ,0.0              ,""                                             ,"Length dependence of u0")
    `MPRnb( lute  ,0.0              ,""                                            ,"Length dependence of ute")
    `MPRnb( lvoff  ,0.0              ,""                                           ,"Length dependence of voff")
    `MPRnb( lminv  ,0.0              ,""                                           ,"Length dependence of minv")
    `MPRnb( ldelta  ,0.0              ,""                                          ,"Length dependence of delta")
    `MPRnb( lrdsw  ,0.0              ,""                                           ,"Length dependence of rdsw")
    `MPRnb( lrsw  ,0.0              ,""                                            ,"Length dependence of rsw")
    `MPRnb( lrdw  ,0.0              ,""                                            ,"Length dependence of rdw")
    `MPRnb( lprwg  ,0.0              ,""                                           ,"Length dependence of prwg")
    `MPRnb( lprwb  ,0.0              ,""                                           ,"Length dependence of prwb")
    `MPRnb( lprt  ,0.0              ,""                                            ,"Length dependence of prt")
    `MPRnb( leta0  ,0.0              ,""                                           ,"Length dependence of eta0")
    `MPRnb( letab  ,0.0              ,""                                           ,"Length dependence of etab")
    `MPRnb( lpclm  ,0.0              ,""                                           ,"Length dependence of pclm")
    `MPRnb( lpdiblc1  ,0.0              ,""                                        ,"Length dependence of pdiblc1")
    `MPRnb( lpdiblc2  ,0.0              ,""                                        ,"Length dependence of pdiblc2")
    `MPRnb( lpdiblcb  ,0.0              ,""                                        ,"Length dependence of pdiblcb")
    `MPRnb( lfprout  ,0.0              ,""                                         ,"Length dependence of pdiblcb")
    `MPRnb( lpdits  ,0.0              ,""                                          ,"Length dependence of pdits")
    `MPRnb( lpditsd  ,0.0              ,""                                         ,"Length dependence of pditsd")
    `MPRnb( lpscbe1  ,0.0              ,""                                         ,"Length dependence of pscbe1")
    `MPRnb( lpscbe2  ,0.0              ,""                                         ,"Length dependence of pscbe2")
    `MPRnb( lpvag  ,0.0              ,""                                           ,"Length dependence of pvag")
    `MPRnb( lwr  ,0.0              ,""                                             ,"Length dependence of wr")
    `MPRnb( ldwg  ,0.0              ,""                                            ,"Length dependence of dwg")
    `MPRnb( ldwb  ,0.0              ,""                                            ,"Length dependence of dwb")
    `MPRnb( lb0  ,0.0              ,""                                             ,"Length dependence of b0")
    `MPRnb( lb1  ,0.0              ,""                                             ,"Length dependence of b1")
    `MPRnb( lcgsl  ,0.0              ,""                                           ,"Length dependence of cgsl")
    `MPRnb( lcgdl  ,0.0              ,""                                           ,"Length dependence of cgdl")
    `MPRnb( lckappas  ,0.0              ,""                                        ,"Length dependence of ckappas")
    `MPRnb( lckappad  ,0.0              ,""                                        ,"Length dependence of ckappad")
    `MPRnb( lcf  ,0.0              ,""                                             ,"Length dependence of cf")
    `MPRnb( lclc  ,0.0              ,""                                            ,"Length dependence of clc")
    `MPRnb( lcle  ,0.0              ,""                                            ,"Length dependence of cle")
    `MPRnb( lalpha0  ,0.0              ,""                                         ,"Length dependence of alpha0")
    `MPRnb( lalpha1  ,0.0              ,""                                         ,"Length dependence of alpha1")
    `MPRnb( lbeta0  ,0.0              ,""                                          ,"Length dependence of beta0")
    `MPRnb( lagidl  ,0.0              ,""                                          ,"Length dependence of agidl")
    `MPRnb( lbgidl  ,0.0              ,""                                          ,"Length dependence of bgidl")
    `MPRnb( lcgidl  ,0.0              ,""                                          ,"Length dependence of cgidl")
    `MPRnb( legidl  ,0.0              ,""                                          ,"Length dependence of egidl")
    `MPRnb( laigc  ,0.0              ,""                                           ,"Length dependence of aigc")
    `MPRnb( lbigc  ,0.0              ,""                                           ,"Length dependence of bigc")
    `MPRnb( lcigc  ,0.0              ,""                                           ,"Length dependence of cigc")
    `MPRnb( laigsd  ,0.0              ,""                                          ,"Length dependence of aigsd")
    `MPRnb( lbigsd  ,0.0              ,""                                          ,"Length dependence of bigsd")
    `MPRnb( lcigsd  ,0.0              ,""                                          ,"Length dependence of cigsd")
    `MPRnb( laigbacc  ,0.0              ,""                                        ,"Length dependence of aigbacc")
    `MPRnb( lbigbacc  ,0.0              ,""                                        ,"Length dependence of bigbacc")
    `MPRnb( lcigbacc  ,0.0              ,""                                        ,"Length dependence of cigbacc")
    `MPRnb( laigbinv  ,0.0              ,""                                        ,"Length dependence of aigbinv")
    `MPRnb( lbigbinv  ,0.0              ,""                                        ,"Length dependence of bigbinv")
    `MPRnb( lcigbinv  ,0.0              ,""                                        ,"Length dependence of cigbinv")
    `MPRnb( lnigc  ,0.0              ,""                                           ,"Length dependence of nigc")
    `MPRnb( lnigbinv  ,0.0              ,""                                        ,"Length dependence of nigbinv")
    `MPRnb( lnigbacc  ,0.0              ,""                                        ,"Length dependence of nigbacc")
    `MPRnb( lntox  ,0.0              ,""                                           ,"Length dependence of ntox")
    `MPRnb( leigbinv  ,0.0              ,""                                        ,"Length dependence for eigbinv")
    `MPRnb( lpigcd  ,0.0              ,""                                          ,"Length dependence for pigcd")
    `MPRnb( lpoxedge  ,0.0              ,""                                        ,"Length dependence for poxedge")
    `MPRnb( lvfbcv  ,0.0              ,""                                          ,"Length dependence of vfbcv")
    `MPRnb( lvfb  ,0.0              ,""                                            ,"Length dependence of vfb")
    `MPRnb( lacde  ,0.0              ,""                                           ,"Length dependence of acde")
    `MPRnb( lmoin  ,0.0              ,""                                           ,"Length dependence of moin")
    `MPRnb( lnoff  ,0.0              ,""                                           ,"Length dependence of noff")
    `MPRnb( lvoffcv  ,0.0              ,""                                         ,"Length dependence of voffcv")
    `MPRnb( lxrcrg1  ,0.0              ,""                                         ,"Length dependence of xrcrg1")
    `MPRnb( lxrcrg2  ,0.0              ,""                                         ,"Length dependence of xrcrg2")
    `MPRnb( leu  ,0.0              ,""                                             ,"Length dependence of eu")
    `MPRnb( wcdsc  ,0.0              ,""                                           ,"Width dependence of cdsc")
    `MPRnb( wcdscb  ,0.0              ,""                                          ,"Width dependence of cdscb")
    `MPRnb( wcdscd  ,0.0              ,""                                          ,"Width dependence of cdscd")
    `MPRnb( wcit  ,0.0              ,""                                            ,"Width dependence of cit")
    `MPRnb( wnfactor  ,0.0              ,""                                        ,"Width dependence of nfactor")
    `MPRnb( wxj  ,0.0              ,""                                             ,"Width dependence of xj")
    `MPRnb( wvsat  ,0.0              ,""                                           ,"Width dependence of vsat")
    `MPRnb( wat  ,0.0              ,""                                             ,"Width dependence of at")
    `MPRnb( wa0  ,0.0              ,""                                             ,"Width dependence of a0")
    `MPRnb( wags  ,0.0              ,""                                            ,"Width dependence of ags")
    `MPRnb( wa1  ,0.0              ,""                                             ,"Width dependence of a1")
    `MPRnb( wa2  ,0.0              ,""                                             ,"Width dependence of a2")
    `MPRnb( wketa  ,0.0              ,""                                           ,"Width dependence of keta")
    `MPRnb( wnsub  ,0.0              ,""                                           ,"Width dependence of nsub")
    `MPRnb( wndep  ,0.0              ,""                                           ,"Width dependence of ndep")
    `MPRnb( wnsd  ,0.0              ,""                                            ,"Width dependence of nsd")
    `MPRnb( wphin  ,0.0              ,""                                           ,"Width dependence of phin")
    `MPRnb( wngate  ,0.0              ,""                                          ,"Width dependence of ngate")
    `MPRnb( wgamma1  ,0.0              ,""                                         ,"Width dependence of gamma1")
    `MPRnb( wgamma2  ,0.0              ,""                                         ,"Width dependence of gamma2")
    `MPRnb( wvbx  ,0.0              ,""                                            ,"Width dependence of vbx")
    `MPRnb( wvbm  ,0.0              ,""                                            ,"Width dependence of vbm")
    `MPRnb( wxt  ,0.0              ,""                                             ,"Width dependence of xt")
    `MPRnb( wk1  ,0.0              ,""                                             ,"Width dependence of k1")
    `MPRnb( wkt1  ,0.0              ,""                                            ,"Width dependence of kt1")
    `MPRnb( wkt1l  ,0.0              ,""                                           ,"Width dependence of kt1l")
    `MPRnb( wkt2  ,0.0              ,""                                            ,"Width dependence of kt2")
    `MPRnb( wk2  ,0.0              ,""                                             ,"Width dependence of k2")
    `MPRnb( wk3  ,0.0              ,""                                             ,"Width dependence of k3")
    `MPRnb( wk3b  ,0.0              ,""                                            ,"Width dependence of k3b")
    `MPRnb( ww0  ,0.0              ,""                                             ,"Width dependence of w0")
    `MPRnb( wdvtp0  ,0.0              ,""                                          ,"Width dependence of dvtp0")
    `MPRnb( wdvtp1  ,0.0              ,""                                          ,"Width dependence of dvtp1")
    `MPRnb( wlpe0  ,0.0              ,""                                           ,"Width dependence of lpe0")
    `MPRnb( wlpeb  ,0.0              ,""                                           ,"Width dependence of lpeb")
    `MPRnb( wdvt0  ,0.0              ,""                                           ,"Width dependence of dvt0")
    `MPRnb( wdvt1  ,0.0              ,""                                           ,"Width dependence of dvt1")
    `MPRnb( wdvt2  ,0.0              ,""                                           ,"Width dependence of dvt2")
    `MPRnb( wdvt0w  ,0.0              ,""                                          ,"Width dependence of dvt0w")
    `MPRnb( wdvt1w  ,0.0              ,""                                          ,"Width dependence of dvt1w")
    `MPRnb( wdvt2w  ,0.0              ,""                                          ,"Width dependence of dvt2w")
    `MPRnb( wdrout  ,0.0              ,""                                          ,"Width dependence of drout")
    `MPRnb( wdsub  ,0.0              ,""                                           ,"Width dependence of dsub")
    `MPRnb( wvth0  ,0.0              ,""                                           ,"Width dependence of vto")
    `MPRnb( wua  ,0.0              ,""                                             ,"Width dependence of ua")
    `MPRnb( wua1  ,0.0              ,""                                            ,"Width dependence of ua1")
    `MPRnb( wub  ,0.0              ,""                                             ,"Width dependence of ub")
    `MPRnb( wub1  ,0.0              ,""                                            ,"Width dependence of ub1")
    `MPRnb( wuc  ,0.0              ,""                                             ,"Width dependence of uc")
    `MPRnb( wuc1  ,0.0              ,""                                            ,"Width dependence of uc1")
    `MPRnb( wu0  ,0.0              ,""                                             ,"Width dependence of u0")
    `MPRnb( wute  ,0.0              ,""                                            ,"Width dependence of ute")
    `MPRnb( wvoff  ,0.0              ,""                                           ,"Width dependence of voff")
    `MPRnb( wminv  ,0.0              ,""                                           ,"Width dependence of minv")
    `MPRnb( wdelta  ,0.0              ,""                                          ,"Width dependence of delta")
    `MPRnb( wrdsw  ,0.0              ,""                                           ,"Width dependence of rdsw")
    `MPRnb( wrsw  ,0.0              ,""                                            ,"Width dependence of rsw")
    `MPRnb( wrdw  ,0.0              ,""                                            ,"Width dependence of rdw")
    `MPRnb( wprwg  ,0.0              ,""                                           ,"Width dependence of prwg")
    `MPRnb( wprwb  ,0.0              ,""                                           ,"Width dependence of prwb")
    `MPRnb( wprt  ,0.0              ,""                                            ,"Width dependence of prt")
    `MPRnb( weta0  ,0.0              ,""                                           ,"Width dependence of eta0")
    `MPRnb( wetab  ,0.0              ,""                                           ,"Width dependence of etab")
    `MPRnb( wpclm  ,0.0              ,""                                           ,"Width dependence of pclm")
    `MPRnb( wpdiblc1  ,0.0              ,""                                        ,"Width dependence of pdiblc1")
    `MPRnb( wpdiblc2  ,0.0              ,""                                        ,"Width dependence of pdiblc2")
    `MPRnb( wpdiblcb  ,0.0              ,""                                        ,"Width dependence of pdiblcb")
    `MPRnb( wfprout  ,0.0              ,""                                         ,"Width dependence of pdiblcb")
    `MPRnb( wpdits  ,0.0              ,""                                          ,"Width dependence of pdits")
    `MPRnb( wpditsd  ,0.0              ,""                                         ,"Width dependence of pditsd")
    `MPRnb( wpscbe1  ,0.0              ,""                                         ,"Width dependence of pscbe1")
    `MPRnb( wpscbe2  ,0.0              ,""                                         ,"Width dependence of pscbe2")
    `MPRnb( wpvag  ,0.0              ,""                                           ,"Width dependence of pvag")
    `MPRnb( wwr  ,0.0              ,""                                             ,"Width dependence of wr")
    `MPRnb( wdwg  ,0.0              ,""                                            ,"Width dependence of dwg")
    `MPRnb( wdwb  ,0.0              ,""                                            ,"Width dependence of dwb")
    `MPRnb( wb0  ,0.0              ,""                                             ,"Width dependence of b0")
    `MPRnb( wb1  ,0.0              ,""                                             ,"Width dependence of b1")
    `MPRnb( wcgsl  ,0.0              ,""                                           ,"Width dependence of cgsl")
    `MPRnb( wcgdl  ,0.0              ,""                                           ,"Width dependence of cgdl")
    `MPRnb( wckappas  ,0.0              ,""                                        ,"Width dependence of ckappas")
    `MPRnb( wckappad  ,0.0              ,""                                        ,"Width dependence of ckappad")
    `MPRnb( wcf  ,0.0              ,""                                             ,"Width dependence of cf")
    `MPRnb( wclc  ,0.0              ,""                                            ,"Width dependence of clc")
    `MPRnb( wcle  ,0.0              ,""                                            ,"Width dependence of cle")
    `MPRnb( walpha0  ,0.0              ,""                                         ,"Width dependence of alpha0")
    `MPRnb( walpha1  ,0.0              ,""                                         ,"Width dependence of alpha1")
    `MPRnb( wbeta0  ,0.0              ,""                                          ,"Width dependence of beta0")
    `MPRnb( wagidl  ,0.0              ,""                                          ,"Width dependence of agidl")
    `MPRnb( wbgidl  ,0.0              ,""                                          ,"Width dependence of bgidl")
    `MPRnb( wcgidl  ,0.0              ,""                                          ,"Width dependence of cgidl")
    `MPRnb( wegidl  ,0.0              ,""                                          ,"Width dependence of egidl")
    `MPRnb( waigc  ,0.0              ,""                                           ,"Width dependence of aigc")
    `MPRnb( wbigc  ,0.0              ,""                                           ,"Width dependence of bigc")
    `MPRnb( wcigc  ,0.0              ,""                                           ,"Width dependence of cigc")
    `MPRnb( waigsd  ,0.0              ,""                                          ,"Width dependence of aigsd")
    `MPRnb( wbigsd  ,0.0              ,""                                          ,"Width dependence of bigsd")
    `MPRnb( wcigsd  ,0.0              ,""                                          ,"Width dependence of cigsd")
    `MPRnb( waigbacc  ,0.0              ,""                                        ,"Width dependence of aigbacc")
    `MPRnb( wbigbacc  ,0.0              ,""                                        ,"Width dependence of bigbacc")
    `MPRnb( wcigbacc  ,0.0              ,""                                        ,"Width dependence of cigbacc")
    `MPRnb( waigbinv  ,0.0              ,""                                        ,"Width dependence of aigbinv")
    `MPRnb( wbigbinv  ,0.0              ,""                                        ,"Width dependence of bigbinv")
    `MPRnb( wcigbinv  ,0.0              ,""                                        ,"Width dependence of cigbinv")
    `MPRnb( wnigc  ,0.0              ,""                                           ,"Width dependence of nigc")
    `MPRnb( wnigbinv  ,0.0              ,""                                        ,"Width dependence of nigbinv")
    `MPRnb( wnigbacc  ,0.0              ,""                                        ,"Width dependence of nigbacc")
    `MPRnb( wntox  ,0.0              ,""                                           ,"Width dependence of ntox")
    `MPRnb( weigbinv  ,0.0              ,""                                        ,"Width dependence for eigbinv")
    `MPRnb( wpigcd  ,0.0              ,""                                          ,"Width dependence for pigcd")
    `MPRnb( wpoxedge  ,0.0              ,""                                        ,"Width dependence for poxedge")
    `MPRnb( wvfbcv  ,0.0              ,""                                          ,"Width dependence of vfbcv")
    `MPRnb( wvfb  ,0.0              ,""                                            ,"Width dependence of vfb")
    `MPRnb( wacde  ,0.0              ,""                                           ,"Width dependence of acde")
    `MPRnb( wmoin  ,0.0              ,""                                           ,"Width dependence of moin")
    `MPRnb( wnoff  ,0.0              ,""                                           ,"Width dependence of noff")
    `MPRnb( wvoffcv  ,0.0              ,""                                         ,"Width dependence of voffcv")
    `MPRnb( wxrcrg1  ,0.0              ,""                                         ,"Width dependence of xrcrg1")
    `MPRnb( wxrcrg2  ,0.0              ,""                                         ,"Width dependence of xrcrg2")
    `MPRnb( weu  ,0.0              ,""                                             ,"Width dependence of eu")
    `MPRnb( pcdsc  ,0.0              ,""                                           ,"Cross-term dependence of cdsc")
    `MPRnb( pcdscb  ,0.0              ,""                                          ,"Cross-term dependence of cdscb")
    `MPRnb( pcdscd  ,0.0              ,""                                          ,"Cross-term dependence of cdscd")
    `MPRnb( pcit  ,0.0              ,""                                            ,"Cross-term dependence of cit")
    `MPRnb( pnfactor  ,0.0              ,""                                        ,"Cross-term dependence of nfactor")
    `MPRnb( pxj  ,0.0              ,""                                             ,"Cross-term dependence of xj")
    `MPRnb( pvsat  ,0.0              ,""                                           ,"Cross-term dependence of vsat")
    `MPRnb( pat  ,0.0              ,""                                             ,"Cross-term dependence of at")
    `MPRnb( pa0  ,0.0              ,""                                             ,"Cross-term dependence of a0")
    `MPRnb( pags  ,0.0              ,""                                            ,"Cross-term dependence of ags")
    `MPRnb( pa1  ,0.0              ,""                                             ,"Cross-term dependence of a1")
    `MPRnb( pa2  ,0.0              ,""                                             ,"Cross-term dependence of a2")
    `MPRnb( pketa  ,0.0              ,""                                           ,"Cross-term dependence of keta")
    `MPRnb( pnsub  ,0.0              ,""                                           ,"Cross-term dependence of nsub")
    `MPRnb( pndep  ,0.0              ,""                                           ,"Cross-term dependence of ndep")
    `MPRnb( pnsd  ,0.0              ,""                                            ,"Cross-term dependence of nsd")
    `MPRnb( pphin  ,0.0              ,""                                           ,"Cross-term dependence of phin")
    `MPRnb( pngate  ,0.0              ,""                                          ,"Cross-term dependence of ngate")
    `MPRnb( pgamma1  ,0.0              ,""                                         ,"Cross-term dependence of gamma1")
    `MPRnb( pgamma2  ,0.0              ,""                                         ,"Cross-term dependence of gamma2")
    `MPRnb( pvbx  ,0.0              ,""                                            ,"Cross-term dependence of vbx")
    `MPRnb( pvbm  ,0.0              ,""                                            ,"Cross-term dependence of vbm")
    `MPRnb( pxt  ,0.0              ,""                                             ,"Cross-term dependence of xt")
    `MPRnb( pk1  ,0.0              ,""                                             ,"Cross-term dependence of k1")
    `MPRnb( pkt1  ,0.0              ,""                                            ,"Cross-term dependence of kt1")
    `MPRnb( pkt1l  ,0.0              ,""                                           ,"Cross-term dependence of kt1l")
    `MPRnb( pkt2  ,0.0              ,""                                            ,"Cross-term dependence of kt2")
    `MPRnb( pk2  ,0.0              ,""                                             ,"Cross-term dependence of k2")
    `MPRnb( pk3  ,0.0              ,""                                             ,"Cross-term dependence of k3")
    `MPRnb( pk3b  ,0.0              ,""                                            ,"Cross-term dependence of k3b")
    `MPRnb( pw0  ,0.0              ,""                                             ,"Cross-term dependence of w0")
    `MPRnb( pdvtp0  ,0.0              ,""                                          ,"Cross-term dependence of dvtp0")
    `MPRnb( pdvtp1  ,0.0              ,""                                          ,"Cross-term dependence of dvtp1")
    `MPRnb( plpe0  ,0.0              ,""                                           ,"Cross-term dependence of lpe0")
    `MPRnb( plpeb  ,0.0              ,""                                           ,"Cross-term dependence of lpeb")
    `MPRnb( pdvt0  ,0.0              ,""                                           ,"Cross-term dependence of dvt0")
    `MPRnb( pdvt1  ,0.0              ,""                                           ,"Cross-term dependence of dvt1")
    `MPRnb( pdvt2  ,0.0              ,""                                           ,"Cross-term dependence of dvt2")
    `MPRnb( pdvt0w  ,0.0              ,""                                          ,"Cross-term dependence of dvt0w")
    `MPRnb( pdvt1w  ,0.0              ,""                                          ,"Cross-term dependence of dvt1w")
    `MPRnb( pdvt2w  ,0.0              ,""                                          ,"Cross-term dependence of dvt2w")
    `MPRnb( pdrout  ,0.0              ,""                                          ,"Cross-term dependence of drout")
    `MPRnb( pdsub  ,0.0              ,""                                           ,"Cross-term dependence of dsub")
    `MPRnb( pvth0  ,0.0              ,""                                           ,"Cross-term dependence of vto")
    `MPRnb( pua  ,0.0              ,""                                             ,"Cross-term dependence of ua")
    `MPRnb( pua1  ,0.0              ,""                                            ,"Cross-term dependence of ua1")
    `MPRnb( pub  ,0.0              ,""                                             ,"Cross-term dependence of ub")
    `MPRnb( pub1  ,0.0              ,""                                            ,"Cross-term dependence of ub1")
    `MPRnb( puc  ,0.0              ,""                                             ,"Cross-term dependence of uc")
    `MPRnb( puc1  ,0.0              ,""                                            ,"Cross-term dependence of uc1")
    `MPRnb( pu0  ,0.0              ,""                                             ,"Cross-term dependence of u0")
    `MPRnb( pute  ,0.0              ,""                                            ,"Cross-term dependence of ute")
    `MPRnb( pvoff  ,0.0              ,""                                           ,"Cross-term dependence of voff")
    `MPRnb( pminv  ,0.0              ,""                                           ,"Cross-term dependence of minv")
    `MPRnb( pdelta  ,0.0              ,""                                          ,"Cross-term dependence of delta")
    `MPRnb( prdsw  ,0.0              ,""                                           ,"Cross-term dependence of rdsw")
    `MPRnb( prsw  ,0.0              ,""                                            ,"Cross-term dependence of rsw")
    `MPRnb( prdw  ,0.0              ,""                                            ,"Cross-term dependence of rdw")
    `MPRnb( pprwg  ,0.0              ,""                                           ,"Cross-term dependence of prwg")
    `MPRnb( pprwb  ,0.0              ,""                                           ,"Cross-term dependence of prwb")
    `MPRnb( pprt  ,0.0              ,""                                            ,"Cross-term dependence of prt")
    `MPRnb( peta0  ,0.0              ,""                                           ,"Cross-term dependence of eta0")
    `MPRnb( petab  ,0.0              ,""                                           ,"Cross-term dependence of etab")
    `MPRnb( ppclm  ,0.0              ,""                                           ,"Cross-term dependence of pclm")
    `MPRnb( ppdiblc1  ,0.0              ,""                                        ,"Cross-term dependence of pdiblc1")
    `MPRnb( ppdiblc2  ,0.0              ,""                                        ,"Cross-term dependence of pdiblc2")
    `MPRnb( ppdiblcb  ,0.0              ,""                                        ,"Cross-term dependence of pdiblcb")
    `MPRnb( pfprout  ,0.0              ,""                                         ,"Cross-term dependence of pdiblcb")
    `MPRnb( ppdits  ,0.0              ,""                                          ,"Cross-term dependence of pdits")
    `MPRnb( ppditsd  ,0.0              ,""                                         ,"Cross-term dependence of pditsd")
    `MPRnb( ppscbe1  ,0.0              ,""                                         ,"Cross-term dependence of pscbe1")
    `MPRnb( ppscbe2  ,0.0              ,""                                         ,"Cross-term dependence of pscbe2")
    `MPRnb( ppvag  ,0.0              ,""                                           ,"Cross-term dependence of pvag")
    `MPRnb( pwr  ,0.0              ,""                                             ,"Cross-term dependence of wr")
    `MPRnb( pdwg  ,0.0              ,""                                            ,"Cross-term dependence of dwg")
    `MPRnb( pdwb  ,0.0              ,""                                            ,"Cross-term dependence of dwb")
    `MPRnb( pb0  ,0.0              ,""                                             ,"Cross-term dependence of b0")
    `MPRnb( pb1  ,0.0              ,""                                             ,"Cross-term dependence of b1")
    `MPRnb( pcgsl  ,0.0              ,""                                           ,"Cross-term dependence of cgsl")
    `MPRnb( pcgdl  ,0.0              ,""                                           ,"Cross-term dependence of cgdl")
    `MPRnb( pckappas  ,0.0              ,""                                        ,"Cross-term dependence of ckappas")
    `MPRnb( pckappad  ,0.0              ,""                                        ,"Cross-term dependence of ckappad")
    `MPRnb( pcf  ,0.0              ,""                                             ,"Cross-term dependence of cf")
    `MPRnb( pclc  ,0.0              ,""                                            ,"Cross-term dependence of clc")
    `MPRnb( pcle  ,0.0              ,""                                            ,"Cross-term dependence of cle")
    `MPRnb( palpha0  ,0.0              ,""                                         ,"Cross-term dependence of alpha0")
    `MPRnb( palpha1  ,0.0              ,""                                         ,"Cross-term dependence of alpha1")
    `MPRnb( pbeta0  ,0.0              ,""                                          ,"Cross-term dependence of beta0")
    `MPRnb( pagidl  ,0.0              ,""                                          ,"Cross-term dependence of agidl")
    `MPRnb( pbgidl  ,0.0              ,""                                          ,"Cross-term dependence of bgidl")
    `MPRnb( pcgidl  ,0.0              ,""                                          ,"Cross-term dependence of cgidl")
    `MPRnb( pegidl  ,0.0              ,""                                          ,"Cross-term dependence of egidl")
    `MPRnb( paigc  ,0.0              ,""                                           ,"Cross-term dependence of aigc")
    `MPRnb( pbigc  ,0.0              ,""                                           ,"Cross-term dependence of bigc")
    `MPRnb( pcigc  ,0.0              ,""                                           ,"Cross-term dependence of cigc")
    `MPRnb( paigsd  ,0.0              ,""                                          ,"Cross-term dependence of aigsd")
    `MPRnb( pbigsd  ,0.0              ,""                                          ,"Cross-term dependence of bigsd")
    `MPRnb( pcigsd  ,0.0              ,""                                          ,"Cross-term dependence of cigsd")
    `MPRnb( paigbacc  ,0.0              ,""                                        ,"Cross-term dependence of aigbacc")
    `MPRnb( pbigbacc  ,0.0              ,""                                        ,"Cross-term dependence of bigbacc")
    `MPRnb( pcigbacc  ,0.0              ,""                                        ,"Cross-term dependence of cigbacc")
    `MPRnb( paigbinv  ,0.0              ,""                                        ,"Cross-term dependence of aigbinv")
    `MPRnb( pbigbinv  ,0.0              ,""                                        ,"Cross-term dependence of bigbinv")
    `MPRnb( pcigbinv  ,0.0              ,""                                        ,"Cross-term dependence of cigbinv")
    `MPRnb( pnigc  ,0.0              ,""                                           ,"Cross-term dependence of nigc")
    `MPRnb( pnigbinv  ,0.0              ,""                                        ,"Cross-term dependence of nigbinv")
    `MPRnb( pnigbacc  ,0.0              ,""                                        ,"Cross-term dependence of nigbacc")
    `MPRnb( pntox  ,0.0              ,""                                           ,"Cross-term dependence of ntox")
    `MPRnb( peigbinv  ,0.0              ,""                                        ,"Cross-term dependence for eigbinv")
    `MPRnb( ppigcd  ,0.0              ,""                                          ,"Cross-term dependence for pigcd")
    `MPRnb( ppoxedge  ,0.0              ,""                                        ,"Cross-term dependence for poxedge")
    `MPRnb( pvfbcv  ,0.0              ,""                                          ,"Cross-term dependence of vfbcv")
    `MPRnb( pvfb  ,0.0              ,""                                            ,"Cross-term dependence of vfb")
    `MPRnb( pacde  ,0.0              ,""                                           ,"Cross-term dependence of acde")
    `MPRnb( pmoin  ,0.0              ,""                                           ,"Cross-term dependence of moin")
    `MPRnb( pnoff  ,0.0              ,""                                           ,"Cross-term dependence of noff")
    `MPRnb( pvoffcv  ,0.0              ,""                                         ,"Cross-term dependence of voffcv")
    `MPRnb( pxrcrg1  ,0.0              ,""                                         ,"Cross-term dependence of xrcrg1")
    `MPRnb( pxrcrg2  ,0.0              ,""                                         ,"Cross-term dependence of xrcrg2")
    `MPRnb( peu  ,0.0              ,""                                             ,"Cross-term dependence of eu")
    `MPRcc( noia  ,6.25e41              ,""            ,0.0           ,1.0e60            ,"Flicker noise parameter")
    `MPRcc( noib  ,3.125e26              ,""            ,0.0           ,1.0e40            ,"Flicker noise parameter")
    `MPRcc( noic  ,8.75              ,""            ,0.0           ,100.0            ,"Flicker noise parameter")
    `MPRcc( tnoia  ,1.5              ,""            ,0.0           ,10.0           ,"Thermal noise parameter")
    `MPRcc( tnoib  ,3.5              ,""            ,0.0           ,10.0           ,"Thermal noise parameter")
    `MPRcc( tnoic  ,0.0              ,""            ,0.0           ,1.0           ,"Thermal noise parameter")
    `MPRcc( ntnoi  ,1.0              ,""            ,0.0           ,10.0           ,"Thermal noise parameter")
    `MPRcc( em  ,4.1e7              ,""            ,0.0           ,1.0e12              ,"Flicker noise parameter")
    `MPRcc( ef  ,1.0              ,""            ,0.0           ,10.0              ,"Flicker noise frequency exponent")
    `MPRcc( af  ,1.0              ,""            ,0.0           ,10.0              ,"Flicker noise exponent")
    `MPRcc( kf  ,0.0              ,""            ,0.0           ,1.0              ,"Flicker noise coeff")

    //  BSIM4.3

    `IPRnb( sa           ,0.0            ,"m"                                     ,"Distance between OD edge to Poly" )
    `IPRnb( sb           ,0.0            ,"m"                                     ,"Distance between OD edge to Poly (other side)" )
    `IPRnb( sd           ,0.0            ,"m"                                     ,"Distance between neighboring fingers" )
    `MPRoc( saref  ,1e-6              ,"m"            ,0.0           ,1.0           ,"Reference distance between OD and edge to poly of one side")
    `MPRoc( sbref  ,1e-6              ,"m"            ,0.0           ,1.0           ,"Reference distance between OD and edge to poly of the other side")
    `MPRcc( wlod  ,0.0              ,"m"            ,0.0           ,1.0            ,"Width parameter for stress effect")
    `MPRcc( ku0  ,0.0              ,"m"            ,-1.0           ,1.0             ,"Mobility degradation/enhancement coefficient for stress effect")
    `MPRcc( kvsat  ,0.0              ,"m"            ,0.0           ,1.0           ,"Saturation velocity degradation/enhancement parameter for stress effect")
    `MPRcc( tku0  ,0.0              ,""            ,0.0           ,1.0            ,"Temperature coefficient of KU0")
    `MPRnb( lku0  ,0.0              ,""                                           ,"Length dependence of ku0")
    `MPRnb( wku0  ,0.0              ,""                                           ,"Width dependence of ku0")
    `MPRnb( pku0  ,0.0              ,""                                           ,"Cross-term dependence of ku0")
    `MPRcc( llodku0  ,0.0              ,""            ,0.0           ,10.0         ,"Length parameter for u0 stress effect")
    `MPRcc( wlodku0  ,0.0              ,""            ,0.0           ,10.0         ,"Width parameter for u0 stress effect")
    `MPRcc( kvth0  ,0.0              ,"Vm"            ,-1.0           ,1.0           ,"Threshold shift parameter for stress effect")
    `MPRnb( lkvth0  ,0.0              ,""                                         ,"Length dependence of kvth0")
    `MPRnb( wkvth0  ,0.0              ,""                                         ,"Width dependence of kvth0")
    `MPRnb( pkvth0  ,0.0              ,""                                        ,"Cross-term dependence of kvth0")
    `MPRcc( llodvth  ,0.0              ,""            ,0.0           ,1.0         ,"Length parameter for Vth stress effect")
    `MPRcc( wlodvth  ,0.0              ,""            ,0.0           ,1.0         ,"Width parameter for Vth stress effect")
    `MPRcc( stk2  ,0.0              ,"m"            ,0.0           ,1.0            ,"K2 shift factor related to Vth0 change")
    `MPRoc( lodk2  ,1.0              ,""            ,0.0           ,10.0           ,"K2 shift modification factor for stress effect")
    `MPRcc( steta0  ,0.0              ,"m"            ,0.0           ,1.0          ,"eta0 shift factor related to Vth0 change")
    `MPRoc( lodeta0  ,1.0              ,""            ,0.0           ,10.0         ,"eta0 shift modification factor for stress effect")
    `MPRcc( xn  ,3.0              ,""            ,0.0           ,10.0              ,"Velocity back scattering")
    `MPRnb( lxn  ,0.0              ,""                                            ,"Length dependence of velocity back scattering")
    `MPRnb( wxn  ,0.0              ,""                                            ,"Width dependence of velocity back scattering")
    `MPRnb( pxn  ,0.0              ,""                                            ,"Cross-term dependence of velocity back scattering")
    `MPRcc( lambda  ,0.0              ,""            ,0.0           ,1.0          ,"Velocity overshoot coefficient")
    `MPRnb( llambda  ,0.0              ,""                                        ,"Length dependence of velocity overshoot coefficient")
    `MPRnb( wlambda  ,0.0              ,""                                        ,"Width dependence of velocity overshoot coefficient")
    `MPRnb( plambda  ,0.0              ,""                                        ,"Cross-term dependence of velocity overshoot coefficient")
    `MPRcc( rnoia  ,0.577              ,""            ,0.0           ,1.0           ,"Thermal noise coefficient")
    `MPRcc( rnoib  ,0.5164              ,""            ,0.0           ,1.0           ,"Thermal noise coefficient")
    `MPRcc( rnoic  ,0.395              ,""            ,0.0           ,1.0           ,"Thermal noise coefficient")
    `MPRcc( vtl  ,2.05e5              ,"m/s"            ,0.0           ,1.0e7             ,"Thermal velocity")
    `MPRnb( lvtl  ,0.0              ,""                                           ,"Length dependence of thermal velocity")
    `MPRnb( wvtl  ,0.0              ,""                                           ,"Width dependence of thermal velocity")
    `MPRnb( pvtl  ,0.0              ,""                                           ,"Cross-term dependence of thermal velocity")
    `MPRcc( lc  ,0.0              ,"m"            ,0.0           ,1.0              ,"Velocity back scattering coefficient")

    // New model BSIM4 version > 4.3
    `IPRcc( sc  ,0.0              ,"m"            ,0.0           ,1.0     ,"")
    `MPRcc( tvoffcv  ,0.0              ,""            ,0.0           ,1.0        ,"")
    `MPRnb( wtvoffcv  ,0.0              ,""                                      ,"")
    `MPRnb( ltvoffcv  ,0.0              ,""                                      ,"")
    `MPRnb( ptvoffcv  ,0.0              ,""                                      ,"")
    `MPRcc( teta0  ,0.0              ,""            ,0.0           ,1.0      ,"")
    `MPRnb( wteta0  ,0.0              ,""                                    ,"")
    `MPRnb( lteta0  ,0.0              ,""                                    ,"")
    `MPRnb( pteta0  ,0.0              ,""                                    ,"")
    `MPRcc( rbpdl  ,0.0              ,""            ,0.0           ,1.0      ,"")
    `MPRcc( rbpdnf  ,0.0              ,""            ,0.0           ,1.0     ,"")
    `MPRcc( voffcvl  ,0.0              ,""            ,0.0           ,1.0    ,"")
    `MPRcc( tnfactor  ,0.0              ,""            ,0.0           ,1.0   ,"")
    `MPRnb( wtnfactor  ,0.0              ,""                                 ,"")
    `MPRnb( ltnfactor  ,0.0              ,""                                 ,"")
    `MPRnb( ptnfactor  ,0.0              ,""                                 ,"")
    `MPRcc( minvcv  ,0.0              ,""            ,0.0           ,10.0     ,"")
    `MPRnb( wminvcv  ,0.0              ,""                                   ,"")
    `MPRnb( lminvcv  ,0.0              ,""                                   ,"")
    `MPRnb( pminvcv  ,0.0              ,""                                   ,"")
    `MPRcc( tvfbsdoff  ,0.0              ,""            ,0.0           ,1.0  ,"")
    `MPRnb( wtvfbsdoff  ,0.0              ,""                                ,"")
    `MPRnb( ltvfbsdoff  ,0.0              ,""                                ,"")
    `MPRnb( ptvfbsdoff  ,0.0              ,""                                ,"")

    `MPIcc( gidlmod ,1              ,""            ,0             ,1          ,"")
    `MPRcc( aigs  ,1.36e-2              ,""            ,0.0           ,1.0       ,"")
    `MPRcc( waigs  ,0.0              ,""            ,0.0           ,1.0      ,"")
    `MPRcc( laigs  ,0.0              ,""            ,0.0           ,1.0      ,"")
    `MPRcc( paigs  ,0.0              ,""            ,0.0           ,1.0      ,"")
    `MPRcc( bigs  ,1.71e-3              ,""            ,0.0           ,1.0       ,"")
    `MPRcc( wbigs  ,0.0              ,""            ,0.0           ,1.0      ,"")
    `MPRcc( lbigs  ,0.0              ,""            ,0.0           ,1.0      ,"")
    `MPRcc( pbigs  ,0.0              ,""            ,0.0           ,1.0      ,"")
    `MPRcc( cigs  ,0.075              ,""            ,0.0           ,1.0       ,"")
    `MPRcc( wcigs  ,0.0              ,""            ,0.0           ,1.0      ,"")
    `MPRcc( lcigs  ,0.0              ,""            ,0.0           ,1.0      ,"")
    `MPRcc( pcigs  ,0.0              ,""            ,0.0           ,1.0      ,"")
    `MPRcc( aigd  ,1.36e-2              ,""            ,0.0           ,1.0       ,"")
    `MPRcc( waigd  ,0.0              ,""            ,0.0           ,1.0      ,"")
    `MPRcc( laigd  ,0.0              ,""            ,0.0           ,1.0      ,"")
    `MPRcc( paigd  ,0.0              ,""            ,0.0           ,1.0      ,"")
    `MPRcc( bigd  ,1.71e-3              ,""            ,0.0           ,1.0       ,"")
    `MPRcc( wbigd  ,0.0              ,""            ,0.0           ,1.0      ,"")
    `MPRcc( lbigd  ,0.0              ,""            ,0.0           ,1.0      ,"")
    `MPRcc( pbigd  ,0.0              ,""            ,0.0           ,1.0      ,"")
    `MPRcc( cigd  ,0.075              ,""            ,0.0           ,1.0       ,"")
    `MPRcc( wcigd  ,0.0              ,""            ,0.0           ,1.0      ,"")
    `MPRcc( lcigd  ,0.0              ,""            ,0.0           ,1.0      ,"")
    `MPRcc( pcigd  ,0.0              ,""            ,0.0           ,1.0      ,"")
    `IPRcc( delvto  ,0.0             ,"V"            ,0.0           ,1.0     ,"")
    `MPRcc( ados  ,1.0              ,""            ,0.0           ,10.0       ,"")
    `MPRcc( bdos  ,1.0              ,""            ,0.0           ,1.0       ,"")
    `MPRcc( agisl  ,0.0              ,"mS"            ,0.0           ,1.0      ,"")
    `MPRcc( wagisl  ,0.0              ,""            ,0.0           ,1.0     ,"")
    `MPRcc( lagisl  ,0.0              ,""            ,0.0           ,1.0     ,"")
    `MPRcc( pagisl  ,0.0              ,""            ,0.0           ,1.0     ,"")
    `MPRcc( bgisl  ,2.3e9             ,"V/m"            ,0.0           ,1.0e10      ,"")
    `MPRcc( wbgisl  ,0.0              ,""            ,0.0           ,1.0     ,"")
    `MPRcc( lbgisl  ,0.0              ,""            ,0.0           ,1.0     ,"")
    `MPRcc( pbgisl  ,0.0              ,""            ,0.0           ,1.0     ,"")
    `MPRcc( cgisl  ,0.5              ,"V3"            ,0.0           ,1.0      ,"")
    `MPRcc( wcgisl  ,0.0              ,""            ,0.0           ,1.0     ,"")
    `MPRcc( lcgisl  ,0.0              ,""            ,0.0           ,1.0     ,"")
    `MPRcc( pcgisl  ,0.0              ,""            ,0.0           ,1.0     ,"")
    `MPRcc( egisl  ,0.8              ,"V"            ,-1.0           ,10.0      ,"")
    `MPRcc( wegisl  ,0.0              ,""            ,0.0           ,1.0     ,"")
    `MPRcc( legisl  ,0.0              ,""            ,0.0           ,1.0     ,"")
    `MPRcc( pegisl  ,0.0              ,""            ,0.0           ,1.0     ,"")
    `MPRcc( rgisl  ,1.0              ,""            ,0.0           ,10.0      ,"")
    `MPRcc( wrgisl  ,0.0              ,""            ,0.0           ,1.0     ,"")
    `MPRcc( lrgisl  ,0.0              ,""            ,0.0           ,1.0     ,"")
    `MPRcc( prgisl  ,0.0              ,""            ,0.0           ,1.0     ,"")
    `MPRcc( kgisl  ,0.0              ,""            ,0.0           ,1.0      ,"")
    `MPRcc( wkgisl  ,0.0              ,""            ,0.0           ,1.0     ,"")
    `MPRcc( lkgisl  ,0.0              ,""            ,0.0           ,1.0     ,"")
    `MPRcc( pkgisl  ,0.0              ,""            ,0.0           ,1.0     ,"")
    `MPRcc( fgisl  ,1.0              ,"V"            ,0.0           ,10.0      ,"")
    `MPRcc( wfgisl  ,0.0              ,""            ,0.0           ,1.0     ,"")
    `MPRcc( lfgisl  ,0.0              ,""            ,0.0           ,1.0     ,"")
    `MPRcc( pfgisl  ,0.0              ,""            ,0.0           ,1.0     ,"")
    `MPRcc( rgidl  ,1.0              ,""            ,0.0           ,10.0      ,"")
    `MPRcc( wrgidl  ,0.0              ,""            ,0.0           ,1.0     ,"")
    `MPRcc( lrgidl  ,0.0              ,""            ,0.0           ,1.0     ,"")
    `MPRcc( prgidl  ,0.0              ,""            ,0.0           ,1.0     ,"")
    `MPRcc( kgidl  ,0.0              ,""            ,0.0           ,1.0      ,"")
    `MPRcc( wkgidl  ,0.0              ,""            ,0.0           ,1.0     ,"")
    `MPRcc( lkgidl  ,0.0              ,""            ,0.0           ,1.0     ,"")
    `MPRcc( pkgidl  ,0.0              ,""            ,0.0           ,1.0     ,"")
    `MPRcc( fgidl  ,1.0              ,""            ,0.0           ,10.0      ,"")
    `MPRcc( wfgidl  ,0.0              ,""            ,0.0           ,1.0     ,"")
    `MPRcc( lfgidl  ,0.0              ,""            ,0.0           ,1.0     ,"")
    `MPRcc( pfgidl  ,0.0              ,""            ,0.0           ,1.0     ,"")

    `MPIcc( cvchargemod ,1              ,""            ,0             ,1          ,"")
    `MPRcc( ud  ,0.0              ,""            ,0.0           ,1.0     ,"")
    `MPRcc( wud  ,0.0              ,""            ,0.0           ,1.0        ,"")
    `MPRcc( lud  ,0.0              ,""            ,0.0           ,1.0        ,"")
    `MPRcc( pud  ,0.0              ,""            ,0.0           ,1.0        ,"")
    `MPRcc( ud1  ,0.0              ,""            ,0.0           ,1.0        ,"")
    `MPRcc( wud1  ,0.0              ,""            ,0.0           ,1.0       ,"")
    `MPRcc( lud1  ,0.0              ,""            ,0.0           ,1.0       ,"")
    `MPRcc( pud1  ,0.0              ,""            ,0.0           ,1.0       ,"")
    `MPRcc( up  ,0.0              ,""            ,0.0           ,1.0     ,"")
    `MPRcc( wup  ,0.0              ,""            ,0.0           ,1.0        ,"")
    `MPRcc( lup  ,0.0              ,""            ,0.0           ,1.0        ,"")
    `MPRcc( pup  ,0.0              ,""            ,0.0           ,1.0        ,"")
    `MPRcc( lp  ,1e-8              ,""            ,0.0           ,1.0     ,"")
    `MPRcc( wlp  ,0.0              ,""            ,0.0           ,1.0        ,"")
    `MPRcc( llp  ,0.0              ,""            ,0.0           ,1.0        ,"")
    `MPRcc( plp  ,0.0              ,""            ,0.0           ,1.0        ,"")
    `MPRcc( ucs  ,1.67              ,""            ,0.0           ,10.0        ,"")
    `MPRcc( wucs  ,0.0              ,""            ,0.0           ,1.0       ,"")
    `MPRcc( lucs  ,0.0              ,""            ,0.0           ,1.0       ,"")
    `MPRcc( pucs  ,0.0              ,""            ,0.0           ,1.0       ,"")
    `MPRcc( ucste  ,-4.775e-3             ,""            ,-1.0           ,1.0      ,"")
    `MPRcc( wucste  ,0.0              ,""            ,0.0           ,1.0     ,"")
    `MPRcc( lucste  ,0.0              ,""            ,0.0           ,1.0     ,"")
    `MPRcc( pucste  ,0.0              ,""            ,0.0           ,1.0     ,"")
    `MPRcc( kvth0we  ,0.0              ,""            ,0.0           ,1.0    ,"")
    `MPRcc( wkvth0we  ,0.0              ,""            ,-1.0           ,1.0   ,"")
    `MPRcc( lkvth0we  ,0.0              ,""            ,-1.0           ,1.0   ,"")
    `MPRcc( pkvth0we  ,0.0              ,""            ,0.0           ,1.0   ,"")
    `MPRcc( k2we  ,0.0              ,""            ,0.0           ,1.0       ,"")
    `MPRcc( wk2we  ,0.0              ,""            ,-1.0           ,1.0      ,"")
    `MPRcc( lk2we  ,0.0              ,""            ,0.0           ,1.0      ,"")
    `MPRcc( pk2we  ,0.0              ,""            ,0.0           ,1.0      ,"")
    `MPRcc( ku0we  ,0.0              ,""            ,0.0           ,1.0      ,"")
    `MPRcc( wku0we  ,0.0              ,""            ,0.0           ,1.0     ,"")
    `MPRcc( lku0we  ,0.0              ,""            ,0.0           ,1.0     ,"")
    `MPRcc( pku0we  ,0.0              ,""            ,0.0           ,1.0     ,"")
    `MPRcc( vfbsdoff  ,0.0              ,""            ,0.0           ,1.0   ,"")
    `MPRcc( wvfbsdoff  ,0.0              ,""            ,0.0           ,1.0  ,"")
    `MPRcc( lvfbsdoff  ,0.0              ,""            ,0.0           ,1.0  ,"")
    `MPRcc( pvfbsdoff  ,0.0              ,""            ,0.0           ,1.0  ,"")
    `MPRcc( tvoff  ,0.0              ,""            ,0.0           ,1.0      ,"")
    `MPRcc( wtvoff  ,0.0              ,""            ,0.0           ,1.0     ,"")
    `MPRcc( ltvoff  ,0.0              ,""            ,0.0           ,1.0     ,"")
    `MPRcc( ptvoff  ,0.0              ,""            ,0.0           ,1.0     ,"")

    `MPIcc( wpemod ,0              ,""            ,0             ,1          ,"")
    `IPRcc( sca  ,0.0              ,""            ,0.0           ,5.0        ,"")
    `IPRcc( scb  ,0.0              ,""            ,0.0           ,1.0        ,"")
    `IPRcc( scc  ,0.0              ,""            ,0.0           ,1.0        ,"")
    `MPRcc( web  ,0.0              ,""            ,0.0           ,1.0        ,"")
    `MPRcc( wec  ,0.0              ,""            ,0.0           ,1.0        ,"")
    `MPRoc( scref  ,1e-6              ,"m"            ,0.0           ,1.0      ,"")
    `MPRcc( rbps0  ,50.0              ,""            ,0.0           ,1000.0      ,"")
    `MPRcc( rbpsl  ,0.0              ,""            ,0.0           ,1.0      ,"")
    `MPRcc( rbpsw  ,0.0              ,""            ,0.0           ,1.0      ,"")
    `MPRcc( rbpsnf  ,0.0              ,""            ,0.0           ,1.0     ,"")
    `MPRcc( rbpd0  ,50.0              ,""            ,0.0           ,1000.0      ,"")
    `MPRcc( rbpdw  ,0.0              ,""            ,0.0           ,1.0      ,"")
    `MPRcc( rbpbx0  ,100.0              ,""            ,0.0           ,1000.0     ,"")
    `MPRcc( rbpbxl  ,0.0              ,""            ,0.0           ,1.0     ,"")
    `MPRcc( rbpbxw  ,0.0              ,""            ,0.0           ,1.0     ,"")
    `MPRcc( rbpbxnf  ,0.0              ,""            ,0.0           ,1.0    ,"")
    `MPRcc( rbpby0  ,100.0              ,""            ,0.0           ,1000.0     ,"")
    `MPRcc( rbpbyl  ,0.0              ,""            ,0.0           ,1.0     ,"")
    `MPRcc( rbpbyw  ,0.0              ,""            ,0.0           ,1.0     ,"")
    `MPRcc( rbpbynf  ,0.0              ,""            ,0.0           ,1.0    ,"")
    `MPRcc( rbsbx0  ,100.0              ,""            ,0.0           ,1000.0     ,"")
    `MPRcc( rbsby0  ,100.0              ,""            ,0.0           ,1000.0     ,"")
    `MPRcc( rbdbx0  ,100.0              ,""            ,0.0           ,1000.0     ,"")
    `MPRcc( rbdby0  ,100.0              ,""            ,0.0           ,1000.0     ,"")
    `MPRcc( rbsdbxl  ,0.0              ,""            ,0.0           ,1.0    ,"")
    `MPRcc( rbsdbxw  ,0.0              ,""            ,0.0           ,1.0    ,"")
    `MPRcc( rbsdbxnf  ,0.0              ,""            ,0.0           ,1.0   ,"")
    `MPRcc( rbsdbyl  ,0.0              ,""            ,0.0           ,1.0    ,"")
    `MPRcc( rbsdbyw  ,0.0              ,""            ,0.0           ,1.0    ,"")
    `MPRcc( rbsdbynf  ,0.0              ,""            ,0.0           ,1.0   ,"")
    `MPRcc( jtss  ,0.0              ,""            ,0.0           ,1.0       ,"")
    `MPRcc( jtssws  ,0.0              ,""            ,0.0           ,1.0     ,"")
    `MPRcc( jtsswgs  ,0.0              ,""            ,0.0           ,1.0    ,"")
    `MPRcc( jtweff  ,0.0              ,""            ,0.0           ,1.0     ,"")
    `MPRoc( njts  ,20.0              ,""            ,0.0           ,100.0       ,"")
    `MPRoc( njtssw  ,20.0              ,""            ,0.0           ,100.0     ,"")
    `MPRoc( njtsswg  ,20.0              ,""            ,0.0           ,100.0    ,"")
    `MPRcc( xtss  ,0.02              ,""            ,0.0           ,1.0       ,"")
    `MPRcc( xtssws  ,0.02              ,""            ,0.0           ,1.0     ,"")
    `MPRcc( xtsswgs  ,0.02              ,""            ,0.0           ,1.0    ,"")
    `MPRcc( vtss  ,10.0              ,""            ,0.0           ,100.0       ,"")
    `MPRcc( vtssws  ,10.0              ,""            ,0.0           ,100.0     ,"")
    `MPRcc( vtsswgs  ,10.0              ,""            ,0.0           ,100.0    ,"")
    `MPRcc( tnjts  ,0.0              ,""            ,0.0           ,1.0      ,"")
    `MPRcc( tnjtssw  ,0.0              ,""            ,0.0           ,1.0    ,"")
    `MPRcc( tnjtsswg  ,0.0              ,""            ,0.0           ,1.0   ,"")
    `MPRcc( jtsd  ,0.0              ,""            ,0.0           ,1.0       ,"")
    `MPRcc( jtsswd  ,0.0              ,""            ,0.0           ,1.0     ,"")
    `MPRcc( jtsswgd  ,0.0              ,""            ,0.0           ,1.0    ,"")
    `MPRcc( njtsd  ,20.0              ,""            ,0.0           ,100.0      ,"")
    `MPRcc( njtsswd  ,20.0              ,""            ,0.0           ,100.0    ,"")
    `MPRcc( njtsswgd  ,20.0              ,""            ,0.0           ,100.0   ,"")
    `MPRcc( xtsd  ,0.02              ,""            ,0.0           ,1.0       ,"")
    `MPRcc( xtsswd  ,0.02              ,""            ,0.0           ,1.0     ,"")
    `MPRcc( xtsswgd  ,0.02              ,""            ,0.0           ,1.0    ,"")
    `MPRcc( vtsd  ,10.0              ,""            ,0.0           ,100.0       ,"")
    `MPRcc( vtsswd  ,10.0              ,""            ,0.0           ,100.0     ,"")
    `MPRcc( vtsswgd  ,10.0              ,""            ,0.0           ,100.0    ,"")
    `MPRcc( tnjtsd  ,0.0              ,""            ,0.0           ,1.0     ,"")
    `MPRcc( tnjtsswd  ,0.0              ,""            ,0.0           ,1.0   ,"")
    `MPRcc( tnjtsswgd  ,0.0              ,""            ,0.0           ,1.0  ,"")
    `MPRoc( epsrsub  ,11.7              ,""            ,0.0           ,100.0    ,"")
    `MPRcc( phig  ,0.0              ,""            ,0.0           ,10.0       ,"")
    `MPRcc( easub  ,4.05              ,"eV"            ,0.0           ,10.0      ,"")

    `MPIcc( mtrlcompatmod  ,0             ,""            ,0            ,1    ,"")
    `MPIcc( mtrlmod        ,0             ,""            ,0            ,1    ,"")

    `MPRcc( tempeot  ,27.0              ,"C"            ,0.0           ,300.0    ,"")
    `MPRoc( leffeot  ,1e-6              ,""            ,0.0           ,1.0    ,"")
    `MPRcc( weffeot  ,10e-6              ,""            ,0.0           ,1.0    ,"")
    `MPRcc( vddeot  ,1.5              ,"V"            ,-10.0           ,10.0     ,"")
    `MPRcc( eot  ,1.5e-9              ,""            ,0.0           ,1.0e-6  ,"")
    `MPRcc( epsrgate  ,11.7              ,""            ,0.0           ,30.0   ,"")
    `MPRcc( ni0sub  ,1.45e10              ,"cm-3"            ,0.0           ,1.0e20     ,"")
    `MPRcc( bg0sub  ,1.16              ,"eV"            ,0.0           ,10.0     ,"")
    `MPRcc( tbgasub  ,7.02e-4              ,"ev/K"            ,0.0           ,1.0    ,"")
    `MPRcc( tbgbsub  ,1108.0              ,"K"            ,0.0           ,1.0e6    ,"")
    `MPRcc( dvtp2  ,0.0              ,""            ,0.0           ,1.0      ,"")
    `MPRnb( wdvtp2  ,0.0              ,""                                    ,"")
    `MPRnb( ldvtp2  ,0.0              ,""                                    ,"")
    `MPRnb( pdvtp2  ,0.0              ,""                                    ,"")
    `MPRcc( dvtp3  ,0.0              ,""            ,0.0           ,1.0      ,"")
    `MPRnb( wdvtp3  ,0.0              ,""                                    ,"")
    `MPRnb( ldvtp3  ,0.0              ,""                                    ,"")
    `MPRnb( pdvtp3  ,0.0              ,""                                    ,"")
    `MPRcc( dvtp4  ,0.0              ,""            ,0.0           ,1.0      ,"")
    `MPRnb( wdvtp4  ,0.0              ,""                                    ,"")
    `MPRnb( ldvtp4  ,0.0              ,""                                    ,"")
    `MPRnb( pdvtp4  ,0.0              ,""                                    ,"")
    `MPRcc( dvtp5  ,0.0              ,""            ,0.0           ,1.0      ,"")
    `MPRnb( wdvtp5  ,0.0              ,""                                    ,"")
    `MPRnb( ldvtp5  ,0.0              ,""                                    ,"")
    `MPRnb( pdvtp5  ,0.0              ,""                                    ,"")

    //real BSIM4ad, BSIM4as, BSIM4pd, BSIM4ps, BSIM4nrd, BSIM4nrs,BSIM4gcrgs;
    //real BSIM4von, BSIM4qgdo, BSIM4qgso,BSIM4cd,BSIM4vbsc,BSIM4fpkt,BSIM4plcr;
    //real BSIM4qgate, BSIM4qbulk, BSIM4qdrn, BSIM4qsrc;
    real BSIM4ueff, BSIM4thetavth, BSIM4cgdo, BSIM4cgso;
    real BSIM4grbsb, BSIM4grbdb, BSIM4grbpb, BSIM4grbps, BSIM4grbpd;
    real BSIM4vjsmFwd, BSIM4vjsmRev, BSIM4vjdmFwd, BSIM4vjdmRev, BSIM4XExpBVS;
    real BSIM4XExpBVD, BSIM4SslpFwd, BSIM4SslpRev, BSIM4DslpFwd, BSIM4DslpRev;
    real BSIM4IVjsmFwd, BSIM4IVjsmRev, BSIM4IVjdmFwd, BSIM4IVjdmRev;
    real BSIM4grgeltd, BSIM4Pseff, BSIM4Pdeff, BSIM4Aseff, BSIM4Adeff;
    real BSIM4l, BSIM4w, BSIM4drainArea, BSIM4sourceArea;
    real BSIM4drainPerimeter, BSIM4sourcePerimeter;
    integer BSIM4drainSquares, BSIM4sourceSquares;
    real BSIM4sourceConductance, BSIM4drainConductance, BSIM4rbdb, BSIM4rbsb;
    real BSIM4rbpb, BSIM4rbps, BSIM4rbpd;// BSIM4icVDS, BSIM4icVGS, BSIM4icVBS;
    real BSIM4qinv, BSIM4cbd, BSIM4cbs, BSIM4gbd, BSIM4gbs;
    real BSIM4gcrg;
    real BSIM4qbs, BSIM4qbd;
    //    real BSIM4qchqs;

    integer BSIM4nf, BSIM4mode, BSIM4trnqsMod, BSIM4acnqsMod;
    integer BSIM4rbodyMod, BSIM4rgateMod, BSIM4geoMod, BSIM4rgeoMod;
    integer BSIM4capMod, BSIM4dioMod, BSIM4rdsMod, BSIM4paramChk, BSIM4fnoiMod;
    integer BSIM4tnoiMod, BSIM4igcMod, BSIM4igbMod, BSIM4binUnit, BSIM4min;

    real BSIM4sa, BSIM4sb, BSIM4sd, BSIM4saref, BSIM4sbref, BSIM4wlod, BSIM4ku0;
    real BSIM4kvsat, BSIM4tku0, BSIM4lku0, BSIM4wku0, BSIM4pku0, BSIM4rnoia;
    real BSIM4rnoib, BSIM4rnoic, BSIM4tnoic,BSIM4llodku0, BSIM4wlodku0, BSIM4kvth0, BSIM4lkvth0;
    real BSIM4wkvth0, BSIM4pkvth0, BSIM4llodvth, BSIM4wlodvth, BSIM4stk2;
    real BSIM4lodk2, BSIM4steta0, BSIM4lodeta0;

    real BSIM4lambda, BSIM4llambda, BSIM4wlambda, BSIM4plambda;
    real BSIM4vtl, BSIM4lvtl, BSIM4wvtl, BSIM4pvtl;
    real BSIM4xn, BSIM4lxn, BSIM4wxn, BSIM4pxn, BSIM4lc;
    real BSIM4tfactor, BSIM4ku0temp, BSIM4inv_od_ref, BSIM4rho_ref;
    real vs, Fsevl, Inv_saref, Inv_sbref, Inv_sa, Inv_sb, rho, Ldrn, Wdrn;
    real dvth0_lod, W_tmp, Inv_ODeff, OD_offset, dk2_lod, deta0_lod,sceff;
    real BSIM4vfbzbfactor,toxpf,toxpi;

    integer i, niter;
    integer BSIM4tempMod;

    real BSIM4cdsc, BSIM4cdscb, BSIM4cdscd, BSIM4cit, BSIM4nfactor, BSIM4xj;
    real BSIM4vsat, BSIM4at, BSIM4a0, BSIM4ags, BSIM4a1, BSIM4a2, BSIM4keta;
    real BSIM4nsub, BSIM4ndep, BSIM4nsd, BSIM4phin, BSIM4ngate, BSIM4gamma1;
    real BSIM4gamma2, BSIM4vbx, BSIM4vbi, BSIM4vbm, BSIM4xt;
    real BSIM4phi, BSIM4litl, BSIM4k1, BSIM4kt1, BSIM4kt1l, BSIM4kt2, BSIM4k2;
    real BSIM4k3, BSIM4k3b, BSIM4w0, BSIM4dvtp0, BSIM4dvtp1, BSIM4lpe0;
    real BSIM4lpeb, BSIM4dvt0, BSIM4dvt1, BSIM4dvt2, BSIM4dvt0w, BSIM4dvt1w;
    real BSIM4dvt2w, BSIM4drout, BSIM4dsub;
    real BSIM4vth0, BSIM4ua, BSIM4ua1, BSIM4ub, BSIM4ub1, BSIM4uc, BSIM4uc1;
    real BSIM4u0;
    real BSIM4eu, BSIM4ute, BSIM4voff, BSIM4minv, BSIM4vfb, BSIM4delta, BSIM4rdsw;
    real BSIM4rds0, BSIM4rs0, BSIM4rd0, BSIM4rsw, BSIM4rdw, BSIM4prwg, BSIM4prwb;
    real BSIM4prt, BSIM4eta0, BSIM4etab, BSIM4pclm, BSIM4pdibl1;
    real BSIM4pdibl2, BSIM4pdiblb, BSIM4fprout, BSIM4pdits, BSIM4pditsd,DITS_Sft2,dDITS_Sft2_dVd;
    real BSIM4pscbe1, BSIM4pscbe2, BSIM4pvag, BSIM4wr;
    real BSIM4dwg, BSIM4dwb, BSIM4b0, BSIM4b1, BSIM4alpha0, BSIM4alpha1;
    real BSIM4beta0;
    real BSIM4cgidl, BSIM4egidl, BSIM4aigc, BSIM4bigc, BSIM4cigc, BSIM4aigsd;
    real BSIM4bigsd, BSIM4cigsd, BSIM4aigbacc, BSIM4agidl, BSIM4bgidl;
    real BSIM4bigbacc, BSIM4cigbacc, BSIM4aigbinv, BSIM4bigbinv, BSIM4cigbinv;
    real BSIM4nigc, BSIM4nigbacc, BSIM4nigbinv, BSIM4ntox;
    real BSIM4eigbinv, BSIM4pigcd, BSIM4poxedge, BSIM4xrcrg1, BSIM4xrcrg2;
    //real  BSIM4plcrl, BSIM4plcrd,BSIM4cof1,BSIM4cof2, BSIM4cof3, BSIM4cof4,BSIM4vfbzb, BSIM4k2ox;

    /* CV model */
    real BSIM4cgsl, BSIM4cgdl, BSIM4ckappas, BSIM4ckappad, BSIM4cf, BSIM4clc;
    real BSIM4cle, BSIM4vfbcv, BSIM4noff, BSIM4voffcv, BSIM4acde, BSIM4moin;
    real BSIM4dw, BSIM4dl, BSIM4leff, BSIM4weff, BSIM4dwc, BSIM4dlc;
    real BSIM4dlcig, BSIM4dlcigd, BSIM4dwj, BSIM4leffCV, BSIM4weffCV, BSIM4weffCJ;
    real BSIM4abulkCVfactor, BSIM4cgbo, BSIM4u0temp, BSIM4vsattemp, BSIM4sqrtPhi;
    real here_BSIM4vsattemp, here_BSIM4u0temp, here_BSIM4vth0, here_BSIM4vfb;
    real here_BSIM4vfbzb, here_BSIM4vtfbphi1, param_BSIM4kvth0;
    real here_BSIM4vtfbphi2, here_BSIM4vbsc, here_BSIM4k2ox, here_BSIM4eta0;
    real here_BSIM4k2, BSIM4phis3, BSIM4Xdep0, BSIM4sqrtXdep0, BSIM4theta0vb0;
    real BSIM4thetaRout, BSIM4mstar, BSIM4voffcbn, BSIM4rdswmin, BSIM4rdwmin,BSIM4mstarcv,BSIM4voffcbncv;
    real BSIM4rswmin, BSIM4vfbsd;
    real BSIM4cdep0, BSIM4k1ox;
    //real BSIM4vtfbphi1, BSIM4vtfbphi2;
    real BSIM4ToxRatio, BSIM4Aechvb, BSIM4Bechvb;
    real BSIM4ToxRatioEdge, BSIM4AechvbEdgeS, BSIM4AechvbEdgeD, BSIM4BechvbEdge, BSIM4ldeb;

    integer BSIM4type, BSIM4mobMod;

    real BSIM4version, BSIM4toxe, BSIM4toxp, BSIM4toxm, BSIM4dtox, BSIM4epsrox;
    real epsroxl, toxel, epssubl;
    real BSIM4voffl, BSIM4lpdibl1, BSIM4lpdibl2, BSIM4lpdiblb, BSIM4wpdibl1;
    real BSIM4wpdibl2, BSIM4wpdiblb, BSIM4ppdibl1, BSIM4ppdibl2, BSIM4ppdiblb;
    real BSIM4pditsl, BSIM4toxref, BSIM4ijthdfwd, BSIM4ijthsfwd, BSIM4ijthdrev;
    real BSIM4ijthsrev, BSIM4xjbvd, BSIM4xjbvs, BSIM4bvd, BSIM4bvs, BSIM4gbmin;
    //real BSIM4noia, BSIM4noib, BSIM4noic,
    real BSIM4tnoia, BSIM4tnoib, BSIM4ntnoi;

    /* CV model and Parasitics */
    real BSIM4xw, BSIM4xl, BSIM4tcj, BSIM4tcjsw, BSIM4tcjswg, BSIM4tpb;
    real BSIM4tpbsw;
    real BSIM4tpbswg, BSIM4dmcg, BSIM4dmci, BSIM4dmdg, BSIM4dmcgt, BSIM4xgw;
    real BSIM4xgl, BSIM4rsh, BSIM4rshg, BSIM4ngcon;

    /* Length Dependence */
    real BSIM4lcdsc, BSIM4lcdscb, BSIM4lcdscd, BSIM4lcit, BSIM4lnfactor;
    real BSIM4la0, BSIM4lags, BSIM4la1, BSIM4la2, BSIM4lketa, BSIM4lnsub;
    real BSIM4lndep, BSIM4lnsd, BSIM4lxj, BSIM4lvsat, BSIM4lat;
    real BSIM4lphin, BSIM4lngate, BSIM4lgamma1, BSIM4lgamma2, BSIM4lvbx;
    real BSIM4lvbm, BSIM4lxt, BSIM4lk1, BSIM4lkt1, BSIM4lkt1l, BSIM4lkt2;
    real BSIM4lk2, BSIM4lk3, BSIM4lk3b, BSIM4lw0, BSIM4ldvtp0;
    real BSIM4ldvtp1, BSIM4llpe0, BSIM4llpeb, BSIM4ldvt0, BSIM4ldvt1, BSIM4ldvt2;
    real BSIM4ldvt0w, BSIM4ldvt1w, BSIM4ldvt2w, BSIM4ldrout, BSIM4ldsub;
    real BSIM4lvth0, BSIM4lua, BSIM4lua1, BSIM4lub, BSIM4lub1;
    real BSIM4luc, BSIM4luc1, BSIM4lu0, BSIM4leu, BSIM4lute, BSIM4lvoff;
    real BSIM4lminv;
    real BSIM4ldelta, BSIM4lrdsw, BSIM4lrsw, BSIM4lrdw, BSIM4lprwg, BSIM4lprwb;
    real BSIM4lprt, BSIM4leta0, BSIM4letab;
    real BSIM4lpclm, BSIM4lfprout, BSIM4lpdits, BSIM4lpditsd, BSIM4lpscbe1;
    real BSIM4lpscbe2, BSIM4lpvag, BSIM4lwr, BSIM4ldwg, BSIM4ldwb, BSIM4lb0;
    real BSIM4lb1, BSIM4lalpha0, BSIM4lalpha1, BSIM4lbeta0;
    real BSIM4lvfb, BSIM4lagidl, BSIM4lbgidl, BSIM4lcgidl, BSIM4legidl;
    real BSIM4laigc, BSIM4lbigc, BSIM4lcigc;
    real BSIM4laigsd, BSIM4lbigsd, BSIM4lcigsd, BSIM4laigbacc, BSIM4lbigbacc;
    real BSIM4lcigbacc, BSIM4laigbinv, BSIM4lbigbinv;
    real BSIM4lcigbinv, BSIM4lnigc, BSIM4lnigbacc, BSIM4lnigbinv, BSIM4lntox;
    real BSIM4leigbinv, BSIM4lpigcd, BSIM4lpoxedge;
    real BSIM4lxrcrg1, BSIM4lxrcrg2;

    /* CV model */
    real BSIM4lcgsl, BSIM4lcgdl, BSIM4lckappas, BSIM4lckappad, BSIM4lcf;
    real BSIM4lclc, BSIM4lcle, BSIM4lvfbcv;
    real BSIM4lnoff, BSIM4lvoffcv, BSIM4lacde, BSIM4lmoin;

    /* Width Dependence */
    real BSIM4wcdsc, BSIM4wcdscb, BSIM4wcdscd, BSIM4wcit, BSIM4wnfactor;
    real BSIM4wxj, BSIM4wvsat, BSIM4wat;
    real BSIM4wa0, BSIM4wags, BSIM4wa1, BSIM4wa2, BSIM4wketa, BSIM4wnsub;
    real BSIM4wndep, BSIM4wnsd;
    real BSIM4wphin, BSIM4wngate, BSIM4wgamma1, BSIM4wgamma2, BSIM4wvbx;
    real BSIM4wvbm, BSIM4wxt, BSIM4wk1;
    real BSIM4wkt1, BSIM4wkt1l, BSIM4wkt2, BSIM4wk2, BSIM4wk3, BSIM4wk3b;
    real BSIM4ww0, BSIM4wdvtp0, BSIM4wdvtp1, BSIM4wlpe0, BSIM4wlpeb, BSIM4wdvt0;
    real BSIM4wdvt1, BSIM4wdvt2, BSIM4wdvt0w, BSIM4wdvt1w;
    real BSIM4wdvt2w, BSIM4wdrout, BSIM4wdsub, BSIM4wvth0, BSIM4wua, BSIM4wua1;
    real BSIM4wub, BSIM4wub1, BSIM4wuc, BSIM4wuc1, BSIM4wu0, BSIM4weu, BSIM4wute;
    real BSIM4wvoff, BSIM4wminv, BSIM4wdelta, BSIM4wrdsw, BSIM4wrsw, BSIM4wrdw;
    real BSIM4wprwg, BSIM4wprwb, BSIM4wprt, BSIM4weta0, BSIM4wetab, BSIM4wpclm;
    real BSIM4wfprout, BSIM4wpdits, BSIM4wpditsd, BSIM4wpscbe1, BSIM4wpscbe2;
    real BSIM4wpvag, BSIM4wwr, BSIM4wdwg, BSIM4wdwb, BSIM4wb0, BSIM4wb1;
    real BSIM4walpha0, BSIM4walpha1, BSIM4wbeta0;
    real BSIM4wvfb, BSIM4wagidl, BSIM4wbgidl, BSIM4wcgidl, BSIM4wegidl;
    real BSIM4waigc, BSIM4wbigc, BSIM4wcigc;
    real BSIM4waigsd, BSIM4wbigsd, BSIM4wcigsd, BSIM4waigbacc, BSIM4wbigbacc;
    real BSIM4wcigbacc, BSIM4waigbinv, BSIM4wbigbinv;
    real BSIM4wcigbinv, BSIM4wnigc, BSIM4wnigbacc, BSIM4wnigbinv, BSIM4wntox;
    real BSIM4weigbinv, BSIM4wpigcd, BSIM4wpoxedge, BSIM4wxrcrg1, BSIM4wxrcrg2;

    /* CV model */
    real BSIM4wcgsl, BSIM4wcgdl, BSIM4wckappas, BSIM4wckappad, BSIM4wcf;
    real BSIM4wclc, BSIM4wcle, BSIM4wvfbcv;
    real BSIM4wnoff, BSIM4wvoffcv, BSIM4wacde, BSIM4wmoin;

    /* Cross-term Dependence */
    real BSIM4pcdsc, BSIM4pcdscb, BSIM4pcdscd, BSIM4pcit, BSIM4pnfactor;
    real BSIM4pxj, BSIM4pvsat, BSIM4pat;
    real BSIM4pa0, BSIM4pags, BSIM4pa1, BSIM4pa2, BSIM4pketa, BSIM4pnsub;
    real BSIM4pndep, BSIM4pnsd;
    real BSIM4pphin, BSIM4pngate, BSIM4pgamma1, BSIM4pgamma2, BSIM4pvbx;
    real BSIM4pvbm, BSIM4pxt, BSIM4pk1;
    real BSIM4pkt1, BSIM4pkt1l, BSIM4pkt2, BSIM4pk2, BSIM4pk3, BSIM4pk3b;
    real BSIM4pw0, BSIM4pdvtp0;
    real BSIM4pdvtp1, BSIM4plpe0, BSIM4plpeb, BSIM4pdvt0, BSIM4pdvt1, BSIM4pdvt2;
    real BSIM4pdvt0w, BSIM4pdvt1w;
    real BSIM4pdvt2w, BSIM4pdrout, BSIM4pdsub, BSIM4pvth0, BSIM4pua, BSIM4pua1;
    real BSIM4pub, BSIM4pub1;
    real BSIM4puc, BSIM4puc1, BSIM4pu0, BSIM4peu, BSIM4pute, BSIM4pvoff;
    real BSIM4pminv, BSIM4pdelta;
    real BSIM4prdsw, BSIM4prsw, BSIM4prdw, BSIM4pprwg, BSIM4pprwb, BSIM4pprt;
    real BSIM4peta0, BSIM4petab;
    real BSIM4ppclm, BSIM4pfprout, BSIM4ppdits, BSIM4ppditsd, BSIM4ppscbe1;
    real BSIM4ppscbe2, BSIM4ppvag, BSIM4pwr;
    real BSIM4pdwg, BSIM4pdwb, BSIM4pb0, BSIM4pb1, BSIM4palpha0, BSIM4palpha1;
    real BSIM4pbeta0, BSIM4pvfb;
    real BSIM4pagidl, BSIM4pbgidl, BSIM4pcgidl, BSIM4pegidl, BSIM4paigc;
    real BSIM4pbigc, BSIM4pcigc, BSIM4paigsd;
    real BSIM4pbigsd, BSIM4pcigsd, BSIM4paigbacc, BSIM4pbigbacc, BSIM4pcigbacc;
    real BSIM4paigbinv, BSIM4pbigbinv, BSIM4pcigbinv;
    real BSIM4pnigc, BSIM4pnigbacc, BSIM4pnigbinv, BSIM4pntox, BSIM4peigbinv;
    real BSIM4ppigcd, BSIM4ppoxedge, BSIM4pxrcrg1, BSIM4pxrcrg2;

    /* CV model */
    real BSIM4pcgsl, BSIM4pcgdl, BSIM4pckappas, BSIM4pckappad, BSIM4pcf;
    real BSIM4pclc, BSIM4pcle, BSIM4pvfbcv;
    real BSIM4pnoff, BSIM4pvoffcv, BSIM4pacde, BSIM4pmoin, BSIM4tnom, BSIM4xpart;
    //real BSIM4cFringOut, BSIM4cFringMax;

    real BSIM4SjctTempRevSatCur,BSIM4DjctTempRevSatCur,BSIM4SswTempRevSatCur;
    real BSIM4DswTempRevSatCur,BSIM4SswgTempRevSatCur,BSIM4DswgTempRevSatCur;
    real BSIM4sheetResistance, BSIM4SjctSatCurDensity, BSIM4DjctSatCurDensity;
    real BSIM4SjctSidewallSatCurDensity, BSIM4DjctSidewallSatCurDensity;
    real BSIM4SjctGateSidewallSatCurDensity;
    real BSIM4DjctGateSidewallSatCurDensity, BSIM4SbulkJctPotential;
    real BSIM4DbulkJctPotential, BSIM4SbulkJctBotGradingCoeff;
    real BSIM4DbulkJctBotGradingCoeff, BSIM4SbulkJctSideGradingCoeff;
    real BSIM4DbulkJctSideGradingCoeff, BSIM4SbulkJctGateSideGradingCoeff;
    real BSIM4DbulkJctGateSideGradingCoeff, BSIM4SsidewallJctPotential;
    real BSIM4DsidewallJctPotential, BSIM4SGatesidewallJctPotential;
    real BSIM4DGatesidewallJctPotential, BSIM4SunitAreaJctCap;
    real BSIM4DunitAreaJctCap;
    real BSIM4SunitLengthSidewallJctCap, BSIM4DunitLengthSidewallJctCap;
    real BSIM4SunitLengthGateSidewallJctCap;
    real BSIM4DunitLengthGateSidewallJctCap, BSIM4SjctEmissionCoeff;
    real BSIM4DjctEmissionCoeff, BSIM4SjctTempExponent, BSIM4DjctTempExponent;
    real BSIM4Lint, BSIM4Ll;
    real BSIM4Llc, BSIM4Lln, BSIM4Lw, BSIM4Lwc, BSIM4Lwn, BSIM4Lwl, BSIM4Lwlc;
    real BSIM4Lmin;
    real BSIM4Lmax, BSIM4Wint, BSIM4Wl, BSIM4Wlc, BSIM4Wln, BSIM4Ww, BSIM4Wwc;
    real BSIM4Wwn, BSIM4Wwl, BSIM4Wwlc, BSIM4Wmin, BSIM4Wmax;

    //New model parameters version > 4.3
    real BSIM4sc;
    real BSIM4tvoffcv,BSIM4wtvoffcv,BSIM4ltvoffcv,BSIM4ptvoffcv,BSIM4teta0;
    real BSIM4wteta0,BSIM4lteta0,BSIM4pteta0;

    real BSIM4rbpdl,BSIM4rbpdnf,BSIM4voffcvl;
    real BSIM4tnfactor,BSIM4wtnfactor,BSIM4ltnfactor,BSIM4ptnfactor,BSIM4minvcv;
    real BSIM4wminvcv,BSIM4lminvcv,BSIM4pminvcv,BSIM4tvfbsdoff,BSIM4wtvfbsdoff;
    real BSIM4ltvfbsdoff,BSIM4ptvfbsdoff;

    real lnl,lnw,lnnf;
    integer BSIM4gidlMod, bodymode;
    real BSIM4aigs,BSIM4waigs,BSIM4laigs,BSIM4paigs,BSIM4bigs;
    real BSIM4wbigs,BSIM4lbigs,BSIM4pbigs,BSIM4cigs,BSIM4wcigs;
    real BSIM4lcigs,BSIM4pcigs,BSIM4aigd,BSIM4waigd,BSIM4laigd;
    real BSIM4paigd,BSIM4bigd,BSIM4wbigd,BSIM4lbigd,BSIM4pbigd;
    real BSIM4cigd,BSIM4wcigd,BSIM4lcigd,BSIM4pcigd;
    real BSIM4delvto,BSIM4ados,BSIM4bdos;
    real BSIM4agisl,BSIM4wagisl,BSIM4lagisl,BSIM4pagisl,BSIM4bgisl;
    real BSIM4wbgisl,BSIM4lbgisl,BSIM4pbgisl,BSIM4cgisl,BSIM4wcgisl;
    real BSIM4lcgisl,BSIM4pcgisl,BSIM4egisl,BSIM4wegisl,BSIM4legisl;
    real BSIM4pegisl,BSIM4rgisl,BSIM4wrgisl,BSIM4lrgisl,BSIM4prgisl;
    real BSIM4kgisl,BSIM4wkgisl,BSIM4lkgisl,BSIM4pkgisl,BSIM4fgisl;
    real BSIM4wfgisl,BSIM4lfgisl,BSIM4pfgisl,BSIM4rgidl,BSIM4wrgidl;
    real BSIM4lrgidl,BSIM4prgidl,BSIM4kgidl,BSIM4wkgidl,BSIM4lkgidl;
    real BSIM4pkgidl,BSIM4fgidl,BSIM4wfgidl,BSIM4lfgidl,BSIM4pfgidl;

    real BSIM4dvtp2,BSIM4wdvtp2,BSIM4ldvtp2,BSIM4pdvtp2,BSIM4dvtp3,BSIM4dvtp2factor;
    real BSIM4wdvtp3,BSIM4ldvtp3,BSIM4pdvtp3,BSIM4dvtp4,BSIM4wdvtp4;
    real BSIM4ldvtp4,BSIM4pdvtp4,BSIM4dvtp5,BSIM4wdvtp5,BSIM4ldvtp5;
    real BSIM4pdvtp5;

    real BSIM4ni0sub,BSIM4bg0sub,BSIM4tbgasub,BSIM4tbgbsub;
    real BSIM4tempeot,BSIM4leffeot,BSIM4weffeot,BSIM4vddeot,BSIM4eot,BSIM4epsrgate,vddeotl;
    real BSIM4epsrsub,BSIM4phig,BSIM4easub,BSIM4Eg0;
    integer BSIM4mtrlcompatmod,BSIM4mtrlmod,BSIM4cvchargeMod;
    real BSIM4ud,BSIM4wud,BSIM4lud,BSIM4pud,BSIM4ud1;
    real BSIM4wud1,BSIM4lud1,BSIM4pud1,BSIM4up,BSIM4wup;
    real BSIM4lup,BSIM4pup,BSIM4lp,BSIM4wlp,BSIM4llp;
    real BSIM4plp,BSIM4ucs,BSIM4wucs,BSIM4lucs,BSIM4pucs;
    real BSIM4ucste,BSIM4wucste,BSIM4lucste,BSIM4pucste,BSIM4kvth0we;
    real BSIM4wkvth0we,BSIM4lkvth0we,BSIM4pkvth0we,BSIM4k2we,BSIM4wk2we;
    real BSIM4lk2we,BSIM4pk2we,BSIM4ku0we,BSIM4wku0we,BSIM4lku0we;
    real BSIM4pku0we,BSIM4vfbsdoff,BSIM4wvfbsdoff,BSIM4lvfbsdoff,BSIM4pvfbsdoff;
    real BSIM4tvoff,BSIM4wtvoff,BSIM4ltvoff,BSIM4ptvoff;
    real BSIM4wpemod,BSIM4sca,BSIM4scb,BSIM4scc,BSIM4web;
    real BSIM4wec,BSIM4scref,BSIM4rbps0,BSIM4rbpsl,BSIM4rbpsw;
    real BSIM4rbpsnf,BSIM4rbpd0,BSIM4rbpdw,BSIM4rbpbx0,BSIM4rbpbxl;
    real BSIM4rbpbxw,BSIM4rbpbxnf,BSIM4rbpby0,BSIM4rbpbyl,BSIM4rbpbyw;
    real BSIM4rbpbynf,BSIM4rbsbx0,BSIM4rbsby0,BSIM4rbdbx0,BSIM4rbdby0;
    real BSIM4rbsdbxl,BSIM4rbsdbxw,BSIM4rbsdbxnf,BSIM4rbsdbyl,BSIM4rbsdbyw;
    real BSIM4rbsdbynf,BSIM4jtss,BSIM4jtssws,BSIM4jtsswgs;
    real BSIM4jtweff,BSIM4njts,BSIM4njtssw,BSIM4njtsswg,BSIM4xtss;
    real BSIM4xtssws,BSIM4xtsswgs,BSIM4vtss,BSIM4vtssws,BSIM4vtsswgs;
    real BSIM4tnjts,BSIM4tnjtssw,BSIM4tnjtsswg,BSIM4jtsd,BSIM4jtsswd;
    real BSIM4jtsswgd,BSIM4njtsd,BSIM4njtsswd,BSIM4njtsswgd;
    real BSIM4xtsd,BSIM4xtsswd,BSIM4xtsswgd,BSIM4vtsd,BSIM4vtsswd;
    real BSIM4vtsswgd,BSIM4tnjtsd,BSIM4tnjtsswd,BSIM4tnjtsswgd;
    real BSIM4VgsteffVth;
    real BSIM4njtsstemp,BSIM4njtsswstemp,BSIM4njtsswgstemp,BSIM4njtsdtemp,BSIM4njtsswdtemp,BSIM4njtsswgdtemp;
    real Nvtmrssws,Nvtmrsswgs,Nvtmrss,Nvtmrsswd,Nvtmrsswgd,Nvtmrsd;


    /* Pre-calculated constants move to size-dependent param */
    real BSIM4vtm, BSIM4coxe, BSIM4coxp, /*BSIM4vcrit,*/ BSIM4factor1;
    real BSIM4PhiBS, BSIM4PhiBSWS, BSIM4PhiBSWGS;
    real BSIM4SjctTempSatCurDensity, BSIM4SjctSidewallTempSatCurDensity;
    real BSIM4SjctGateSidewallTempSatCurDensity;
    real BSIM4PhiBD, BSIM4PhiBSWD, BSIM4PhiBSWGD, BSIM4DjctTempSatCurDensity;
    real BSIM4DjctSidewallTempSatCurDensity;
    real BSIM4DjctGateSidewallTempSatCurDensity, BSIM4SunitAreaTempJctCap;
    real BSIM4DunitAreaTempJctCap;
    real BSIM4SunitLengthSidewallTempJctCap;
    real BSIM4DunitLengthSidewallTempJctCap;
    real BSIM4SunitLengthGateSidewallTempJctCap;
    real BSIM4DunitLengthGateSidewallTempJctCap, BSIM4oxideTrapDensityA;
    real BSIM4oxideTrapDensityB, BSIM4oxideTrapDensityC, BSIM4em, BSIM4ef;
    real BSIM4af, BSIM4kf, BSIM4perMod;


    // The following are used by the macro definitions:
    real ADiso, ADsha, ADmer, ASiso, ASsha, ASmer;
    real PDiso, PDsha, PDmer, PSiso, PSsha, PSmer;
    real nuIntD, nuEndD, nuIntS, nuEndS;
    real Rint, Rend;

    //integer noiseAnalGiven;
    real DMCGeff, DMCIeff, DMDGeff;
    real tmp, tmp1, tmp2, tmp3, tmp4, Eg, Eg0, ni;
    real T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, Lnew, Wnew;
    real delTemp, T, TRatio, Inv_L, Inv_W, Inv_LW, Vtm0, Tnom;
    real dumPs, dumPd, dumAs, dumAd, PowWeffWr;
    real Nvtms, Nvtmd;
    real Rs, Rd;
    real vgs_eff, vgd_eff;
    real vses, vdes;
    real vges, vgms, vgmd;
    real vgmb, qgmb, qgmid;
    real vgdx,vgsx;
    real vbd, vbs, vds, vgb, vgd, vgs;
    real vdbs, vdbd, vsbs;
    real vbs_jct, vbd_jct, SourceSatCurrent, DrainSatCurrent;
    real qgb, VgstNVt, ExpVgst, cdrain;
    real czbd, czbdsw, czbdswg, czbs, czbssw, czbsswg, evbd, evbs, arg, sarg;
    real Vfbeff, V3, V4;
    real MJD, MJSWD, MJSWGD, MJS, MJSWS, MJSWGS;
    real qgate, qbulk, qdrn, qsrc;
    real Vdb, Vds, Vgs, Vbs;
    real Igidl, Voxacc, Voxdepinv, VxNVt, ExpVxNVt, Vaux;
    real Igc, Igcs, Igcd, Igs, Igbacc, Igbinv, Igb, Igd, Pigcd;
    real Vgs_eff, Vfb, Vth_NarrowW, dvgs_eff_dvg, dvgd_eff_dvg;
    real Phis, sqrtPhis, Vth, Vgst, Vtm, dVgs_eff_dVg;
    real n, local_voffcv, local_noff;
    real V0, CoxWLcen, LINK, VgDP;
    real DeltaPhi, Cox, Tox, Tcen, Ccen, Coxeff;
    real Denomi, ueff, Esat, Vdsat, EsatL;
    real Vasat, Va, Vbseff;
    real Arg1, One_Third_CoxWL, Two_Third_CoxWL, Alphaz, CoxWL;
    real T10, T11, T12, T13, T14;
    real Abulk, here_Abulk, Abulk0, Cclm, FP, VADITS, Lpe_Vb;
    real VACLM, VADIBL, VASCBE, Xdep, lt1, ltw, Delt_vth;
    real Theta0, TempRatio;
    real DIBL_Sft, dDIBL_Sft_dVd, Lambda;
    real a1l, PvagTerm;
    real Vgsteff, here_Vgsteff, Vdseff, here_Vdseff, VdseffCV, VbseffCV;
    real diffVds, dAbulk_dVg;
    real beta, gche, fgche1, fgche2, Idl;
    real Idsa, Ids, Gm, Gds, Gmb, devbs_dvb, devbd_dvb;
    real Isub;
    real CoxeffWovL, Rds, WVCox, WVCoxRds;
    real Vgst2Vtm, VdsatCV, Leff, Weff, AbulkCV;
    real qgdo, qgso;
    real Qac0, Qsub0, Igisl;
    real Fatal_Flag, Issi, Iddi;
    real vtfbphi2eot, phieot, TempRatioeot, Vtm0eot, Vtmeot,vbieot;

    real flickerNoiseContrib, thermalNoiseContrib;
    real esat, DelClm, N0, Nl, AbovVgst2Vtm, BSIM4nstar;
    real gspr, gdpr, grdsw, inv_grdsw;
    real npart_beta, npart_theta, IdovVds;
    real igsquare, Swi, Ssi;
    real BSIM4gstot, BSIM4gdtot;

    // The following are only needed for the tnoiMod==1
    real dT0_dvg;
    real dT3_dvg;
    real dT0_dVg, dT0_dVd, dT0_dVb;
    real dT1_dVg, dT1_dVd, dT1_dVb;
    real dT2_dVg, dT2_dVd, dT2_dVb;
    real dT3_dVg, dT3_dVd, dT3_dVb;
    real dT4_dVd, dT4_dVb;
    real dT5_dVb;
    real dT6_dVg, dT6_dVb;
    real dT7_dVg, dT7_dVd, dT7_dVb;
    real dT8_dVg, dT8_dVd, dT8_dVb;
    real dT9_dVg, dT9_dVd, dT9_dVb;
    real dT10_dVg, dT10_dVd, dT10_dVb;
    real dbeta_dVg, dbeta_dVd, dbeta_dVb;
    real dCoxeff_dVg ;
    real dTcen_dVg ;
    real dVasat_dVg, dVasat_dVd, dVasat_dVb;
    real dVdseff_dVg, dVdseff_dVd, dVdseff_dVb;
    real dVdsat_dVg, dVdsat_dVd, dVdsat_dVb;
    real dLambda_dVg;
    real dgche_dVg, dgche_dVd, dgche_dVb;
    real dfgche1_dVg, dfgche1_dVd, dfgche1_dVb;
    real dfgche2_dVg, dfgche2_dVd, dfgche2_dVb;
    real dIdsa_dVg, dIdsa_dVd, dIdsa_dVb;
    real dVASCBE_dVg, dVASCBE_dVd, dVASCBE_dVb;
    real dVa_dVg, dVa_dVd, dVa_dVb;
    real dVADIBL_dVg, dVADIBL_dVd, dVADIBL_dVb;
    real dVACLM_dVg, dVACLM_dVd, dVACLM_dVb;
    real dCclm_dVg, dCclm_dVd, dCclm_dVb;
    real dPvagTerm_dVg, dPvagTerm_dVd, dPvagTerm_dVb;
    real dFP_dVg;
    real dIdl_dVg, dIdl_dVd, dIdl_dVb;
    real dEsatL_dVg, dEsatL_dVd, dEsatL_dVb;
    real dAbulk_dVb;
    real dAbulk0_dVb;
    real dn_dVd, dn_dVb;
    real dVth_dVd, dVth_dVb;
    real dTheta0_dVb;
    real dDelt_vth_dVb;
    real dDITS_Sft_dVd, dDITS_Sft_dVb;
    real dVgsteff_dVg, dVgsteff_dVd, dVgsteff_dVb;
    real dRds_dVg, dRds_dVb;
    real dWeff_dVg, dWeff_dVb;
    real dDenomi_dVg, dDenomi_dVd, dDenomi_dVb;
    real dueff_dVg, dueff_dVd, dueff_dVb;
    real dVfbeff_dVg, dVfbeff_dVb;
    real dVoxacc_dVg, dVoxacc_dVb;
    real dVoxdepinv_dVg, dVoxdepinv_dVd, dVoxdepinv_dVb;
    real dVaux_dVg, dVaux_dVd, dVaux_dVb;
    real dPigcd_dVg, dPigcd_dVd, dPigcd_dVb;
    real dVbseff_dVb;
    real dsqrtPhis_dVb, dXdep_dVb, dlt1_dVb, dltw_dVb;

    analog begin

        `INITIAL_INSTANCE begin
            T = $temperature; //move into @initial_step block to avoid va-parsing error
            BSIM4Adeff = 0.0;
            BSIM4Aseff = 0.0;
            BSIM4DslpFwd = 0.0;
            BSIM4DslpRev = 0.0;
            BSIM4DunitAreaTempJctCap = 0.0;
            BSIM4DunitLengthGateSidewallTempJctCap = 0.0;
            BSIM4DunitLengthSidewallTempJctCap = 0.0;
            BSIM4IVjdmFwd = 0.0;
            BSIM4IVjdmRev = 0.0;
            BSIM4IVjsmFwd = 0.0;
            BSIM4IVjsmRev = 0.0;
            BSIM4Pdeff = 0.0;
            BSIM4Pseff = 0.0;
            BSIM4SslpFwd = 0.0;
            BSIM4SslpRev = 0.0;
            BSIM4SunitAreaTempJctCap = 0.0;
            BSIM4SunitLengthGateSidewallTempJctCap = 0.0;
            BSIM4SunitLengthSidewallTempJctCap = 0.0;
            BSIM4af = af;
            BSIM4kf = kf;
            BSIM4ef = ef;
            BSIM4em = em;
            BSIM4cbd = 0.0;
            BSIM4cbs = 0.0;
            BSIM4gbd = 0.0;
            BSIM4gbs = 0.0;
            BSIM4gcrg = 0.0;
            BSIM4grbdb = 0.0;
            BSIM4grbpb = 0.0;
            BSIM4grbpd = 0.0;
            BSIM4grbps = 0.0;
            BSIM4grbsb = 0.0;
            //BSIM4icVBS = 0.0;
            //BSIM4icVDS = 0.0;
            //BSIM4icVGS = 0.0;
            BSIM4qbd = 0.0;
            BSIM4qbs = 0.0;
            //BSIM4qchqs = 0.0;
            BSIM4vjdmFwd = 0.0;
            BSIM4vjdmRev = 0.0;
            BSIM4vjsmFwd = 0.0;
            BSIM4vjsmRev = 0.0;
            DrainSatCurrent = 0.0;
            Igd = 0.0;
            Igs = 0.0;
            Nvtmd = 0.0;
            Rd = 0.0;
            Rend = 0.0;
            Rint = 0.0;
            Rs = 0.0;
            Vfb = 0.0;
            Voxacc = 0.0;
            Voxdepinv = 0.0;
            nuEndD = 0.0;
            nuEndS = 0.0;
            nuIntD = 0.0;
            nuIntS = 0.0;
            qbulk = 0.0;
            qdrn = 0.0;
            qgate = 0.0;
            tmp = 0.0;

            dVdsat_dVb = 0.0;
            dVdsat_dVd = 0.0;
            dVdsat_dVg = 0.0;
            dVdseff_dVb = 0.0;
            dVdseff_dVd = 0.0;
            dVdseff_dVg = 0.0;
            dVgs_eff_dVg = 0.0;
            dVgsteff_dVb = 0.0;
            dVgsteff_dVd = 0.0;
            dVgsteff_dVg = 0.0;
            dVoxacc_dVb = 0.0;
            dVoxacc_dVg = 0.0;
            dVoxdepinv_dVb = 0.0;
            dVoxdepinv_dVd = 0.0;
            dVoxdepinv_dVg = 0.0;
            dVth_dVb = 0.0;
            dVth_dVd = 0.0;
            dWeff_dVb = 0.0;
            dWeff_dVg = 0.0;
            dXdep_dVb = 0.0;
            dltw_dVb = 0.0;
            dn_dVb = 0.0;
            dn_dVd = 0.0;
            dsqrtPhis_dVb = 0.0;
            dueff_dVb = 0.0;
            dueff_dVd = 0.0;
            dueff_dVg = 0.0;
            grdsw = 0.0;
            inv_grdsw = 0.0;
            BSIM4gdtot= 0.0;
            BSIM4gstot= 0.0;
            BSIM4lxn= 0.0;
            BSIM4pxn= 0.0;
            BSIM4qinv= 0.0;
            BSIM4tfactor= 0.0;
            BSIM4wxn= 0.0;
            ExpVxNVt= 0.0;
            Gds= 0.0;
            Gm= 0.0;
            Gmb= 0.0;
            Igc= 0.0;
            Pigcd= 0.0;
            T6= 0.0;
            Vaux= 0.0;
            Vfbeff= 0.0;
            dAbulk_dVb= 0.0;
            dCclm_dVb= 0.0;
            dCclm_dVd= 0.0;
            dCclm_dVg= 0.0;
            dDelt_vth_dVb= 0.0;
            dEsatL_dVb= 0.0;
            dEsatL_dVd= 0.0;
            dEsatL_dVg= 0.0;
            dFP_dVg= 0.0;
            dIdl_dVb= 0.0;
            dIdl_dVd= 0.0;
            dIdl_dVg= 0.0;
            dIdsa_dVb= 0.0;
            dIdsa_dVd= 0.0;
            dIdsa_dVg= 0.0;
            dLambda_dVg= 0.0;
            dPvagTerm_dVb= 0.0;
            dPvagTerm_dVd= 0.0;
            dPvagTerm_dVg= 0.0;
            dRds_dVb= 0.0;
            dRds_dVg= 0.0;
            dTheta0_dVb= 0.0;
            dVACLM_dVb= 0.0;
            dVACLM_dVd= 0.0;
            dVACLM_dVg= 0.0;
            dVADIBL_dVb= 0.0;
            dVADIBL_dVd= 0.0;
            dVADIBL_dVg= 0.0;
            dVASCBE_dVb= 0.0;
            dVASCBE_dVd= 0.0;
            dVASCBE_dVg= 0.0;
            dVa_dVb= 0.0;
            dVa_dVd= 0.0;
            dVa_dVg= 0.0;
            dVasat_dVb= 0.0;
            dVasat_dVd= 0.0;
            dVasat_dVg= 0.0;
            dVbseff_dVb= 0.0;

            BSIM4l = l;
            BSIM4w = w;
            BSIM4nf = nf;

            // BSIM4.3
            Ldrn = BSIM4l;
            BSIM4lc = lc;
            BSIM4llodku0 = llodku0;
            BSIM4wlodku0 = wlodku0;

            BSIM4rnoia = rnoia;
            BSIM4rnoib = rnoib;
            BSIM4rnoic = rnoic;

            BSIM4min = minsd;
            BSIM4drainArea = ad;
            BSIM4sourceArea = as;
            BSIM4drainSquares = nrd;
            BSIM4sourceSquares = nrs;
            BSIM4sourcePerimeter = ps;
            BSIM4drainPerimeter = pd;
            BSIM4trnqsMod = trnqsmod;
            BSIM4acnqsMod = acnqsmod;
            BSIM4rbodyMod = rbodymod;
            BSIM4rgateMod = rgatemod;
            BSIM4geoMod = geomod;
            BSIM4rgeoMod = rgeomod;
            BSIM4capMod = capmod;
            BSIM4dioMod = diomod;
            BSIM4rdsMod = rdsmod;
            BSIM4fnoiMod = fnoimod;
            BSIM4tnoiMod = tnoimod;
            BSIM4igcMod = igcmod;
            BSIM4igbMod = igbmod;

            BSIM4type = type;
            BSIM4mobMod = mobmod;
            BSIM4tempMod = tempmod;

            BSIM4binUnit = binunit;
            BSIM4paramChk = paramchk;
            BSIM4perMod = permod;
            BSIM4version = version;
            BSIM4toxe = toxe;
            BSIM4toxp = toxp;
            BSIM4toxm = toxm;
            BSIM4dtox = dtox;
            BSIM4epsrox = epsrox;
            BSIM4cdsc = cdsc;
            BSIM4cdscb = cdscb;
            BSIM4cdscd = cdscd;
            BSIM4cit = cit;
            BSIM4nfactor = nfactor;
            BSIM4xj = xj;
            BSIM4vsat = vsat;
            BSIM4at = at;
            BSIM4a0 = a0;
            BSIM4ags = ags;
            BSIM4a1 = a1;
            BSIM4a2 = a2;
            BSIM4keta = keta;
            BSIM4nsub = nsub;
            BSIM4ndep = ndep;
            BSIM4nsd = nsd;
            BSIM4phin = phin;
            BSIM4ngate = ngate;
            BSIM4gamma1 = gamma1;
            BSIM4gamma2 = gamma2;
            BSIM4vbx = vbx;
            BSIM4vbm = vbm;
            BSIM4xt = xt;
            BSIM4k1 = k1;
            BSIM4kt1 = kt1;
            BSIM4kt1l = kt1l;
            BSIM4kt2 = kt2;
            BSIM4k2 = k2;
            BSIM4k3 = k3;
            BSIM4k3b = k3b;
            BSIM4w0 = w0;
            BSIM4dvtp0 = dvtp0;
            BSIM4dvtp1 = dvtp1;
            BSIM4lpe0 = lpe0;
            BSIM4lpeb = lpeb;
            BSIM4dvt0 = dvt0;
            BSIM4dvt1 = dvt1;
            BSIM4dvt2 = dvt2;
            BSIM4dvt0w = dvt0w;
            BSIM4dvt1w = dvt1w;
            BSIM4dvt2w = dvt2w;
            BSIM4drout = drout;
            BSIM4dsub = dsub;
            BSIM4vth0 = vth0;
            BSIM4eu = eu;
            BSIM4ua = ua;
            BSIM4ua1 = ua1;
            BSIM4ub = ub;
            BSIM4ub1 = ub1;
            BSIM4uc = uc;
            BSIM4uc1 = uc1;
            BSIM4u0 = u0;
            BSIM4ute = ute;
            BSIM4voff = voff;
            BSIM4minv = minv;
            BSIM4voffl = voffl;
            BSIM4delta = delta;
            BSIM4rdsw = rdsw;
            BSIM4rdswmin = rdswmin;
            BSIM4rdwmin = rdwmin;
            BSIM4rswmin = rswmin;
            BSIM4rsw = rsw;
            BSIM4rdw = rdw;
            BSIM4prwg = prwg;
            BSIM4prwb = prwb;
            BSIM4prt = prt;
            BSIM4eta0 = eta0;
            BSIM4etab = etab;
            BSIM4pclm = pclm;
            BSIM4pdibl1 = pdiblc1;
            BSIM4pdibl2 = pdiblc2;
            BSIM4pdiblb = pdiblcb;
            BSIM4lpdibl1 = lpdiblc1;
            BSIM4lpdibl2 = lpdiblc2;
            BSIM4lpdiblb = lpdiblcb;
            BSIM4wpdibl1 = wpdiblc1;
            BSIM4wpdibl2 = wpdiblc2;
            BSIM4wpdiblb = wpdiblcb;
            BSIM4ppdibl1 = ppdiblc1;
            BSIM4ppdibl2 = ppdiblc2;
            BSIM4ppdiblb = ppdiblcb;
            BSIM4fprout = fprout;
            BSIM4pdits = pdits;
            BSIM4pditsd = pditsd;
            BSIM4pditsl = pditsl;
            BSIM4pscbe1 = pscbe1;
            BSIM4pscbe2 = pscbe2;
            BSIM4pvag = pvag;
            BSIM4wr = wr;
            BSIM4dwg = dwg;
            BSIM4dwb = dwb;
            BSIM4b0 = b0;
            BSIM4b1 = b1;
            BSIM4alpha0 = alpha0;
            BSIM4alpha1 = alpha1;
            BSIM4beta0 = beta0;
            BSIM4agidl = agidl;
            BSIM4bgidl = bgidl;
            BSIM4cgidl = cgidl;
            BSIM4egidl = egidl;
            BSIM4aigc = aigc;
            BSIM4bigc = bigc;
            BSIM4cigc = cigc;
            BSIM4aigsd = aigsd;
            BSIM4bigsd = bigsd;
            BSIM4cigsd = cigsd;
            BSIM4aigbacc = aigbacc;
            BSIM4bigbacc = bigbacc;
            BSIM4cigbacc = cigbacc;
            BSIM4aigbinv = aigbinv;
            BSIM4bigbinv = bigbinv;
            BSIM4cigbinv = cigbinv;
            BSIM4nigc = nigc;
            BSIM4nigbacc = nigbacc;
            BSIM4nigbinv = nigbinv;
            BSIM4ntox = ntox;
            BSIM4eigbinv = eigbinv;
            BSIM4pigcd = pigcd;
            BSIM4poxedge = poxedge;
            BSIM4toxref = toxref;
            BSIM4ijthdfwd = ijthdfwd;
            BSIM4ijthsfwd = ijthsfwd;
            BSIM4ijthdrev = ijthdrev;
            BSIM4ijthsrev = ijthsrev;
            BSIM4xjbvd = xjbvd;
            BSIM4xjbvs = xjbvs;
            BSIM4bvd = bvd;
            BSIM4bvs = bvs;
            BSIM4xrcrg1 = xrcrg1;
            BSIM4xrcrg2 = xrcrg2;
            BSIM4vfb = vfb;
            BSIM4gbmin = gbmin;
            BSIM4rbdb = rbdb;
            BSIM4rbsb = rbsb;
            BSIM4rbpb = rbpb;
            BSIM4rbps = rbps;
            BSIM4rbpd = rbpd;
            BSIM4oxideTrapDensityA = noia;
            BSIM4oxideTrapDensityB = noib;
            BSIM4oxideTrapDensityC = noic;
            BSIM4tnoia = tnoia;
            BSIM4tnoib = tnoib;
            BSIM4tnoic = tnoic;
            BSIM4ntnoi = ntnoi;
            BSIM4cgsl = cgsl;
            BSIM4cgdl = cgdl;
            BSIM4ckappas = ckappas;
            BSIM4ckappad = ckappad;
            BSIM4cf = cf;
            BSIM4vfbcv = vfbcv;
            BSIM4clc = clc;
            BSIM4cle = cle;
            BSIM4dwc = dwc;
            BSIM4dlc = dlc;
            BSIM4xw = xw;
            BSIM4xl = xl;
            BSIM4dlcig = dlcig;
            BSIM4dlcigd = dlcigd;
            BSIM4dwj = dwj;
            BSIM4noff = noff;
            BSIM4voffcv = voffcv;
            BSIM4acde = acde;
            BSIM4moin = moin;
            BSIM4tcj = tcj;
            BSIM4tcjsw = tcjsw;
            BSIM4tcjswg = tcjswg;
            BSIM4tpb = tpb;
            BSIM4tpbsw = tpbsw;
            BSIM4tpbswg = tpbswg;
            BSIM4dmcg = dmcg;
            BSIM4dmci = dmci;
            BSIM4dmdg = dmdg;
            BSIM4dmcgt = dmcgt;
            BSIM4xgw = xgw;
            BSIM4xgl = xgl;
            BSIM4rsh = rsh;
            BSIM4rshg = rshg;
            BSIM4ngcon = ngcon;
            BSIM4lcdsc = lcdsc;
            BSIM4lcdscb = lcdscb;
            BSIM4lcdscd = lcdscd;
            BSIM4lcit = lcit;
            BSIM4lnfactor = lnfactor;
            BSIM4lxj = lxj;
            BSIM4lvsat = lvsat;
            BSIM4lat = lat;
            BSIM4la0 = la0;
            BSIM4lags = lags;
            BSIM4la1 = la1;
            BSIM4la2 = la2;
            BSIM4lketa = lketa;
            BSIM4lnsub = lnsub;
            BSIM4lndep = lndep;
            BSIM4lnsd = lnsd;
            BSIM4lphin = lphin;
            BSIM4lngate = lngate;
            BSIM4lgamma1 = lgamma1;
            BSIM4lgamma2 = lgamma2;
            BSIM4lvbx = lvbx;
            BSIM4lvbm = lvbm;
            BSIM4lxt = lxt;
            BSIM4lk1 = lk1;
            BSIM4lkt1 = lkt1;
            BSIM4lkt1l = lkt1l;
            BSIM4lkt2 = lkt2;
            BSIM4lk2 = lk2;
            BSIM4lk3 = lk3;
            BSIM4lk3b = lk3b;
            BSIM4lw0 = lw0;
            BSIM4ldvtp0 = ldvtp0;
            BSIM4ldvtp1 = ldvtp1;
            BSIM4llpe0 = llpe0;
            BSIM4llpeb = llpeb;
            BSIM4ldvt0 = ldvt0;
            BSIM4ldvt1 = ldvt1;
            BSIM4ldvt2 = ldvt2;
            BSIM4ldvt0w = ldvt0w;
            BSIM4ldvt1w = ldvt1w;
            BSIM4ldvt2w = ldvt2w;
            BSIM4ldrout = ldrout;
            BSIM4ldsub = ldsub;
            BSIM4lvth0 = lvth0;
            BSIM4lua = lua;
            BSIM4lua1 = lua1;
            BSIM4lub = lub;
            BSIM4lub1 = lub1;
            BSIM4luc = luc;
            BSIM4luc1 = luc1;
            BSIM4lu0 = lu0;
            BSIM4leu = leu;
            BSIM4lute = lute;
            BSIM4lvoff = lvoff;
            BSIM4lminv = lminv;
            BSIM4ldelta = ldelta;
            BSIM4lrdsw = lrdsw;
            BSIM4lrsw = lrsw;
            BSIM4lrdw = lrdw;
            BSIM4lprwg = lprwg;
            BSIM4lprwb = lprwb;
            BSIM4lprt = lprt;
            BSIM4leta0 = leta0;
            BSIM4letab = letab;
            BSIM4lpclm = lpclm;
            BSIM4lfprout = lfprout;
            BSIM4lpdits = lpdits;
            BSIM4lpditsd = lpditsd;
            BSIM4lpscbe1 = lpscbe1;
            BSIM4lpscbe2 = lpscbe2;
            BSIM4lpvag = lpvag;
            BSIM4lwr = lwr;
            BSIM4ldwg = ldwg;
            BSIM4ldwb = ldwb;
            BSIM4lb0 = lb0;
            BSIM4lb1 = lb1;
            BSIM4lalpha0 = lalpha0;
            BSIM4lalpha1 = lalpha1;
            BSIM4lbeta0 = lbeta0;
            BSIM4lvfb = lvfb;
            BSIM4lagidl = lagidl;
            BSIM4lbgidl = lbgidl;
            BSIM4lcgidl = lcgidl;
            BSIM4legidl = legidl;
            BSIM4laigc = laigc;
            BSIM4lbigc = lbigc;
            BSIM4lcigc = lcigc;
            BSIM4laigsd = laigsd;
            BSIM4lbigsd = lbigsd;
            BSIM4lcigsd = lcigsd;
            BSIM4laigbacc = laigbacc;
            BSIM4lbigbacc = lbigbacc;
            BSIM4lcigbacc = lcigbacc;
            BSIM4laigbinv = laigbinv;
            BSIM4lbigbinv = lbigbinv;
            BSIM4lcigbinv = lcigbinv;
            BSIM4lnigc = lnigc;
            BSIM4lnigbacc = lnigbacc;
            BSIM4lnigbinv = lnigbinv;
            BSIM4lntox = lntox;
            BSIM4leigbinv = leigbinv;
            BSIM4lpigcd = lpigcd;
            BSIM4lpoxedge = lpoxedge;
            BSIM4lxrcrg1 = lxrcrg1;
            BSIM4lxrcrg2 = lxrcrg2;
            BSIM4lcgsl = lcgsl;
            BSIM4lcgdl = lcgdl;
            BSIM4lckappas = lckappas;
            BSIM4lckappad = lckappad;
            BSIM4lcf = lcf;
            BSIM4lclc = lclc;
            BSIM4lcle = lcle;
            BSIM4lvfbcv = lvfbcv;
            BSIM4lnoff = lnoff;
            BSIM4lvoffcv = lvoffcv;
            BSIM4lacde = lacde;
            BSIM4lmoin = lmoin;
            BSIM4wcdsc = wcdsc;
            BSIM4wcdscb = wcdscb;
            BSIM4wcdscd = wcdscd;
            BSIM4wcit = wcit;
            BSIM4wnfactor = wnfactor;
            BSIM4wxj = wxj;
            BSIM4wvsat = wvsat;
            BSIM4wat = wat;
            BSIM4wa0 = wa0;
            BSIM4wags = wags;
            BSIM4wa1 = wa1;
            BSIM4wa2 = wa2;
            BSIM4wketa = wketa;
            BSIM4wnsub = wnsub;
            BSIM4wndep = wndep;
            BSIM4wnsd = wnsd;
            BSIM4wphin = wphin;
            BSIM4wngate = wngate;
            BSIM4wgamma1 = wgamma1;
            BSIM4wgamma2 = wgamma2;
            BSIM4wvbx = wvbx;
            BSIM4wvbm = wvbm;
            BSIM4wxt = wxt;
            BSIM4wk1 = wk1;
            BSIM4wkt1 = wkt1;
            BSIM4wkt1l = wkt1l;
            BSIM4wkt2 = wkt2;
            BSIM4wk2 = wk2;
            BSIM4wk3 = wk3;
            BSIM4wk3b = wk3b;
            BSIM4ww0 = ww0;
            BSIM4wdvtp0 = wdvtp0;
            BSIM4wdvtp1 = wdvtp1;
            BSIM4wlpe0 = wlpe0;
            BSIM4wlpeb = wlpeb;
            BSIM4wdvt0 = wdvt0;
            BSIM4wdvt1 = wdvt1;
            BSIM4wdvt2 = wdvt2;
            BSIM4wdvt0w = wdvt0w;
            BSIM4wdvt1w = wdvt1w;
            BSIM4wdvt2w = wdvt2w;
            BSIM4wdrout = wdrout;
            BSIM4wdsub = wdsub;
            BSIM4wvth0 = wvth0;
            BSIM4wua = wua;
            BSIM4wua1 = wua1;
            BSIM4wub = wub;
            BSIM4wub1 = wub1;
            BSIM4wuc = wuc;
            BSIM4wuc1 = wuc1;
            BSIM4wu0 = wu0;
            BSIM4weu = weu;
            BSIM4wute = wute;
            BSIM4wvoff = wvoff;
            BSIM4wminv = wminv;
            BSIM4wdelta = wdelta;
            BSIM4wrdsw = wrdsw;
            BSIM4wrsw = wrsw;
            BSIM4wrdw = wrdw;
            BSIM4wprwg = wprwg;
            BSIM4wprwb = wprwb;
            BSIM4wprt = wprt;
            BSIM4weta0 = weta0;
            BSIM4wetab = wetab;
            BSIM4wpclm = wpclm;
            BSIM4wfprout = wfprout;
            BSIM4wpdits = wpdits;
            BSIM4wpditsd = wpditsd;
            BSIM4wpscbe1 = wpscbe1;
            BSIM4wpscbe2 = wpscbe2;
            BSIM4wpvag = wpvag;
            BSIM4wwr = wwr;
            BSIM4wdwg = wdwg;
            BSIM4wdwb = wdwb;
            BSIM4wb0 = wb0;
            BSIM4wb1 = wb1;
            BSIM4walpha0 = walpha0;
            BSIM4walpha1 = walpha1;
            BSIM4wbeta0 = wbeta0;
            BSIM4wvfb = wvfb;
            BSIM4wagidl = wagidl;
            BSIM4wbgidl = wbgidl;
            BSIM4wcgidl = wcgidl;
            BSIM4wegidl = wegidl;
            BSIM4waigc = waigc;
            BSIM4wbigc = wbigc;
            BSIM4wcigc = wcigc;
            BSIM4waigsd = waigsd;
            BSIM4wbigsd = wbigsd;
            BSIM4wcigsd = wcigsd;
            BSIM4waigbacc = waigbacc;
            BSIM4wbigbacc = wbigbacc;
            BSIM4wcigbacc = wcigbacc;
            BSIM4waigbinv = waigbinv;
            BSIM4wbigbinv = wbigbinv;
            BSIM4wcigbinv = wcigbinv;
            BSIM4wnigc = wnigc;
            BSIM4wnigbacc = wnigbacc;
            BSIM4wnigbinv = wnigbinv;
            BSIM4wntox = wntox;
            BSIM4weigbinv = weigbinv;
            BSIM4wpigcd = wpigcd;
            BSIM4wpoxedge = wpoxedge;
            BSIM4wxrcrg1 = wxrcrg1;
            BSIM4wxrcrg2 = wxrcrg2;
            BSIM4wcgsl = wcgsl;
            BSIM4wcgdl = wcgdl;
            BSIM4wckappas = wckappas;
            BSIM4wckappad = wckappad;
            BSIM4wcf = wcf;
            BSIM4wclc = wclc;
            BSIM4wcle = wcle;
            BSIM4wvfbcv = wvfbcv;
            BSIM4wnoff = wnoff;
            BSIM4wvoffcv = wvoffcv;
            BSIM4wacde = wacde;
            BSIM4wmoin = wmoin;
            BSIM4pcdsc = pcdsc;
            BSIM4pcdscb = pcdscb;
            BSIM4pcdscd = pcdscd;
            BSIM4pcit = pcit;
            BSIM4pnfactor = pnfactor;
            BSIM4pxj = pxj;
            BSIM4pvsat = pvsat;
            BSIM4pat = pat;
            BSIM4pa0 = pa0;
            BSIM4pags = pags;
            BSIM4pa1 = pa1;
            BSIM4pa2 = pa2;
            BSIM4pketa = pketa;
            BSIM4pnsub = pnsub;
            BSIM4pndep = pndep;
            BSIM4pnsd = pnsd;
            BSIM4pphin = pphin;
            BSIM4pngate = pngate;
            BSIM4pgamma1 = pgamma1;
            BSIM4pgamma2 = pgamma2;
            BSIM4pvbx = pvbx;
            BSIM4pvbm = pvbm;
            BSIM4pxt = pxt;
            BSIM4pk1 = pk1;
            BSIM4pkt1 = pkt1;
            BSIM4pkt1l = pkt1l;
            BSIM4pkt2 = pkt2;
            BSIM4pk2 = pk2;
            BSIM4pk3 = pk3;
            BSIM4pk3b = pk3b;
            BSIM4pw0 = pw0;
            BSIM4pdvtp0 = pdvtp0;
            BSIM4pdvtp1 = pdvtp1;
            BSIM4plpe0 = plpe0;
            BSIM4plpeb = plpeb;
            BSIM4pdvt0 = pdvt0;
            BSIM4pdvt1 = pdvt1;
            BSIM4pdvt2 = pdvt2;
            BSIM4pdvt0w = pdvt0w;
            BSIM4pdvt1w = pdvt1w;
            BSIM4pdvt2w = pdvt2w;
            BSIM4pdrout = pdrout;
            BSIM4pdsub = pdsub;
            BSIM4pvth0 = pvth0;
            BSIM4pua = pua;
            BSIM4pua1 = pua1;
            BSIM4pub = pub;
            BSIM4pub1 = pub1;
            BSIM4puc = puc;
            BSIM4puc1 = puc1;
            BSIM4pu0 = pu0;
            BSIM4peu = peu;
            BSIM4pute = pute;
            BSIM4pvoff = pvoff;
            BSIM4pminv = pminv;
            BSIM4pdelta = pdelta;
            BSIM4prdsw = prdsw;
            BSIM4prsw = prsw;
            BSIM4prdw = prdw;
            BSIM4pprwg = pprwg;
            BSIM4pprwb = pprwb;
            BSIM4pprt = pprt;
            BSIM4peta0 = peta0;
            BSIM4petab = petab;
            BSIM4ppclm = ppclm;
            BSIM4pfprout = pfprout;
            BSIM4ppdits = ppdits;
            BSIM4ppditsd = ppditsd;
            BSIM4ppscbe1 = ppscbe1;
            BSIM4ppscbe2 = ppscbe2;
            BSIM4ppvag = ppvag;
            BSIM4pwr = pwr;
            BSIM4pdwg = pdwg;
            BSIM4pdwb = pdwb;
            BSIM4pb0 = pb0;
            BSIM4pb1 = pb1;
            BSIM4palpha0 = palpha0;
            BSIM4palpha1 = palpha1;
            BSIM4pbeta0 = pbeta0;
            BSIM4pvfb = pvfb;
            BSIM4pagidl = pagidl;
            BSIM4pbgidl = pbgidl;
            BSIM4pcgidl = pcgidl;
            BSIM4pegidl = pegidl;
            BSIM4paigc = paigc;
            BSIM4pbigc = pbigc;
            BSIM4pcigc = pcigc;
            BSIM4paigsd = paigsd;
            BSIM4pbigsd = pbigsd;
            BSIM4pcigsd = pcigsd;
            BSIM4paigbacc = paigbacc;
            BSIM4pbigbacc = pbigbacc;
            BSIM4pcigbacc = pcigbacc;
            BSIM4paigbinv = paigbinv;
            BSIM4pbigbinv = pbigbinv;
            BSIM4pcigbinv = pcigbinv;
            BSIM4pnigc = pnigc;
            BSIM4pnigbacc = pnigbacc;
            BSIM4pnigbinv = pnigbinv;
            BSIM4pntox = pntox;
            BSIM4peigbinv = peigbinv;
            BSIM4ppigcd = ppigcd;
            BSIM4ppoxedge = ppoxedge;
            BSIM4pxrcrg1 = pxrcrg1;
            BSIM4pxrcrg2 = pxrcrg2;
            BSIM4pcgsl = pcgsl;
            BSIM4pcgdl = pcgdl;
            BSIM4pckappas = pckappas;
            BSIM4pckappad = pckappad;
            BSIM4pcf = pcf;
            BSIM4pclc = pclc;
            BSIM4pcle = pcle;
            BSIM4pvfbcv = pvfbcv;
            BSIM4pnoff = pnoff;
            BSIM4pvoffcv = pvoffcv;
            BSIM4pacde = pacde;
            BSIM4pmoin = pmoin;
            BSIM4tnom = tnom;
            BSIM4cgso = cgso;
            BSIM4cgdo = cgdo;
            BSIM4cgbo = cgbo;
            BSIM4xpart = xpart;
            BSIM4sheetResistance = rsh;
            BSIM4SjctSatCurDensity = jss;
            BSIM4DjctSatCurDensity = jsd;
            BSIM4SjctSidewallSatCurDensity = jsws;
            BSIM4DjctSidewallSatCurDensity = jswd;
            BSIM4SjctGateSidewallSatCurDensity = jswgs;
            BSIM4DjctGateSidewallSatCurDensity = jswgd;
            BSIM4SbulkJctPotential = pbs;
            BSIM4DbulkJctPotential = pbd;
            BSIM4SbulkJctBotGradingCoeff = mjs;
            BSIM4DbulkJctBotGradingCoeff = mjd;
            BSIM4SbulkJctSideGradingCoeff = mjsws;
            BSIM4DbulkJctSideGradingCoeff = mjswd;
            BSIM4SbulkJctGateSideGradingCoeff = mjswgs;
            BSIM4DbulkJctGateSideGradingCoeff = mjswgd;
            BSIM4SsidewallJctPotential = pbsws;
            BSIM4DsidewallJctPotential = pbswd;
            BSIM4SGatesidewallJctPotential = pbswgs;
            BSIM4DGatesidewallJctPotential = pbswgd;
            BSIM4SunitAreaJctCap = cjs;
            BSIM4DunitAreaJctCap = cjd;
            BSIM4SunitLengthSidewallJctCap = cjsws;
            BSIM4DunitLengthSidewallJctCap = cjswd;
            BSIM4SunitLengthGateSidewallJctCap = cjswgs;
            BSIM4DunitLengthGateSidewallJctCap = cjswgd;
            BSIM4SjctEmissionCoeff = njs;
            BSIM4DjctEmissionCoeff = njd;
            BSIM4SjctTempExponent = xtis;
            BSIM4DjctTempExponent = xtid;
            BSIM4Lint = lint;
            BSIM4Ll = ll;
            BSIM4Llc = llc;
            BSIM4Lln = lln;
            BSIM4Lw = lw;
            BSIM4Lwc = lwc;
            BSIM4Lwn = lwn;
            BSIM4Lwl = lwl;
            BSIM4Lwlc = lwlc;
            BSIM4Lmin = lmin;
            BSIM4Lmax = lmax;
            BSIM4Wint = wint;
            BSIM4Wl = wl;
            BSIM4Wlc = wlc;
            BSIM4Wln = wln;
            BSIM4Ww = ww;
            BSIM4Wwc = wwc;
            BSIM4Wwn = wwn;
            BSIM4Wwl = wwl;
            BSIM4Wwlc = wwlc;
            BSIM4Wmin = wmin;
            BSIM4Wmax = wmax;

            // BSIM4.3
            BSIM4lambda = lambda;
            BSIM4llambda = llambda;
            BSIM4wlambda = wlambda;
            BSIM4plambda = plambda;
            BSIM4vtl = vtl;
            BSIM4lvtl = lvtl;
            BSIM4wvtl = wvtl;
            BSIM4pvtl = pvtl;
            BSIM4xn = xn;
            BSIM4lxn = lxn;
            BSIM4wxn = wxn;
            BSIM4pxn = pxn;

            BSIM4sa = sa;
            BSIM4sb = sb;
            BSIM4sd = sd;
            BSIM4saref = saref;
            BSIM4sbref = sbref;
            BSIM4wlod = wlod;
            BSIM4ku0 = ku0;
            BSIM4kvsat = kvsat;
            BSIM4tku0 = tku0;
            BSIM4lku0 = lku0;
            BSIM4wku0 = wku0;
            BSIM4pku0 = pku0;
            BSIM4kvth0 = kvth0;
            BSIM4wlodku0 = wlodku0;
            BSIM4lkvth0 = lkvth0;
            BSIM4wkvth0 = wkvth0;
            BSIM4pkvth0 = pkvth0;
            BSIM4llodvth = llodvth;
            BSIM4wlodvth = wlodvth;
            BSIM4stk2 = stk2;
            BSIM4lodk2 = lodk2;
            BSIM4steta0 = steta0;
            BSIM4lodeta0 = lodeta0;

            //New model version > 4.3
            BSIM4sc = sc;
            BSIM4tvoffcv = tvoffcv;
            BSIM4wtvoffcv = wtvoffcv;
            BSIM4ltvoffcv = ltvoffcv;
            BSIM4ptvoffcv = ptvoffcv;
            BSIM4teta0 = teta0;
            BSIM4wteta0 = wteta0;
            BSIM4lteta0 = lteta0;
            BSIM4pteta0 = pteta0;

            BSIM4rbpdl = rbpdl;
            BSIM4rbpdnf = rbpdnf;
            BSIM4voffcvl = voffcvl;

            BSIM4tnfactor = tnfactor;
            BSIM4wtnfactor = wtnfactor;
            BSIM4ltnfactor = ltnfactor;
            BSIM4ptnfactor = ptnfactor;
            BSIM4minvcv = minvcv;
            BSIM4wminvcv = wminvcv;
            BSIM4lminvcv = lminvcv;
            BSIM4pminvcv = pminvcv;
            BSIM4tvfbsdoff = tvfbsdoff;
            BSIM4wtvfbsdoff = wtvfbsdoff;
            BSIM4ltvfbsdoff = ltvfbsdoff;
            BSIM4ptvfbsdoff = ptvfbsdoff;

            BSIM4gidlMod = gidlmod;
            BSIM4aigs = aigs;
            BSIM4waigs = waigs;
            BSIM4laigs = laigs;
            BSIM4paigs = paigs;
            BSIM4bigs = bigs;
            BSIM4wbigs = wbigs;
            BSIM4lbigs = lbigs;
            BSIM4pbigs = pbigs;
            BSIM4cigs = cigs;
            BSIM4wcigs = wcigs;
            BSIM4lcigs = lcigs;
            BSIM4pcigs = pcigs;
            BSIM4aigd = aigd;
            BSIM4waigd = waigd;
            BSIM4laigd = laigd;
            BSIM4paigd = paigd;
            BSIM4bigd = bigd;
            BSIM4wbigd = wbigd;
            BSIM4lbigd = lbigd;
            BSIM4pbigd = pbigd;
            BSIM4cigd = cigd;
            BSIM4wcigd = wcigd;
            BSIM4lcigd = lcigd;
            BSIM4pcigd = pcigd;
            BSIM4delvto = delvto;
            BSIM4ados = ados;
            BSIM4bdos = bdos;
            BSIM4agisl = agisl;
            BSIM4wagisl = wagisl;
            BSIM4lagisl = lagisl;
            BSIM4pagisl = pagisl;
            BSIM4bgisl = bgisl;
            BSIM4wbgisl = wbgisl;
            BSIM4lbgisl = lbgisl;
            BSIM4pbgisl = pbgisl;
            BSIM4cgisl = cgisl;
            BSIM4wcgisl = wcgisl;
            BSIM4lcgisl = lcgisl;
            BSIM4pcgisl = pcgisl;
            BSIM4egisl = egisl;
            BSIM4wegisl = wegisl;
            BSIM4legisl = legisl;
            BSIM4pegisl = pegisl;
            BSIM4rgisl = rgisl;
            BSIM4wrgisl = wrgisl;
            BSIM4lrgisl = lrgisl;
            BSIM4prgisl = prgisl;
            BSIM4kgisl = kgisl;
            BSIM4wkgisl = wkgisl;
            BSIM4lkgisl = lkgisl;
            BSIM4pkgisl = pkgisl;
            BSIM4fgisl = fgisl;
            BSIM4wfgisl = wfgisl;
            BSIM4lfgisl = lfgisl;
            BSIM4pfgisl = pfgisl;
            BSIM4rgidl = rgidl;
            BSIM4wrgidl = wrgidl;
            BSIM4lrgidl = lrgidl;
            BSIM4prgidl = prgidl;
            BSIM4kgidl = kgidl;
            BSIM4wkgidl = wkgidl;
            BSIM4lkgidl = lkgidl;
            BSIM4pkgidl = pkgidl;
            BSIM4fgidl = fgidl;
            BSIM4wfgidl = wfgidl;
            BSIM4lfgidl = lfgidl;
            BSIM4pfgidl = pfgidl;

            BSIM4dvtp2 = dvtp2;
            BSIM4wdvtp2 = wdvtp2;
            BSIM4ldvtp2 = ldvtp2;
            BSIM4pdvtp2 = pdvtp2;
            BSIM4dvtp3 = dvtp3;
            BSIM4wdvtp3 = wdvtp3;
            BSIM4ldvtp3 = ldvtp3;
            BSIM4pdvtp3 = pdvtp3;
            BSIM4dvtp4 = dvtp4;
            BSIM4wdvtp4 = wdvtp4;
            BSIM4ldvtp4 = ldvtp4;
            BSIM4pdvtp4 = pdvtp4;
            BSIM4dvtp5 = dvtp5;
            BSIM4wdvtp5 = wdvtp5;
            BSIM4ldvtp5 = ldvtp5;
            BSIM4pdvtp5 = pdvtp5;

            BSIM4ni0sub = ni0sub;
            BSIM4bg0sub = bg0sub;
            BSIM4tbgasub = tbgasub;
            BSIM4tbgbsub = tbgbsub;
            BSIM4tempeot = tempeot;
            BSIM4leffeot = leffeot;
            BSIM4weffeot = weffeot;
            BSIM4vddeot = vddeot;
            BSIM4eot = eot;
            BSIM4epsrgate = epsrgate;
            BSIM4epsrsub = epsrsub;
            BSIM4phig = phig;
            BSIM4easub = easub;
            BSIM4mtrlcompatmod = mtrlcompatmod;
            BSIM4mtrlmod = mtrlmod;
            BSIM4cvchargeMod = cvchargemod;

            BSIM4ud = ud;
            BSIM4wud = wud;
            BSIM4lud = lud;
            BSIM4pud = pud;
            BSIM4ud1 = ud1;
            BSIM4wud1 = wud1;
            BSIM4lud1 = lud1;
            BSIM4pud1 = pud1;
            BSIM4up = up;
            BSIM4wup = wup;
            BSIM4lup = lup;
            BSIM4pup = pup;
            BSIM4lp = lp;
            BSIM4wlp = wlp;
            BSIM4llp = llp;
            BSIM4plp = plp;
            BSIM4ucs = ucs;
            BSIM4wucs = wucs;
            BSIM4lucs = lucs;
            BSIM4pucs = pucs;
            BSIM4ucste = ucste;
            BSIM4wucste = wucste;
            BSIM4lucste = lucste;
            BSIM4pucste = pucste;
            BSIM4kvth0we = kvth0we;
            BSIM4wkvth0we = wkvth0we;
            BSIM4lkvth0we = lkvth0we;
            BSIM4pkvth0we = pkvth0we;
            BSIM4k2we = k2we;
            BSIM4wk2we = wk2we;
            BSIM4lk2we = lk2we;
            BSIM4pk2we = pk2we;
            BSIM4ku0we = ku0we;
            BSIM4wku0we = wku0we;
            BSIM4lku0we = lku0we;
            BSIM4pku0we = pku0we;
            BSIM4vfbsdoff = vfbsdoff;
            BSIM4wvfbsdoff = wvfbsdoff;
            BSIM4lvfbsdoff = lvfbsdoff;
            BSIM4pvfbsdoff = pvfbsdoff;
            BSIM4tvoff = tvoff;
            BSIM4wtvoff = wtvoff;
            BSIM4ltvoff = ltvoff;
            BSIM4ptvoff = ptvoff;
            BSIM4wpemod = wpemod;
            BSIM4sca = sca;
            BSIM4scb = scb;
            BSIM4scc = scc;
            BSIM4web = web;
            BSIM4wec = wec;
            BSIM4scref = scref;
            BSIM4rbps0 = rbps0;
            BSIM4rbpsl = rbpsl;
            BSIM4rbpsw = rbpsw;
            BSIM4rbpsnf = rbpsnf;
            BSIM4rbpd0 = rbpd0;
            BSIM4rbpdw = rbpdw;
            BSIM4rbpbx0 = rbpbx0;
            BSIM4rbpbxl = rbpbxl;
            BSIM4rbpbxw = rbpbxw;
            BSIM4rbpbxnf = rbpbxnf;
            BSIM4rbpby0 = rbpby0;
            BSIM4rbpbyl = rbpbyl;
            BSIM4rbpbyw = rbpbyw;
            BSIM4rbpbynf = rbpbynf;
            BSIM4rbsbx0 = rbsbx0;
            BSIM4rbsby0 = rbsby0;
            BSIM4rbdbx0 = rbdbx0;
            BSIM4rbdby0 = rbdby0;
            BSIM4rbsdbxl = rbsdbxl;
            BSIM4rbsdbxw = rbsdbxw;
            BSIM4rbsdbxnf = rbsdbxnf;
            BSIM4rbsdbyl = rbsdbyl;
            BSIM4rbsdbyw = rbsdbyw;
            BSIM4rbsdbynf = rbsdbynf;
            BSIM4jtss = jtss;
            BSIM4jtssws = jtssws;
            BSIM4jtsswgs = jtsswgs;
            BSIM4jtweff = jtweff;
            BSIM4njts = njts;
            BSIM4njtssw = njtssw;
            BSIM4njtsswg = njtsswg;
            BSIM4xtss = xtss;
            BSIM4xtssws = xtssws;
            BSIM4xtsswgs = xtsswgs;
            BSIM4vtss = vtss;
            BSIM4vtssws = vtssws;
            BSIM4vtsswgs = vtsswgs;
            BSIM4tnjts = tnjts;
            BSIM4tnjtssw = tnjtssw;
            BSIM4tnjtsswg = tnjtsswg;
            BSIM4jtsd = jtsd;
            BSIM4jtsswd = jtsswd;
            BSIM4jtsswgd = jtsswgd;
            BSIM4njtsd = njtsd;
            BSIM4njtsswd = njtsswd;
            BSIM4njtsswgd = njtsswgd;
            BSIM4xtsd = xtsd;
            BSIM4xtsswd = xtsswd;
            BSIM4xtsswgd = xtsswgd;
            BSIM4vtsd = vtsd;
            BSIM4vtsswd = vtsswd;
            BSIM4vtsswgd = vtsswgd;
            BSIM4tnjtsd = tnjtsd;
            BSIM4tnjtsswd = tnjtsswd;
            BSIM4tnjtsswgd = tnjtsswgd;
            BSIM4VgsteffVth = 0.0;

            /* process defaults of model parameters */
            if (!$param_given(type))
                BSIM4type = `NMOS;

            if ((BSIM4mobMod != 0) && (BSIM4mobMod != 1)
                && (BSIM4mobMod != 2) && (BSIM4mobMod != 3) && (BSIM4mobMod != 4)
                && (BSIM4mobMod != 5) && (BSIM4mobMod != 6) ) begin
                BSIM4mobMod = 0;
                $strobe("Warning: (instance X*) mobMod has been set to its default value: 0.\n");
            end

            if ((BSIM4dioMod != 0) && (BSIM4dioMod != 1)
                && (BSIM4dioMod != 2)) begin
                BSIM4dioMod = 1;
                $strobe("Warning: (instance X*) dioMod has been set to its default value: 1.\n");
            end

            if ((BSIM4capMod != 0) && (BSIM4capMod != 1)
                && (BSIM4capMod != 2)) begin
                BSIM4capMod = 2;
                $strobe("Warning: (instance X*) capMod has been set to its default value: 2.\n");
            end

            if ((BSIM4rdsMod != 0) && (BSIM4rdsMod != 1)) begin
                BSIM4rdsMod = 0;
                $strobe("Warning: (instance X*) rdsMod has been set to its default value: 0.\n");
            end
            if ((BSIM4rbodyMod != 0) && (BSIM4rbodyMod != 1) && (BSIM4rbodyMod != 2)) begin
                BSIM4rbodyMod = 0;
                $strobe("Warning: (instance X*) rbodyMod has been set to its default value: 0.\n");
            end

            if ((BSIM4rgateMod != 0) && (BSIM4rgateMod != 1)
                && (BSIM4rgateMod != 2) && (BSIM4rgateMod != 3)) begin
                BSIM4rgateMod = 0;
                $strobe("Warning: (instance X*) rgateMod has been set to its default value: 0.\n");
            end

            if ((BSIM4perMod != 0) && (BSIM4perMod != 1)) begin
                BSIM4perMod = 1;
                $strobe("Warning: (instance X*) perMod has been set to its default value: 1.\n");
            end

            if ((BSIM4fnoiMod != 0) && (BSIM4fnoiMod != 1)) begin
                BSIM4fnoiMod = 1;
                $strobe("Warning: (instance X*) fnoiMod has been set to its default value: 1.\n");
            end
            if ((BSIM4tnoiMod != 0) && (BSIM4tnoiMod != 1)) begin
                BSIM4tnoiMod = 0;
                $strobe("Warning: (instance X*) tnoiMod has been set to its default value: 0.\n");
            end

            if ((BSIM4trnqsMod != 0) && (BSIM4trnqsMod != 1)) begin
                BSIM4trnqsMod = 0;
                $strobe("Warning: (instance X*) trnqsMod has been set to its default value: 0.\n");
            end
            if ((BSIM4acnqsMod != 0) && (BSIM4acnqsMod != 1)) begin
                BSIM4acnqsMod = 0;
                $strobe("Warning: (instance X*) acnqsMod has been set to its default value: 0.\n");
            end

            if ((BSIM4igcMod != 0) && (BSIM4igcMod != 1) && (BSIM4igcMod != 2)) begin
                BSIM4igcMod = 0;
                $strobe("Warning: (instance X*) igcMod has been set to its default value: 0.\n");
            end
            if ((BSIM4igbMod != 0) && (BSIM4igbMod != 1)) begin
                BSIM4igbMod = 0;
                $strobe("Warning: (instance X*) igbMod has been set to its default value: 0.\n");
            end

            if (!$param_given(dsub))
                BSIM4dsub = BSIM4drout;
            if (!$param_given(vth0))
                BSIM4vth0 = (BSIM4type == `NMOS) ? 0.7 : -0.7;

            if (!$param_given(toxp))
                BSIM4toxp = BSIM4toxe;
            if (!$param_given(toxm))
                BSIM4toxm = BSIM4toxe;

            if (!$param_given(vddeot))
                BSIM4vddeot = (BSIM4type == `NMOS) ? 1.5 : -1.5;
            if (!$param_given(eu))
                BSIM4eu = (BSIM4type == `NMOS) ? 1.67 : 1.0;
            if (!$param_given(ua))
                BSIM4ua = (BSIM4mobMod == 2) ? 1.0e-15 : 1.0e-9; /* unit m/V */
            if (!$param_given(uc))
                BSIM4uc = (BSIM4mobMod == 1) ? -0.0465 : -0.0465e-9;
            if (!$param_given(uc1))
                BSIM4uc1 = (BSIM4mobMod == 1) ? -0.056 : -0.056e-9;
            if (!$param_given(u0))
                BSIM4u0 = (BSIM4type == `NMOS) ? 0.067 : 0.025;

            if (!$param_given(aigc))
                BSIM4aigc = (BSIM4type == `NMOS) ? 1.36e-2 : 9.80e-3;
            if (!$param_given(bigc))
                BSIM4bigc = (BSIM4type == `NMOS) ? 1.71e-3 : 7.59e-4;
            if (!$param_given(cigc))
                BSIM4cigc = (BSIM4type == `NMOS) ? 0.075 : 0.03;
            if ($param_given(aigsd)) begin
                BSIM4aigs = BSIM4aigsd;
                BSIM4aigd = BSIM4aigsd;
            end
            else begin
                BSIM4aigsd = (BSIM4type == `NMOS) ? 1.36e-2 : 9.80e-3;
                if (!$param_given(aigs))
                    BSIM4aigs = (BSIM4type == `NMOS) ? 1.36e-2 : 9.80e-3;
                if (!$param_given(aigd))
                    BSIM4aigd = (BSIM4type == `NMOS) ? 1.36e-2 : 9.80e-3;
            end
            if ($param_given(bigsd)) begin
                BSIM4bigs = BSIM4bigsd;
                BSIM4bigd = BSIM4bigsd;
            end
            else begin
                BSIM4bigsd = (BSIM4type == `NMOS) ? 1.71e-3 : 7.59e-4;
                if (!$param_given(bigs))
                    BSIM4bigs = (BSIM4type == `NMOS) ? 1.71e-3 : 7.59e-4;
                if (!$param_given(bigd))
                    BSIM4bigd = (BSIM4type == `NMOS) ? 1.71e-3 : 7.59e-4;
            end
            if ($param_given(cigsd)) begin
                BSIM4cigs =BSIM4cigsd;
                BSIM4cigd = BSIM4cigsd;
            end
            else begin
                BSIM4cigsd = (BSIM4type == `NMOS) ? 0.075 : 0.03;
                if (!$param_given(cigs))
                    BSIM4cigs = (BSIM4type == `NMOS) ? 0.075 : 0.03;
                if (!$param_given(cigd))
                    BSIM4cigd = (BSIM4type == `NMOS) ? 0.075 : 0.03;
            end

            if (!$param_given(ijthdfwd))
                BSIM4ijthdfwd = BSIM4ijthsfwd;
            if (!$param_given(ijthdrev))
                BSIM4ijthdrev = BSIM4ijthsrev;
            if (!$param_given(xjbvd))
                BSIM4xjbvd = BSIM4xjbvs;
            if (!$param_given(bvd))
                BSIM4bvd = BSIM4bvs;
            if (!$param_given(ckappad))
                BSIM4ckappad = BSIM4ckappas;
            if (!$param_given(dmci))
                BSIM4dmci = BSIM4dmcg;

            if (!$param_given(wlpeb))
                BSIM4wlpeb = BSIM4wlpe0;
            if (!$param_given(plpeb))
                BSIM4plpeb = BSIM4plpe0;

            /* NOTE: Verilog-A does not support access to the modelcard
             * default Tnom value */
            if (!$param_given(tnom))
                BSIM4tnom = `DEFAULT_TNOM + `P_CELSIUS0;
            else  // Shift from C to K:
                BSIM4tnom = BSIM4tnom + `P_CELSIUS0;

            if (!$param_given(llc))
                BSIM4Llc = BSIM4Ll;
            if (!$param_given(lwc))
                BSIM4Lwc = BSIM4Lw;
            if (!$param_given(lwlc))
                BSIM4Lwlc = BSIM4Lwl;
            if (!$param_given(wlc))
                BSIM4Wlc = BSIM4Wl;
            if (!$param_given(wwc))
                BSIM4Wwc = BSIM4Ww;
            if (!$param_given(wwlc))
                BSIM4Wwlc = BSIM4Wwl;
            if (!$param_given(dwc))
                BSIM4dwc = BSIM4Wint;
            if (!$param_given(dlc))
                BSIM4dlc = BSIM4Lint;
            if (!$param_given(dlcig))
                BSIM4dlcig = BSIM4Lint;
            if (!$param_given(dlcigd))
                BSIM4dlcigd = BSIM4Lint;
            if (!$param_given(dwj))
                BSIM4dwj = BSIM4dwc;



            if (!$param_given(cf))
                BSIM4cf = 2.0 * BSIM4epsrox * `P_EPS0 / `M_PI
               * ln(1.0 + 0.4e-6 / BSIM4toxe);

            if (!$param_given(cjd))
                BSIM4DunitAreaJctCap = BSIM4SunitAreaJctCap;
            if (!$param_given(cjswd))
                BSIM4DunitLengthSidewallJctCap = BSIM4SunitLengthSidewallJctCap;
            if (!$param_given(cjswgs))
                BSIM4SunitLengthGateSidewallJctCap = BSIM4SunitLengthSidewallJctCap;
            if (!$param_given(cjswgd))
                BSIM4DunitLengthGateSidewallJctCap = BSIM4SunitLengthGateSidewallJctCap;
            if (!$param_given(jsd))
                BSIM4DjctSatCurDensity = BSIM4SjctSatCurDensity;
            if (!$param_given(jswd))
                BSIM4DjctSidewallSatCurDensity = BSIM4SjctSidewallSatCurDensity;
            if (!$param_given(jswgd))
                BSIM4DjctGateSidewallSatCurDensity = BSIM4SjctGateSidewallSatCurDensity;
            if (!$param_given(pbd))
                BSIM4DbulkJctPotential = BSIM4SbulkJctPotential;
            if (!$param_given(pbswd))
                BSIM4DsidewallJctPotential = BSIM4SsidewallJctPotential;
            if (!$param_given(pbswgs))
                BSIM4SGatesidewallJctPotential = BSIM4SsidewallJctPotential;
            if (!$param_given(pbswgd))
                BSIM4DGatesidewallJctPotential = BSIM4SGatesidewallJctPotential;
            if (!$param_given(mjd))
                BSIM4DbulkJctBotGradingCoeff = BSIM4SbulkJctBotGradingCoeff;
            if (!$param_given(mjswd))
                BSIM4DbulkJctSideGradingCoeff = BSIM4SbulkJctSideGradingCoeff;
            if (!$param_given(mjswgs))
                BSIM4SbulkJctGateSideGradingCoeff = BSIM4SbulkJctSideGradingCoeff;
            if (!$param_given(mjswgd))
                BSIM4DbulkJctGateSideGradingCoeff = BSIM4SbulkJctGateSideGradingCoeff;
            if (!$param_given(njd))
                BSIM4DjctEmissionCoeff = BSIM4SjctEmissionCoeff;
            if (!$param_given(xtid))
                BSIM4DjctTempExponent = BSIM4SjctTempExponent;

            if (!$param_given(noia)) begin
                if (BSIM4type == `NMOS)
                    BSIM4oxideTrapDensityA = 6.25e41;
                else
                    BSIM4oxideTrapDensityA= 6.188e40;
            end
            if (!$param_given(noib)) begin
                if (BSIM4type == `NMOS)
                    BSIM4oxideTrapDensityB = 3.125e26;
                else
                    BSIM4oxideTrapDensityB = 1.5e25;
            end

            DMCGeff = BSIM4dmcg - BSIM4dmcgt;
            DMCIeff = BSIM4dmci;
            DMDGeff = BSIM4dmdg - BSIM4dmcgt;

            if (!$param_given(sd))
                BSIM4sd = 2 * BSIM4dmcg;

            if (!$param_given(aigsd) && ($param_given(aigs) || $param_given(aigd))) begin
                if (!$param_given(laigs))
                    BSIM4laigs = 0.0;
                if (!$param_given(laigd))
                    BSIM4laigd = 0.0;
            end
            else begin
                if (!$param_given(laigsd))
                    BSIM4laigsd = 0.0;
                BSIM4laigs = BSIM4laigsd;
                BSIM4laigd = BSIM4laigsd;
            end

            if (!$param_given(aigsd) && ($param_given(aigs) || $param_given(aigd))) begin
                if (!$param_given(waigs))
                    BSIM4waigs = 0.0;
                if (!$param_given(waigd))
                    BSIM4waigd = 0.0;
            end
            else begin
                if (!$param_given(waigsd))
                    BSIM4waigsd = 0.0;
                BSIM4waigs = BSIM4waigsd;
                BSIM4waigd = BSIM4waigsd;
            end
            if (!$param_given(bigsd) && ($param_given(bigs) || $param_given(bigd))) begin
                if (!$param_given(wbigs))
                    BSIM4wbigs = 0.0;
                if (!$param_given(wbigd))
                    BSIM4wbigd = 0.0;
            end
            else begin
                if (!$param_given(wbigsd))
                    BSIM4wbigsd = 0.0;
                BSIM4wbigs = BSIM4wbigsd;
                BSIM4wbigd = BSIM4wbigsd;
            end
            if (!$param_given(cigsd) && ($param_given(cigs) || $param_given(cigd))) begin
                if (!$param_given(wcigs))
                    BSIM4wcigs = 0.0;
                if (!$param_given(wcigd))
                    BSIM4wcigd = 0.0;
            end
            else begin
                if (!$param_given(wcigsd))
                    BSIM4wcigsd = 0.0;
                BSIM4wcigs = BSIM4wcigsd;
                BSIM4wcigd = BSIM4wcigsd;
            end

            if (!$param_given(bigsd) && ($param_given(bigs) || $param_given(bigd))) begin
                if (!$param_given(lbigs))
                    BSIM4lbigs = 0.0;
                if (!$param_given(lbigd))
                    BSIM4lbigd = 0.0;
            end
            else begin
                if (!$param_given(lbigsd))
                    BSIM4lbigsd = 0.0;
                BSIM4lbigs = BSIM4lbigsd;
                BSIM4lbigd = BSIM4lbigsd;
            end

            if (!$param_given(cigsd) && ($param_given(cigs) || $param_given(cigd))) begin
                if (!$param_given(lcigs))
                    BSIM4lcigs = 0.0;
                if (!$param_given(lcigd))
                    BSIM4lcigd = 0.0;
            end
            else begin
                if (!$param_given(lcigsd))
                    BSIM4lcigsd = 0.0;
                BSIM4lcigs = BSIM4lcigsd;
                BSIM4lcigd = BSIM4lcigsd;
            end
            if (!$param_given(aigsd) && ($param_given(aigs) || $param_given(aigd))) begin
                if (!$param_given(paigs))
                    BSIM4paigs = 0.0;
                if (!$param_given(paigd))
                    BSIM4paigd = 0.0;
            end
            else begin
                if (!$param_given(paigsd))
                    BSIM4paigsd = 0.0;
                BSIM4paigs = BSIM4paigsd;
                BSIM4paigd = BSIM4paigsd;
            end
            if (!$param_given(bigsd) && ($param_given(bigs) || $param_given(bigd))) begin
                if (!$param_given(pbigs))
                    BSIM4pbigs = 0.0;
                if (!$param_given(pbigd))
                    BSIM4pbigd = 0.0;
            end
            else begin
                if (!$param_given(pbigsd))
                    BSIM4pbigsd = 0.0;
                BSIM4pbigs = BSIM4pbigsd;
                BSIM4pbigd = BSIM4pbigsd;
            end
            if (!$param_given(cigsd) && ($param_given(cigs) || $param_given(cigd))) begin
                if (!$param_given(pcigs))
                    BSIM4pcigs = 0.0;
                if (!$param_given(pcigd))
                    BSIM4pcigd = 0.0;
            end
            else begin
                if (!$param_given(pcigsd))
                    BSIM4pcigsd = 0.0;
                BSIM4pcigs = BSIM4pcigsd;
                BSIM4pcigd = BSIM4pcigsd;
            end

            if (!$param_given(agisl))
                BSIM4agisl = BSIM4agidl;
            if (!$param_given(wagisl))
                BSIM4wagisl = BSIM4wagidl;
            if (!$param_given(lagisl))
                BSIM4lagisl = BSIM4lagidl;
            if (!$param_given(pagisl))
                BSIM4pagisl = BSIM4pagidl;
            if (!$param_given(bgisl))
                BSIM4bgisl = BSIM4bgidl;
            if (!$param_given(wbgisl))
                BSIM4wbgisl = BSIM4wbgidl;
            if (!$param_given(lbgisl))
                BSIM4lbgisl = BSIM4lbgidl;
            if (!$param_given(pbgisl))
                BSIM4pbgisl = BSIM4pbgidl;
            if (!$param_given(cgisl))
                BSIM4cgisl = BSIM4cgidl;
            if (!$param_given(wcgisl))
                BSIM4wcgisl = BSIM4wcgidl;
            if (!$param_given(lcgisl))
                BSIM4lcgisl = BSIM4lcgidl;
            if (!$param_given(pcgisl))
                BSIM4pcgisl = BSIM4pcgidl;
            if (!$param_given(egisl))
                BSIM4egisl = BSIM4egidl;
            if (!$param_given(wegisl))
                BSIM4wegisl = BSIM4wegidl;
            if (!$param_given(legisl))
                BSIM4legisl = BSIM4legidl;
            if (!$param_given(pegisl))
                BSIM4pegisl = BSIM4pegidl;
            if (!$param_given(rgisl))
                BSIM4rgisl = BSIM4rgidl;
            if (!$param_given(wrgisl))
                BSIM4wrgisl = BSIM4wrgidl;
            if (!$param_given(lrgisl))
                BSIM4lrgisl = BSIM4lrgidl;
            if (!$param_given(prgisl))
                BSIM4prgisl = BSIM4prgidl;
            if (!$param_given(kgisl))
                BSIM4kgisl = BSIM4kgidl;
            if (!$param_given(wkgisl))
                BSIM4wkgisl = BSIM4wkgidl;
            if (!$param_given(lkgisl))
                BSIM4lkgisl = BSIM4lkgidl;
            if (!$param_given(pkgisl))
                BSIM4pkgisl = BSIM4pkgidl;
            if (!$param_given(fgisl))
                BSIM4fgisl = BSIM4fgidl;
            if (!$param_given(wfgisl))
                BSIM4wfgisl = BSIM4wfgidl;
            if (!$param_given(lfgisl))
                BSIM4lfgisl = BSIM4lfgidl;
            if (!$param_given(pfgisl))
                BSIM4pfgisl = BSIM4pfgidl;

            if (!$param_given(vddeot))
                BSIM4vddeot = (BSIM4type == `NMOS) ? 1.5 : -1.5;

            if ((BSIM4mtrlmod != 0) && (BSIM4mtrlmod != 1)) begin
                BSIM4mtrlmod = 0;
                $strobe("Warning: mtrlMod has been set to its default value: 0.\n");
            end
            if ((BSIM4mtrlcompatmod != 0) && (BSIM4mtrlcompatmod != 1)) begin
                BSIM4mtrlcompatmod = 0;
                $strobe("Warning: mtrlCompatMod has been set to its default value: 0.\n");
            end
            if (!$param_given(ucs))
                BSIM4ucs = (BSIM4type == `NMOS) ? 1.67 : 1.0;
            if ((BSIM4wpemod != 0) && (BSIM4wpemod != 1)) begin
                BSIM4wpemod = 0;
                $strobe("Warning: wpemod has been set to its default value: 0.\n");
            end

            if (!$param_given(jtsd))
                BSIM4jtsd = BSIM4jtss;
            if (!$param_given(jtsswd))
                BSIM4jtsswd = BSIM4jtssws;
            if (!$param_given(jtsswgd))
                BSIM4jtsswgd = BSIM4jtsswgs;

            if (!$param_given(njtsd)) begin
                if ($param_given(njts))
                    BSIM4njtsd =  BSIM4njts;
                else
                    BSIM4njtsd = 20.0;
            end
            if (!$param_given(njtsswd)) begin
                if ($param_given(njtssw))
                    BSIM4njtsswd =  BSIM4njtssw;
                else
                    BSIM4njtsswd = 20.0;
            end
            if (!$param_given(njtsswgd)) begin
                if ($param_given(njtsswg))
                    BSIM4njtsswgd =  BSIM4njtsswg;
                else
                    BSIM4njtsswgd = 20.0;
            end
            if (!$param_given(xtsd))
                BSIM4xtsd = BSIM4xtss;
            if (!$param_given(xtsswd))
                BSIM4xtsswd = BSIM4xtssws;
            if (!$param_given(xtsswgd))
                BSIM4xtsswgd = BSIM4xtsswgs;
            if (!$param_given(vtsd))
                BSIM4vtsd = BSIM4vtss;
            if (!$param_given(vtsswd))
                BSIM4vtsswd = BSIM4vtssws;
            if (!$param_given(vtsswgd))
                BSIM4vtsswgd = BSIM4vtsswgs;
            if (!$param_given(tnjtsd)) begin
                if ($param_given(tnjts))
                    BSIM4tnjtsd =  BSIM4tnjts;
                else
                    BSIM4tnjtsd = 0.0;
            end
            if (!$param_given(tnjtsswd)) begin
                if ($param_given(tnjtssw))
                    BSIM4tnjtsswd =  BSIM4tnjtssw;
                else
                    BSIM4tnjtsswd = 0.0;
            end
            if (!$param_given(tnjtsswgd)) begin
                if ($param_given(tnjtsswg))
                    BSIM4tnjtsswgd =  BSIM4tnjtsswg;
                else
                    BSIM4tnjtsswgd = 0.0;
            end

            /* process drain series resistance - removed useless code*/
            //if (BSIM4sheetResistance > 0) begin
            //    if (!$param_given(drainSquares) && (BSIM4rgeoMod != 0))
            //      `BSIM4RdseffGeo(BSIM4nf, BSIM4geoMod, BSIM4rgeoMod, BSIM4min,
            //        BSIM4w, BSIM4sheetResistance, DMCGeff, DMCIeff, DMDGeff, 0, Rtot)
            //end

            ///* process source series resistance */
            //if (BSIM4sheetResistance > 0) begin
            //    if (!$param_given(sourceSquares) && (BSIM4rgeoMod != 0))
            //       `BSIM4RdseffGeo(BSIM4nf, BSIM4geoMod, BSIM4rgeoMod, BSIM4min,
            //         BSIM4w, BSIM4sheetResistance, DMCGeff, DMCIeff, DMDGeff, 1, Rtot)
            //end

            if (BSIM4SbulkJctPotential < 0.1) begin
                BSIM4SbulkJctPotential = 0.1;
                $strobe("Given pbs is less than 0.1. Pbs is set to 0.1.\n");
            end
            if (BSIM4SsidewallJctPotential < 0.1) begin
                BSIM4SsidewallJctPotential = 0.1;
                $strobe("Given pbsws is less than 0.1. Pbsws is set to 0.1.\n");
            end
            if (BSIM4SGatesidewallJctPotential < 0.1) begin
                BSIM4SGatesidewallJctPotential = 0.1;
                $strobe("Given pbswgs is less than 0.1. Pbswgs is set to 0.1.\n");
            end

            if (BSIM4DbulkJctPotential < 0.1) begin
                BSIM4DbulkJctPotential = 0.1;
                $strobe("Given pbd is less than 0.1. Pbd is set to 0.1.\n");
            end
            if (BSIM4DsidewallJctPotential < 0.1) begin
                BSIM4DsidewallJctPotential = 0.1;
                $strobe("Given pbswd is less than 0.1. Pbswd is set to 0.1.\n");
            end

            if (BSIM4DGatesidewallJctPotential < 0.1) begin
                BSIM4DGatesidewallJctPotential = 0.1;
                $strobe("Given pbswgd is less than 0.1. Pbswgd is set to 0.1.\n");
            end

            //New model version > 4.3
            if (BSIM4mtrlmod == 0) begin
                if (($param_given(toxe)) && ($param_given(toxp)) && ($param_given(dtox))
                    && (BSIM4toxe != (BSIM4toxp + BSIM4dtox))) begin
                    if (BSIM4toxe == 0.0)
                        $strobe("Warning: toxe, toxp and dtox all given and toxe != toxp + dtox; dtox ignored.");
                    else if (abs((BSIM4toxe - (BSIM4toxp + BSIM4dtox)) / BSIM4toxe) >= 1e-15)
                        $strobe("Warning: toxe, toxp and dtox all given and toxe != toxp + dtox; dtox ignored.");
                end
                else if (($param_given(toxe)) && (!$param_given(toxp)))
                    BSIM4toxp = BSIM4toxe - BSIM4dtox;
                else if ((!$param_given(toxe)) && ($param_given(toxp))) begin
                    BSIM4toxe = BSIM4toxp + BSIM4dtox;
                    if (!$param_given(toxm))            /* v4.7 */
                        BSIM4toxm = BSIM4toxe;
                end
            end
            else if (BSIM4mtrlcompatmod != 0) /* v4.7 */
            begin
                T0 = BSIM4epsrox / 3.9;
                if (($param_given(eot)) && ($param_given(toxp)) && ($param_given(dtox))
                    && (abs(BSIM4eot * T0 - (BSIM4toxp + BSIM4dtox)) > 1.0e-20))
                    $strobe("Warning: eot, toxp and dtox all given and eot * EPSROX / 3.9 != toxp + dtox; dtox ignored.\n");
                else if (($param_given(eot)) && (!$param_given(toxp)))
                    BSIM4toxp = T0 * BSIM4eot - BSIM4dtox;
                else if ((!$param_given(eot)) && ($param_given(toxp))) begin
                    BSIM4eot = (BSIM4toxp + BSIM4dtox) / T0;
                    if (!$param_given(toxm))
                        BSIM4toxm = BSIM4eot;
                end
            end

            if (BSIM4mtrlmod)
            begin
                epsroxl = 3.9;
                toxel = BSIM4eot;
                epssubl = `EPS0 * BSIM4epsrsub;
            end
            else
            begin
                epsroxl = BSIM4epsrox;
                toxel = BSIM4toxe;
                epssubl = `EPSSI;
            end

            BSIM4coxe = epsroxl * `EPS0 / toxel;
            if (BSIM4mtrlmod == 0 || BSIM4mtrlcompatmod != 0)
                BSIM4coxp = BSIM4epsrox * `EPS0 / BSIM4toxp;

            if (!$param_given(cgdo)) begin
                if ($param_given(dlc) && (BSIM4dlc > 0.0))
                    BSIM4cgdo = BSIM4dlc * BSIM4coxe - BSIM4cgdl;
                else
                    BSIM4cgdo = 0.6 * BSIM4xj * BSIM4coxe;
            end

            if (!$param_given(cgso)) begin
                if ($param_given(dlc) && (BSIM4dlc > 0.0))
                    BSIM4cgso = BSIM4dlc * BSIM4coxe - BSIM4cgsl;
                else
                    BSIM4cgso = 0.6 * BSIM4xj * BSIM4coxe;
            end

            if (!$param_given(cgbo))
                BSIM4cgbo = 2.0 * BSIM4dwc * BSIM4coxe;

            Tnom = BSIM4tnom;
            TRatio = T / Tnom;
            //remove dead code
            //BSIM4vcrit = CONSTvt0 * ln(CONSTvt0 / (CONSTroot2 * 1.0e-14));
            BSIM4factor1 = sqrt(epssubl / (epsroxl * `EPS0)* toxel);

            Vtm0 = `KboQ * Tnom;
            if (BSIM4mtrlmod==0) begin
                Eg0 = 1.16 - 7.02e-4 * Tnom * Tnom / (Tnom + 1108.0);
                ni = 1.45e10 * (Tnom / 300.15) * sqrt(Tnom / 300.15)
                  * exp(21.5565981 - Eg0 / (2.0 * Vtm0));
            end
            else begin
                Eg0 = BSIM4bg0sub - BSIM4tbgasub * Tnom * Tnom
                                         / (Tnom + BSIM4tbgbsub);
                T0 =  BSIM4bg0sub - BSIM4tbgasub * 90090.0225
                                         / (300.15 + BSIM4tbgbsub);
                ni = BSIM4ni0sub * (Tnom / 300.15) * sqrt(Tnom / 300.15)
                    * exp((T0 - Eg0) / (2.0 * Vtm0));
            end

            BSIM4Eg0 = Eg0;
            BSIM4vtm = `KboQ * T;
            if (BSIM4mtrlmod == 0)
                Eg = 1.16 - 7.02e-4 * T * T / (T + 1108.0);
            else
                Eg = BSIM4bg0sub - BSIM4tbgasub * T * T
                                      / (T + BSIM4tbgbsub);
            if (T != Tnom) begin
                T0 = Eg0 / Vtm0 - Eg / BSIM4vtm;
                T1 = ln(T / Tnom);
                T2 = T0 + BSIM4SjctTempExponent * T1;
                T3 = exp(T2 / BSIM4SjctEmissionCoeff);
                BSIM4SjctTempSatCurDensity = BSIM4SjctSatCurDensity * T3;
                BSIM4SjctSidewallTempSatCurDensity
                = BSIM4SjctSidewallSatCurDensity * T3;
                BSIM4SjctGateSidewallTempSatCurDensity
                = BSIM4SjctGateSidewallSatCurDensity * T3;

                T2 = T0 + BSIM4DjctTempExponent * T1;
                T3 = exp(T2 / BSIM4DjctEmissionCoeff);
                BSIM4DjctTempSatCurDensity = BSIM4DjctSatCurDensity * T3;
                BSIM4DjctSidewallTempSatCurDensity
                = BSIM4DjctSidewallSatCurDensity * T3;
                BSIM4DjctGateSidewallTempSatCurDensity
                = BSIM4DjctGateSidewallSatCurDensity * T3;
            end
            else begin
                BSIM4SjctTempSatCurDensity = BSIM4SjctSatCurDensity;
                BSIM4SjctSidewallTempSatCurDensity
                = BSIM4SjctSidewallSatCurDensity;
                BSIM4SjctGateSidewallTempSatCurDensity
                = BSIM4SjctGateSidewallSatCurDensity;
                BSIM4DjctTempSatCurDensity = BSIM4DjctSatCurDensity;
                BSIM4DjctSidewallTempSatCurDensity
                = BSIM4DjctSidewallSatCurDensity;
                BSIM4DjctGateSidewallTempSatCurDensity
                = BSIM4DjctGateSidewallSatCurDensity;
            end

            if (BSIM4SjctTempSatCurDensity < 0.0)
                BSIM4SjctTempSatCurDensity = 0.0;
            if (BSIM4SjctSidewallTempSatCurDensity < 0.0)
                BSIM4SjctSidewallTempSatCurDensity = 0.0;
            if (BSIM4SjctGateSidewallTempSatCurDensity < 0.0)
                BSIM4SjctGateSidewallTempSatCurDensity = 0.0;

            if (BSIM4DjctTempSatCurDensity < 0.0)
                BSIM4DjctTempSatCurDensity = 0.0;
            if (BSIM4DjctSidewallTempSatCurDensity < 0.0)
                BSIM4DjctSidewallTempSatCurDensity = 0.0;
            if (BSIM4DjctGateSidewallTempSatCurDensity < 0.0)
                BSIM4DjctGateSidewallTempSatCurDensity = 0.0;

            /* Temperature dependence of D/B and S/B diode capacitance begins */
            delTemp = T - Tnom; // - BSIM4tnom;

            T0 = BSIM4tcj * delTemp;
            if (T0 >= -1.0) begin
                BSIM4SunitAreaTempJctCap = BSIM4SunitAreaJctCap *(1.0 + T0);
                BSIM4DunitAreaTempJctCap = BSIM4DunitAreaJctCap *(1.0 + T0);
            end
            else begin
                if (BSIM4SunitAreaJctCap > 0.0) begin
                    BSIM4SunitAreaTempJctCap = 0.0;
                    $strobe("Temperature effect has caused cjs to be negative. \
                             Cjs is clamped to zero.\n");
                end
                if (BSIM4DunitAreaJctCap > 0.0) begin
                    BSIM4DunitAreaTempJctCap = 0.0;
                    $strobe("Temperature effect has caused cjd to be negative. \
                             Cjd is clamped to zero.\n");
                end
            end
            T0 = BSIM4tcjsw * delTemp;

            if (T0 >= -1.0) begin
                BSIM4SunitLengthSidewallTempJctCap = BSIM4SunitLengthSidewallJctCap
                                                      * (1.0 + T0);
                BSIM4DunitLengthSidewallTempJctCap = BSIM4DunitLengthSidewallJctCap
                                                      * (1.0 + T0);
            end
            else begin
                if (BSIM4SunitLengthSidewallJctCap > 0.0) begin
                    BSIM4SunitLengthSidewallTempJctCap = 0.0;
                    $strobe("Temperature effect has caused cjsws to be negative. \
                             Cjsws is clamped to zero.\n");
                end

                if (BSIM4DunitLengthSidewallJctCap > 0.0) begin
                    BSIM4DunitLengthSidewallTempJctCap = 0.0;
                    $strobe("Temperature effect has caused cjswd to be negative. \
                             Cjswd is clamped to zero.\n");
                end
            end

            T0 = BSIM4tcjswg * delTemp;
            if (T0 >= -1.0) begin
                BSIM4SunitLengthGateSidewallTempJctCap =
                    BSIM4SunitLengthGateSidewallJctCap *(1.0 + T0);
                BSIM4DunitLengthGateSidewallTempJctCap =
                    BSIM4DunitLengthGateSidewallJctCap *(1.0 + T0);
            end
            else begin
                if (BSIM4SunitLengthGateSidewallJctCap > 0.0) begin
                    BSIM4SunitLengthGateSidewallTempJctCap = 0.0;
                    $strobe("Temperature effect has caused cjswgs to be negative. \
                             Cjswgs is clamped to zero.\n");
                end
                if (BSIM4DunitLengthGateSidewallJctCap > 0.0) begin
                    BSIM4DunitLengthGateSidewallTempJctCap = 0.0;
                    $strobe("Temperature effect has caused cjswgd to be negative. \
                             Cjswgd is clamped to zero.\n");
                end
            end

            BSIM4PhiBS = BSIM4SbulkJctPotential - BSIM4tpb * delTemp;
            if (BSIM4PhiBS < 0.01) begin
                BSIM4PhiBS = 0.01;
                $strobe("Temperature effect has caused pbs to be less than 0.01. \
                         Pbs is clamped to 0.01.\n");
            end
            BSIM4PhiBD = BSIM4DbulkJctPotential - BSIM4tpb * delTemp;
            if (BSIM4PhiBD < 0.01) begin
                BSIM4PhiBD = 0.01;
                $strobe("Temperature effect has caused pbd to be less than 0.01. Pbd is clamped to 0.01.\n");
            end

            BSIM4PhiBSWS = BSIM4SsidewallJctPotential - BSIM4tpbsw * delTemp;
            if (BSIM4PhiBSWS <= 0.01) begin
                BSIM4PhiBSWS = 0.01;
                $strobe("Temperature effect has caused pbsws to be less than 0.01. Pbsws is clamped to 0.01.\n");
            end
            BSIM4PhiBSWD = BSIM4DsidewallJctPotential - BSIM4tpbsw * delTemp;
            if (BSIM4PhiBSWD <= 0.01) begin
                BSIM4PhiBSWD = 0.01;
                $strobe("Temperature effect has caused pbswd to be less than 0.01. Pbswd is clamped to 0.01.\n");
            end

            BSIM4PhiBSWGS = BSIM4SGatesidewallJctPotential - BSIM4tpbswg * delTemp;
            if (BSIM4PhiBSWGS <= 0.01) begin
                BSIM4PhiBSWGS = 0.01;
                $strobe("Temperature effect has caused pbswgs to be less than 0.01. Pbswgs is clamped to 0.01.\n");
            end
            BSIM4PhiBSWGD = BSIM4DGatesidewallJctPotential - BSIM4tpbswg * delTemp;
            if (BSIM4PhiBSWGD <= 0.01) begin
                BSIM4PhiBSWGD = 0.01;
                $strobe("Temperature effect has caused pbswgd to be less than 0.01. Pbswgd is clamped to 0.01.\n");
            end  /* End of junction capacitance */

            if (BSIM4ijthdfwd <= 0.0) begin
                BSIM4ijthdfwd = 0.0;  //0.1->0 for version > 4.6.1
                $strobe("Ijthdfwd reset to %g.\n", BSIM4ijthdfwd);
            end
            if (BSIM4ijthsfwd <= 0.0) begin
                BSIM4ijthsfwd = 0.0;  //0.1->0 for version > 4.6.1
                $strobe("Ijthsfwd reset to %g.\n", BSIM4ijthsfwd);
            end
            if (BSIM4ijthdrev <= 0.0) begin
                BSIM4ijthdrev = 0.0;  //0.1->0 for version > 4.6.1
                $strobe("Ijthdrev reset to %g.\n", BSIM4ijthdrev);
            end
            if (BSIM4ijthsrev <= 0.0) begin
                BSIM4ijthsrev = 0.0; //0.1->0 for version > 4.6.1
                $strobe("Ijthsrev reset to %g.\n", BSIM4ijthsrev);
            end

            if ((BSIM4xjbvd <= 0.0) && (BSIM4dioMod == 2)) begin
                BSIM4xjbvd = 0.0;    //1.0->0 for version > 4.6.1
                $strobe("Xjbvd reset to %g.\n", BSIM4xjbvd);
            end
            else if ((BSIM4xjbvd < 0.0) && (BSIM4dioMod == 0)) begin
                BSIM4xjbvd = 0.0;    //1.0->0 for version > 4.6.1
                $strobe("Xjbvd reset to %g.\n", BSIM4xjbvd);
            end

            if (BSIM4bvd <= 0.0) begin
                BSIM4bvd = 0.0; //10.0->0 for version > 4.6.1
                $strobe("BVD reset to %g.\n", BSIM4bvd);
            end

            if ((BSIM4xjbvs <= 0.0) && (BSIM4dioMod == 2)) begin
                BSIM4xjbvs =0.0; //1.0->0 for version > 4.6.1
                $strobe("Xjbvs reset to %g.\n", BSIM4xjbvs);
            end
            else if ((BSIM4xjbvs < 0.0) && (BSIM4dioMod == 0)) begin
                BSIM4xjbvs = 0.0;//1.0->0 for version > 4.6.1
                $strobe("Xjbvs reset to %g.\n", BSIM4xjbvs);
            end

            if (BSIM4bvs <= 0.0) begin
                BSIM4bvs = 0.0; //10.0->0 for version > 4.6.1
                $strobe("BVS reset to %g.\n", BSIM4bvs);
            end

            /* stress effect */
            Ldrn = BSIM4l;
            Wdrn = BSIM4w / BSIM4nf;

            Lnew = BSIM4l + BSIM4xl;
            Wnew = BSIM4w / BSIM4nf + BSIM4xw;

            T0 = pow(Lnew, BSIM4Lln);
            T1 = pow(Wnew, BSIM4Lwn);
            tmp1 = BSIM4Ll / T0 + BSIM4Lw / T1
                   + BSIM4Lwl / (T0 * T1);

            BSIM4dl = BSIM4Lint + tmp1;
            tmp2 = BSIM4Llc / T0 + BSIM4Lwc / T1
                   + BSIM4Lwlc / (T0 * T1);
            BSIM4dlc = BSIM4dlc + tmp2;
            //BSIM4dlcig = BSIM4dlcig + tmp2;  // version > 4.3 should be removed

            T2 = pow(Lnew, BSIM4Wln);
            T3 = pow(Wnew, BSIM4Wwn);
            tmp1 = BSIM4Wl / T2 + BSIM4Ww / T3
                   + BSIM4Wwl / (T2 * T3);
            BSIM4dw = BSIM4Wint + tmp1;
            tmp2 = BSIM4Wlc / T2 + BSIM4Wwc / T3
                   + BSIM4Wwlc / (T2 * T3);
            BSIM4dwc = BSIM4dwc + tmp2;
            BSIM4dwj = BSIM4dwj + tmp2;

            BSIM4leff = Lnew - 2.0 * BSIM4dl;
            if (BSIM4leff <= 0.0)
                $strobe("\nFATAL Error: leff <= 0.");

            BSIM4weff = Wnew - 2.0 * BSIM4dw;
            if (BSIM4weff <= 0.0)
                $strobe("\nFATAL Error: weff <= 0.");

            BSIM4leffCV = Lnew - 2.0 * BSIM4dlc;
            if (BSIM4leffCV <= 0.0)
                $strobe("\nFATAL Error: leffCV <= 0.");

            BSIM4weffCV = Wnew - 2.0 * BSIM4dwc;
            if (BSIM4weffCV <= 0.0)
                $strobe("\nFATAL Error: weffCV <= 0.");

            BSIM4weffCJ = Wnew - 2.0 * BSIM4dwj;

            if (BSIM4binUnit == 1) begin
                Inv_L = 1.0e-6 / BSIM4leff;
                Inv_W = 1.0e-6 / BSIM4weff;
                Inv_LW = 1.0e-12 / (BSIM4leff * BSIM4weff);
            end
            else begin
                Inv_L = 1.0 / BSIM4leff;
                Inv_W = 1.0 / BSIM4weff;
                Inv_LW = 1.0 / (BSIM4leff * BSIM4weff);
            end

            BSIM4cdsc = BSIM4cdsc
              + BSIM4lcdsc * Inv_L
              + BSIM4wcdsc * Inv_W
              + BSIM4pcdsc * Inv_LW;
            BSIM4cdscb = BSIM4cdscb
              + BSIM4lcdscb * Inv_L
              + BSIM4wcdscb * Inv_W
              + BSIM4pcdscb * Inv_LW;
            BSIM4cdscd = BSIM4cdscd
              + BSIM4lcdscd * Inv_L
              + BSIM4wcdscd * Inv_W
              + BSIM4pcdscd * Inv_LW;
            BSIM4cit = BSIM4cit
              + BSIM4lcit * Inv_L
              + BSIM4wcit * Inv_W
              + BSIM4pcit * Inv_LW;
            BSIM4nfactor = BSIM4nfactor
              + BSIM4lnfactor * Inv_L
              + BSIM4wnfactor * Inv_W
              + BSIM4pnfactor * Inv_LW;
            BSIM4xj = BSIM4xj
              + BSIM4lxj * Inv_L
              + BSIM4wxj * Inv_W
              + BSIM4pxj * Inv_LW;
            BSIM4vsat = BSIM4vsat
              + BSIM4lvsat * Inv_L
              + BSIM4wvsat * Inv_W
              + BSIM4pvsat * Inv_LW;
            BSIM4at = BSIM4at
              + BSIM4lat * Inv_L
              + BSIM4wat * Inv_W
              + BSIM4pat * Inv_LW;
            BSIM4a0 = BSIM4a0
              + BSIM4la0 * Inv_L
              + BSIM4wa0 * Inv_W
              + BSIM4pa0 * Inv_LW;
            BSIM4ags = BSIM4ags
              + BSIM4lags * Inv_L
              + BSIM4wags * Inv_W
              + BSIM4pags * Inv_LW;
            BSIM4a1 = BSIM4a1
              + BSIM4la1 * Inv_L
              + BSIM4wa1 * Inv_W
              + BSIM4pa1 * Inv_LW;
            BSIM4a2 = BSIM4a2
              + BSIM4la2 * Inv_L
              + BSIM4wa2 * Inv_W
              + BSIM4pa2 * Inv_LW;
            BSIM4keta = BSIM4keta
              + BSIM4lketa * Inv_L
              + BSIM4wketa * Inv_W
              + BSIM4pketa * Inv_LW;
            BSIM4nsub = BSIM4nsub
              + BSIM4lnsub * Inv_L
              + BSIM4wnsub * Inv_W
              + BSIM4pnsub * Inv_LW;
            BSIM4ndep = BSIM4ndep
              + BSIM4lndep * Inv_L
              + BSIM4wndep * Inv_W
              + BSIM4pndep * Inv_LW;
            BSIM4nsd = BSIM4nsd
              + BSIM4lnsd * Inv_L
              + BSIM4wnsd * Inv_W
              + BSIM4pnsd * Inv_LW;
            BSIM4phin = BSIM4phin
              + BSIM4lphin * Inv_L
              + BSIM4wphin * Inv_W
              + BSIM4pphin * Inv_LW;
            BSIM4ngate = BSIM4ngate
              + BSIM4lngate * Inv_L
              + BSIM4wngate * Inv_W
              + BSIM4pngate * Inv_LW;
            BSIM4gamma1 = BSIM4gamma1
              + BSIM4lgamma1 * Inv_L
              + BSIM4wgamma1 * Inv_W
              + BSIM4pgamma1 * Inv_LW;
            BSIM4gamma2 = BSIM4gamma2
              + BSIM4lgamma2 * Inv_L
              + BSIM4wgamma2 * Inv_W
              + BSIM4pgamma2 * Inv_LW;
            BSIM4vbx = BSIM4vbx
              + BSIM4lvbx * Inv_L
              + BSIM4wvbx * Inv_W
              + BSIM4pvbx * Inv_LW;
            BSIM4vbm = BSIM4vbm
              + BSIM4lvbm * Inv_L
              + BSIM4wvbm * Inv_W
              + BSIM4pvbm * Inv_LW;
            BSIM4xt = BSIM4xt
              + BSIM4lxt * Inv_L
              + BSIM4wxt * Inv_W
              + BSIM4pxt * Inv_LW;
            BSIM4vfb = BSIM4vfb
              + BSIM4lvfb * Inv_L
              + BSIM4wvfb * Inv_W
              + BSIM4pvfb * Inv_LW;
            BSIM4k1 = BSIM4k1
              + BSIM4lk1 * Inv_L
              + BSIM4wk1 * Inv_W
              + BSIM4pk1 * Inv_LW;
            BSIM4kt1 = BSIM4kt1
              + BSIM4lkt1 * Inv_L
              + BSIM4wkt1 * Inv_W
              + BSIM4pkt1 * Inv_LW;
            BSIM4kt1l = BSIM4kt1l
              + BSIM4lkt1l * Inv_L
              + BSIM4wkt1l * Inv_W
              + BSIM4pkt1l * Inv_LW;
            BSIM4k2 = BSIM4k2
              + BSIM4lk2 * Inv_L
              + BSIM4wk2 * Inv_W
              + BSIM4pk2 * Inv_LW;
            BSIM4kt2 = BSIM4kt2
              + BSIM4lkt2 * Inv_L
              + BSIM4wkt2 * Inv_W
              + BSIM4pkt2 * Inv_LW;
            BSIM4k3 = BSIM4k3
              + BSIM4lk3 * Inv_L
              + BSIM4wk3 * Inv_W
              + BSIM4pk3 * Inv_LW;
            BSIM4k3b = BSIM4k3b
              + BSIM4lk3b * Inv_L
              + BSIM4wk3b * Inv_W
              + BSIM4pk3b * Inv_LW;
            BSIM4w0 = BSIM4w0
              + BSIM4lw0 * Inv_L
              + BSIM4ww0 * Inv_W
              + BSIM4pw0 * Inv_LW;
            BSIM4lpe0 = BSIM4lpe0
              + BSIM4llpe0 * Inv_L
              + BSIM4wlpe0 * Inv_W
              + BSIM4plpe0 * Inv_LW;
            BSIM4lpeb = BSIM4lpeb
              + BSIM4llpeb * Inv_L
              + BSIM4wlpeb * Inv_W
              + BSIM4plpeb * Inv_LW;
            BSIM4dvtp0 = BSIM4dvtp0
              + BSIM4ldvtp0 * Inv_L
              + BSIM4wdvtp0 * Inv_W
              + BSIM4pdvtp0 * Inv_LW;
            BSIM4dvtp1 = BSIM4dvtp1
              + BSIM4ldvtp1 * Inv_L
              + BSIM4wdvtp1 * Inv_W
              + BSIM4pdvtp1 * Inv_LW;
            BSIM4dvt0 = BSIM4dvt0
              + BSIM4ldvt0 * Inv_L
              + BSIM4wdvt0 * Inv_W
              + BSIM4pdvt0 * Inv_LW;
            BSIM4dvt1 = BSIM4dvt1
              + BSIM4ldvt1 * Inv_L
              + BSIM4wdvt1 * Inv_W
              + BSIM4pdvt1 * Inv_LW;
            BSIM4dvt2 = BSIM4dvt2
              + BSIM4ldvt2 * Inv_L
              + BSIM4wdvt2 * Inv_W
              + BSIM4pdvt2 * Inv_LW;
            BSIM4dvt0w = BSIM4dvt0w
              + BSIM4ldvt0w * Inv_L
              + BSIM4wdvt0w * Inv_W
              + BSIM4pdvt0w * Inv_LW;
            BSIM4dvt1w = BSIM4dvt1w
              + BSIM4ldvt1w * Inv_L
              + BSIM4wdvt1w * Inv_W
              + BSIM4pdvt1w * Inv_LW;
            BSIM4dvt2w = BSIM4dvt2w
              + BSIM4ldvt2w * Inv_L
              + BSIM4wdvt2w * Inv_W
              + BSIM4pdvt2w * Inv_LW;
            BSIM4drout = BSIM4drout
              + BSIM4ldrout * Inv_L
              + BSIM4wdrout * Inv_W
              + BSIM4pdrout * Inv_LW;
            BSIM4dsub = BSIM4dsub
              + BSIM4ldsub * Inv_L
              + BSIM4wdsub * Inv_W
              + BSIM4pdsub * Inv_LW;
            BSIM4vth0 = BSIM4vth0
              + BSIM4lvth0 * Inv_L
              + BSIM4wvth0 * Inv_W
              + BSIM4pvth0 * Inv_LW;
            BSIM4ua = BSIM4ua
              + BSIM4lua * Inv_L
              + BSIM4wua * Inv_W
              + BSIM4pua * Inv_LW;
            BSIM4ua1 = BSIM4ua1
              + BSIM4lua1 * Inv_L
              + BSIM4wua1 * Inv_W
              + BSIM4pua1 * Inv_LW;
            BSIM4ub = BSIM4ub
              + BSIM4lub * Inv_L
              + BSIM4wub * Inv_W
              + BSIM4pub * Inv_LW;
            BSIM4ub1 = BSIM4ub1
              + BSIM4lub1 * Inv_L
              + BSIM4wub1 * Inv_W
              + BSIM4pub1 * Inv_LW;
            BSIM4uc = BSIM4uc
              + BSIM4luc * Inv_L
              + BSIM4wuc * Inv_W
              + BSIM4puc * Inv_LW;
            BSIM4uc1 = BSIM4uc1
              + BSIM4luc1 * Inv_L
              + BSIM4wuc1 * Inv_W
              + BSIM4puc1 * Inv_LW;
            BSIM4eu = BSIM4eu
              + BSIM4leu * Inv_L
              + BSIM4weu * Inv_W
              + BSIM4peu * Inv_LW;
            BSIM4u0 = BSIM4u0
              + BSIM4lu0 * Inv_L
              + BSIM4wu0 * Inv_W
              + BSIM4pu0 * Inv_LW;
            BSIM4ute = BSIM4ute
              + BSIM4lute * Inv_L
              + BSIM4wute * Inv_W
              + BSIM4pute * Inv_LW;

            //New model version > 4.3
            BSIM4tvoffcv = BSIM4tvoffcv
              + BSIM4ltvoffcv * Inv_L
              + BSIM4wtvoffcv * Inv_W
              + BSIM4ptvoffcv * Inv_LW;

            BSIM4teta0 = BSIM4teta0
              + BSIM4lteta0 * Inv_L
              + BSIM4wteta0 * Inv_W
              + BSIM4pteta0 * Inv_LW;

            BSIM4tnfactor = BSIM4tnfactor
              + BSIM4ltnfactor * Inv_L
              + BSIM4wtnfactor * Inv_W
              + BSIM4ptnfactor * Inv_LW;

            BSIM4minvcv = BSIM4minvcv
              + BSIM4lminvcv * Inv_L
              + BSIM4wminvcv * Inv_W
              + BSIM4pminvcv * Inv_LW;

            BSIM4tvfbsdoff = BSIM4tvfbsdoff
              + BSIM4ltvfbsdoff * Inv_L
              + BSIM4wtvfbsdoff * Inv_W
              + BSIM4ptvfbsdoff * Inv_LW;

            BSIM4aigs = BSIM4aigs
              + BSIM4laigs * Inv_L
              + BSIM4waigs * Inv_W
              + BSIM4paigs * Inv_LW;

            BSIM4bigs = BSIM4bigs
              + BSIM4lbigs * Inv_L
              + BSIM4wbigs * Inv_W
              + BSIM4pbigs * Inv_LW;

            BSIM4cigs = BSIM4cigs
              + BSIM4lcigs * Inv_L
              + BSIM4wcigs * Inv_W
              + BSIM4pcigs * Inv_LW;

            BSIM4aigd = BSIM4aigd
              + BSIM4laigd * Inv_L
              + BSIM4waigd * Inv_W
              + BSIM4paigd * Inv_LW;

            BSIM4bigd = BSIM4bigd
              + BSIM4lbigd * Inv_L
              + BSIM4wbigd * Inv_W
              + BSIM4pbigd * Inv_LW;

            BSIM4cigd = BSIM4cigd
              + BSIM4lcigd * Inv_L
              + BSIM4wcigd * Inv_W
              + BSIM4pcigd * Inv_LW;

            BSIM4agisl = BSIM4agisl
              + BSIM4lagisl * Inv_L
              + BSIM4wagisl * Inv_W
              + BSIM4pagisl * Inv_LW;

            BSIM4bgisl = BSIM4bgisl
              + BSIM4lbgisl * Inv_L
              + BSIM4wbgisl * Inv_W
              + BSIM4pbgisl * Inv_LW;

            BSIM4cgisl = BSIM4cgisl
              + BSIM4lcgisl * Inv_L
              + BSIM4wcgisl * Inv_W
              + BSIM4pcgisl * Inv_LW;

            BSIM4egisl = BSIM4egisl
              + BSIM4legisl * Inv_L
              + BSIM4wegisl * Inv_W
              + BSIM4pegisl * Inv_LW;

            BSIM4rgisl = BSIM4rgisl
              + BSIM4lrgisl * Inv_L
              + BSIM4wrgisl * Inv_W
              + BSIM4prgisl * Inv_LW;

            BSIM4kgisl = BSIM4kgisl
              + BSIM4lkgisl * Inv_L
              + BSIM4wkgisl * Inv_W
              + BSIM4pkgisl * Inv_LW;

            BSIM4fgisl = BSIM4fgisl
              + BSIM4lfgisl * Inv_L
              + BSIM4wfgisl * Inv_W
              + BSIM4pfgisl * Inv_LW;

            BSIM4rgidl = BSIM4rgidl
              + BSIM4lrgidl * Inv_L
              + BSIM4wrgidl * Inv_W
              + BSIM4prgidl * Inv_LW;

            BSIM4kgidl = BSIM4kgidl
              + BSIM4lkgidl * Inv_L
              + BSIM4wkgidl * Inv_W
              + BSIM4pkgidl * Inv_LW;

            BSIM4fgidl = BSIM4fgidl
              + BSIM4lfgidl * Inv_L
              + BSIM4wfgidl * Inv_W
              + BSIM4pfgidl * Inv_LW;

            BSIM4ud = BSIM4ud
              + BSIM4lud * Inv_L
              + BSIM4wud * Inv_W
              + BSIM4pud * Inv_LW;

            BSIM4ud1 = BSIM4ud1
              + BSIM4lud1 * Inv_L
              + BSIM4wud1 * Inv_W
              + BSIM4pud1 * Inv_LW;

            BSIM4up = BSIM4up
              + BSIM4lup * Inv_L
              + BSIM4wup * Inv_W
              + BSIM4pup * Inv_LW;

            BSIM4lp = BSIM4lp
              + BSIM4llp * Inv_L
              + BSIM4wlp * Inv_W
              + BSIM4plp * Inv_LW;

            BSIM4ucs = BSIM4ucs
              + BSIM4lucs * Inv_L
              + BSIM4wucs * Inv_W
              + BSIM4pucs * Inv_LW;

            BSIM4ucste = BSIM4ucste
              + BSIM4lucste * Inv_L
              + BSIM4wucste * Inv_W
              + BSIM4pucste * Inv_LW;

            BSIM4kvth0we = BSIM4kvth0we
              + BSIM4lkvth0we * Inv_L
              + BSIM4wkvth0we * Inv_W
              + BSIM4pkvth0we * Inv_LW;

            BSIM4k2we = BSIM4k2we
              + BSIM4lk2we * Inv_L
              + BSIM4wk2we * Inv_W
              + BSIM4pk2we * Inv_LW;

            BSIM4ku0we = BSIM4ku0we
              + BSIM4lku0we * Inv_L
              + BSIM4wku0we * Inv_W
              + BSIM4pku0we * Inv_LW;

            BSIM4vfbsdoff = BSIM4vfbsdoff
              + BSIM4lvfbsdoff * Inv_L
              + BSIM4wvfbsdoff * Inv_W
              + BSIM4pvfbsdoff * Inv_LW;

            BSIM4tvoff = BSIM4tvoff
              + BSIM4ltvoff * Inv_L
              + BSIM4wtvoff * Inv_W
              + BSIM4ptvoff * Inv_LW;
            BSIM4dvtp2 = BSIM4dvtp2
              + BSIM4ldvtp2 * Inv_L
              + BSIM4wdvtp2 * Inv_W
              + BSIM4pdvtp2 * Inv_LW;

            BSIM4dvtp3 = BSIM4dvtp3
              + BSIM4ldvtp3 * Inv_L
              + BSIM4wdvtp3 * Inv_W
              + BSIM4pdvtp3 * Inv_LW;

            BSIM4dvtp4 = BSIM4dvtp4
              + BSIM4ldvtp4 * Inv_L
              + BSIM4wdvtp4 * Inv_W
              + BSIM4pdvtp4 * Inv_LW;

            BSIM4dvtp5 = BSIM4dvtp5
              + BSIM4ldvtp5 * Inv_L
              + BSIM4wdvtp5 * Inv_W
              + BSIM4pdvtp5 * Inv_LW;

            BSIM4voff = BSIM4voff
              + BSIM4lvoff * Inv_L
              + BSIM4wvoff * Inv_W
              + BSIM4pvoff * Inv_LW;
            BSIM4minv = BSIM4minv
              + BSIM4lminv * Inv_L
              + BSIM4wminv * Inv_W
              + BSIM4pminv * Inv_LW;
            BSIM4fprout = BSIM4fprout
              + BSIM4lfprout * Inv_L
              + BSIM4wfprout * Inv_W
              + BSIM4pfprout * Inv_LW;
            BSIM4pdits = BSIM4pdits
              + BSIM4lpdits * Inv_L
              + BSIM4wpdits * Inv_W
              + BSIM4ppdits * Inv_LW;
            BSIM4pditsd = BSIM4pditsd
              + BSIM4lpditsd * Inv_L
              + BSIM4wpditsd * Inv_W
              + BSIM4ppditsd * Inv_LW;
            BSIM4delta = BSIM4delta
              + BSIM4ldelta * Inv_L
              + BSIM4wdelta * Inv_W
              + BSIM4pdelta * Inv_LW;
            BSIM4rdsw = BSIM4rdsw
              + BSIM4lrdsw * Inv_L
              + BSIM4wrdsw * Inv_W
              + BSIM4prdsw * Inv_LW;
            BSIM4rdw = BSIM4rdw
              + BSIM4lrdw * Inv_L
              + BSIM4wrdw * Inv_W
              + BSIM4prdw * Inv_LW;
            BSIM4rsw = BSIM4rsw
              + BSIM4lrsw * Inv_L
              + BSIM4wrsw * Inv_W
              + BSIM4prsw * Inv_LW;
            BSIM4prwg = BSIM4prwg
              + BSIM4lprwg * Inv_L
              + BSIM4wprwg * Inv_W
              + BSIM4pprwg * Inv_LW;
            BSIM4prwb = BSIM4prwb
              + BSIM4lprwb * Inv_L
              + BSIM4wprwb * Inv_W
              + BSIM4pprwb * Inv_LW;
            BSIM4prt = BSIM4prt
              + BSIM4lprt * Inv_L
              + BSIM4wprt * Inv_W
              + BSIM4pprt * Inv_LW;
            BSIM4eta0 = BSIM4eta0
              + BSIM4leta0 * Inv_L
              + BSIM4weta0 * Inv_W
              + BSIM4peta0 * Inv_LW;
            BSIM4etab = BSIM4etab
              + BSIM4letab * Inv_L
              + BSIM4wetab * Inv_W
              + BSIM4petab * Inv_LW;
            BSIM4pclm = BSIM4pclm
              + BSIM4lpclm * Inv_L
              + BSIM4wpclm * Inv_W
              + BSIM4ppclm * Inv_LW;
            BSIM4pdibl1 = BSIM4pdibl1
              + BSIM4lpdibl1 * Inv_L
              + BSIM4wpdibl1 * Inv_W
              + BSIM4ppdibl1 * Inv_LW;
            BSIM4pdibl2 = BSIM4pdibl2
              + BSIM4lpdibl2 * Inv_L
              + BSIM4wpdibl2 * Inv_W
              + BSIM4ppdibl2 * Inv_LW;
            BSIM4pdiblb = BSIM4pdiblb
              + BSIM4lpdiblb * Inv_L
              + BSIM4wpdiblb * Inv_W
              + BSIM4ppdiblb * Inv_LW;
            BSIM4pscbe1 = BSIM4pscbe1
              + BSIM4lpscbe1 * Inv_L
              + BSIM4wpscbe1 * Inv_W
              + BSIM4ppscbe1 * Inv_LW;
            BSIM4pscbe2 = BSIM4pscbe2
              + BSIM4lpscbe2 * Inv_L
              + BSIM4wpscbe2 * Inv_W
              + BSIM4ppscbe2 * Inv_LW;
            BSIM4pvag = BSIM4pvag
              + BSIM4lpvag * Inv_L
              + BSIM4wpvag * Inv_W
              + BSIM4ppvag * Inv_LW;
            BSIM4wr = BSIM4wr
              + BSIM4lwr * Inv_L
              + BSIM4wwr * Inv_W
              + BSIM4pwr * Inv_LW;
            BSIM4dwg = BSIM4dwg
              + BSIM4ldwg * Inv_L
              + BSIM4wdwg * Inv_W
              + BSIM4pdwg * Inv_LW;
            BSIM4dwb = BSIM4dwb
              + BSIM4ldwb * Inv_L
              + BSIM4wdwb * Inv_W
              + BSIM4pdwb * Inv_LW;
            BSIM4b0 = BSIM4b0
              + BSIM4lb0 * Inv_L
              + BSIM4wb0 * Inv_W
              + BSIM4pb0 * Inv_LW;
            BSIM4b1 = BSIM4b1
              + BSIM4lb1 * Inv_L
              + BSIM4wb1 * Inv_W
              + BSIM4pb1 * Inv_LW;
            BSIM4alpha0 = BSIM4alpha0
              + BSIM4lalpha0 * Inv_L
              + BSIM4walpha0 * Inv_W
              + BSIM4palpha0 * Inv_LW;
            BSIM4alpha1 = BSIM4alpha1
              + BSIM4lalpha1 * Inv_L
              + BSIM4walpha1 * Inv_W
              + BSIM4palpha1 * Inv_LW;
            BSIM4beta0 = BSIM4beta0
              + BSIM4lbeta0 * Inv_L
              + BSIM4wbeta0 * Inv_W
              + BSIM4pbeta0 * Inv_LW;
            BSIM4agidl = BSIM4agidl
              + BSIM4lagidl * Inv_L
              + BSIM4wagidl * Inv_W
              + BSIM4pagidl * Inv_LW;
            BSIM4bgidl = BSIM4bgidl
              + BSIM4lbgidl * Inv_L
              + BSIM4wbgidl * Inv_W
              + BSIM4pbgidl * Inv_LW;
            BSIM4cgidl = BSIM4cgidl
              + BSIM4lcgidl * Inv_L
              + BSIM4wcgidl * Inv_W
              + BSIM4pcgidl * Inv_LW;
            BSIM4egidl = BSIM4egidl
              + BSIM4legidl * Inv_L
              + BSIM4wegidl * Inv_W
              + BSIM4pegidl * Inv_LW;
            BSIM4aigc = BSIM4aigc
              + BSIM4laigc * Inv_L
              + BSIM4waigc * Inv_W
              + BSIM4paigc * Inv_LW;
            BSIM4bigc = BSIM4bigc
              + BSIM4lbigc * Inv_L
              + BSIM4wbigc * Inv_W
              + BSIM4pbigc * Inv_LW;
            BSIM4cigc = BSIM4cigc
              + BSIM4lcigc * Inv_L
              + BSIM4wcigc * Inv_W
              + BSIM4pcigc * Inv_LW;
            BSIM4aigsd = BSIM4aigsd
              + BSIM4laigsd * Inv_L
              + BSIM4waigsd * Inv_W
              + BSIM4paigsd * Inv_LW;
            BSIM4bigsd = BSIM4bigsd
              + BSIM4lbigsd * Inv_L
              + BSIM4wbigsd * Inv_W
              + BSIM4pbigsd * Inv_LW;
            BSIM4cigsd = BSIM4cigsd
              + BSIM4lcigsd * Inv_L
              + BSIM4wcigsd * Inv_W
              + BSIM4pcigsd * Inv_LW;
            BSIM4aigbacc = BSIM4aigbacc
              + BSIM4laigbacc * Inv_L
              + BSIM4waigbacc * Inv_W
              + BSIM4paigbacc * Inv_LW;
            BSIM4bigbacc = BSIM4bigbacc
              + BSIM4lbigbacc * Inv_L
              + BSIM4wbigbacc * Inv_W
              + BSIM4pbigbacc * Inv_LW;
            BSIM4cigbacc = BSIM4cigbacc
              + BSIM4lcigbacc * Inv_L
              + BSIM4wcigbacc * Inv_W
              + BSIM4pcigbacc * Inv_LW;
            BSIM4aigbinv = BSIM4aigbinv
              + BSIM4laigbinv * Inv_L
              + BSIM4waigbinv * Inv_W
              + BSIM4paigbinv * Inv_LW;
            BSIM4bigbinv = BSIM4bigbinv
              + BSIM4lbigbinv * Inv_L
              + BSIM4wbigbinv * Inv_W
              + BSIM4pbigbinv * Inv_LW;
            BSIM4cigbinv = BSIM4cigbinv
              + BSIM4lcigbinv * Inv_L
              + BSIM4wcigbinv * Inv_W
              + BSIM4pcigbinv * Inv_LW;
            BSIM4nigc = BSIM4nigc
              + BSIM4lnigc * Inv_L
              + BSIM4wnigc * Inv_W
              + BSIM4pnigc * Inv_LW;
            BSIM4nigbacc = BSIM4nigbacc
              + BSIM4lnigbacc * Inv_L
              + BSIM4wnigbacc * Inv_W
              + BSIM4pnigbacc * Inv_LW;
            BSIM4nigbinv = BSIM4nigbinv
              + BSIM4lnigbinv * Inv_L
              + BSIM4wnigbinv * Inv_W
              + BSIM4pnigbinv * Inv_LW;
            BSIM4ntox = BSIM4ntox
              + BSIM4lntox * Inv_L
              + BSIM4wntox * Inv_W
              + BSIM4pntox * Inv_LW;
            BSIM4eigbinv = BSIM4eigbinv
              + BSIM4leigbinv * Inv_L
              + BSIM4weigbinv * Inv_W
              + BSIM4peigbinv * Inv_LW;
            BSIM4pigcd = BSIM4pigcd
              + BSIM4lpigcd * Inv_L
              + BSIM4wpigcd * Inv_W
              + BSIM4ppigcd * Inv_LW;
            BSIM4poxedge = BSIM4poxedge
              + BSIM4lpoxedge * Inv_L
              + BSIM4wpoxedge * Inv_W
              + BSIM4ppoxedge * Inv_LW;
            BSIM4xrcrg1 = BSIM4xrcrg1
              + BSIM4lxrcrg1 * Inv_L
              + BSIM4wxrcrg1 * Inv_W
              + BSIM4pxrcrg1 * Inv_LW;
            BSIM4xrcrg2 = BSIM4xrcrg2
              + BSIM4lxrcrg2 * Inv_L
              + BSIM4wxrcrg2 * Inv_W
              + BSIM4pxrcrg2 * Inv_LW;

            // BSIM4.3
            BSIM4lambda = BSIM4lambda
              + BSIM4llambda * Inv_L
              + BSIM4wlambda * Inv_W
              + BSIM4plambda * Inv_LW;
            BSIM4vtl = BSIM4vtl
              + BSIM4lvtl * Inv_L
              + BSIM4wvtl * Inv_W
              + BSIM4pvtl * Inv_LW;
            BSIM4xn = BSIM4xn
              + BSIM4lxn * Inv_L
              + BSIM4wxn * Inv_W
              + BSIM4pxn * Inv_LW;
            BSIM4cgsl = BSIM4cgsl
              + BSIM4lcgsl * Inv_L
              + BSIM4wcgsl * Inv_W
              + BSIM4pcgsl * Inv_LW;
            BSIM4cgdl = BSIM4cgdl
              + BSIM4lcgdl * Inv_L
              + BSIM4wcgdl * Inv_W
              + BSIM4pcgdl * Inv_LW;
            BSIM4ckappas = BSIM4ckappas
              + BSIM4lckappas * Inv_L
              + BSIM4wckappas * Inv_W
              + BSIM4pckappas * Inv_LW;
            BSIM4ckappad = BSIM4ckappad
              + BSIM4lckappad * Inv_L
              + BSIM4wckappad * Inv_W
              + BSIM4pckappad * Inv_LW;
            BSIM4cf = BSIM4cf
              + BSIM4lcf * Inv_L
              + BSIM4wcf * Inv_W
              + BSIM4pcf * Inv_LW;
            BSIM4clc = BSIM4clc
              + BSIM4lclc * Inv_L
              + BSIM4wclc * Inv_W
              + BSIM4pclc * Inv_LW;
            BSIM4cle = BSIM4cle
              + BSIM4lcle * Inv_L
              + BSIM4wcle * Inv_W
              + BSIM4pcle * Inv_LW;
            BSIM4vfbcv = BSIM4vfbcv
              + BSIM4lvfbcv * Inv_L
              + BSIM4wvfbcv * Inv_W
              + BSIM4pvfbcv * Inv_LW;
            BSIM4acde = BSIM4acde
              + BSIM4lacde * Inv_L
              + BSIM4wacde * Inv_W
              + BSIM4pacde * Inv_LW;
            BSIM4moin = BSIM4moin
              + BSIM4lmoin * Inv_L
              + BSIM4wmoin * Inv_W
              + BSIM4pmoin * Inv_LW;
            BSIM4noff = BSIM4noff
              + BSIM4lnoff * Inv_L
              + BSIM4wnoff * Inv_W
              + BSIM4pnoff * Inv_LW;
            BSIM4voffcv = BSIM4voffcv
              + BSIM4lvoffcv * Inv_L
              + BSIM4wvoffcv * Inv_W
              + BSIM4pvoffcv * Inv_LW;

            BSIM4abulkCVfactor = 1.0 + pow((BSIM4clc / BSIM4leffCV), BSIM4cle);
            if (verbose == 1)
                $strobe("BSIM4abulkCVfactor=%g\n", BSIM4abulkCVfactor);

            T0 = (TRatio - 1.0);
            PowWeffWr = pow(BSIM4weffCJ * 1.0e6, BSIM4wr) * BSIM4nf;

            T1 = 0.0;
            T2 = 0.0;
            T3 = 0.0;
            T4 = 0.0;

            if (BSIM4tempMod == 0) begin
                BSIM4ua = BSIM4ua + BSIM4ua1 * T0;
                BSIM4ub = BSIM4ub + BSIM4ub1 * T0;
                BSIM4uc = BSIM4uc + BSIM4uc1 * T0;
                BSIM4vsattemp = BSIM4vsat - BSIM4at * T0;
                T10 = BSIM4prt * T0;
                /* External Rd(V) */
                if (BSIM4rdsMod) begin
                    T1 = BSIM4rdw + T10;
                    T2 = BSIM4rdwmin + T10;
                    /* External Rs(V) */
                    T3 = BSIM4rsw + T10;
                    T4 = BSIM4rswmin + T10;
                end
                /* Internal Rds(V) in IV */
                BSIM4rds0 = (BSIM4rdsw + T10) * BSIM4nf / PowWeffWr;
                BSIM4rdswmin = (BSIM4rdswmin + T10) * BSIM4nf / PowWeffWr;
            end
            else begin
                if (BSIM4tempMod == 3) begin
                    BSIM4ua = BSIM4ua * pow(TRatio, BSIM4ua1) ;
                    BSIM4ub = BSIM4ub * pow(TRatio, BSIM4ub1);
                    BSIM4uc = BSIM4uc * pow(TRatio, BSIM4uc1);
                    BSIM4ud = BSIM4ud * pow(TRatio, BSIM4ud1);
                end
                else begin
                    /* tempMod = 1,2 */
                    BSIM4ua = BSIM4ua * (1.0 + BSIM4ua1 * delTemp) ;
                    BSIM4ub = BSIM4ub * (1.0 + BSIM4ub1 * delTemp);
                    BSIM4uc = BSIM4uc * (1.0 + BSIM4uc1 * delTemp);
                end
                BSIM4vsattemp = BSIM4vsat * (1.0 - BSIM4at * delTemp);
                T10 = 1.0 + BSIM4prt * delTemp;
                /* External Rd(V) */
                if (BSIM4rdsMod) begin
                    T1 = BSIM4rdw * T10;
                    T2 = BSIM4rdwmin * T10;
                    /* External Rs(V) */
                    T3 = BSIM4rsw * T10;
                    T4 = BSIM4rswmin * T10;
                end
                /* Internal Rds(V) in IV */
                BSIM4rds0 = BSIM4rdsw * T10 * BSIM4nf / PowWeffWr;
                BSIM4rdswmin = BSIM4rdswmin * T10 * BSIM4nf / PowWeffWr;
            end

            if (T1 < 0.0) begin
                T1 = 0.0;
                $strobe("Warning: (instance X*) Rdw at current temperature is negative: set to 0.\n");
            end
            if (T2 < 0.0) begin
                T2 = 0.0;
                $strobe("Warning: (instance X*) Rdwmin at current temperature is negative: set to 0.\n");
            end
            BSIM4rd0 = T1 / PowWeffWr;
            BSIM4rdwmin = T2 / PowWeffWr;
            if (T3 < 0.0) begin
                T3 = 0.0;
                $strobe("Warning: (instance X*) Rsw at current temperature is negative: set to 0.\n");
            end

            if (T4 < 0.0) begin
                T4 = 0.0;
                $strobe("Warning: (instance X*) Rswmin at current temperature is negative: set to 0.\n");
            end
            BSIM4rs0 = T3 / PowWeffWr;
            BSIM4rswmin = T4 / PowWeffWr;

            if (BSIM4u0 > 1.0)
                BSIM4u0 = BSIM4u0 / 1.0e4;

            /* mobility channel length dependence */
            T5 = 1.0 - BSIM4up * exp( - BSIM4leff / BSIM4lp);
            BSIM4u0temp = BSIM4u0 * T5 * pow(TRatio, BSIM4ute);

            if (BSIM4eu < 0.0) begin
                BSIM4eu = 0.0;
                $strobe("Warning: (instance X*) eu has been negative: reset to 0.0.\n");
            end
            if (BSIM4ucs < 0.0) begin
                BSIM4ucs = 0.0;
                $strobe("Warning: ucs has been negative; reset to 0.0.\n");
            end
            BSIM4vfbsdoff = BSIM4vfbsdoff * (1.0 + BSIM4tvfbsdoff * delTemp);
            BSIM4voff = BSIM4voff * (1.0 + BSIM4tvoff * delTemp);

            BSIM4nfactor = BSIM4nfactor + BSIM4tnfactor * delTemp / Tnom;  /* v4.7 temp dep of leakage currents */
            BSIM4voffcv = BSIM4voffcv * (1.0 + BSIM4tvoffcv * delTemp);   /*     v4.7 temp dep of leakage currents */
            BSIM4eta0 = BSIM4eta0 + BSIM4teta0 * delTemp / Tnom;   /*    v4.7 temp dep of leakage currents */

            /* Source End Velocity Limit  */
            if (($param_given(vtl)) && (BSIM4vtl > 0.0) ) begin
                if (BSIM4lc < 0.0)
                    BSIM4lc = 0.0;

                T0 = BSIM4leff / (BSIM4xn * BSIM4leff + BSIM4lc);
                BSIM4tfactor = (1.0 - T0) / (1.0 + T0 );
            end

            BSIM4cgdo = (BSIM4cgdo + BSIM4cf) * BSIM4weffCV;
            BSIM4cgso = (BSIM4cgso + BSIM4cf) * BSIM4weffCV;
            BSIM4cgbo = BSIM4cgbo * BSIM4leffCV * BSIM4nf;

            if (!$param_given(ndep) && $param_given(gamma1)) begin
                T0 = BSIM4gamma1 * BSIM4coxe;
                BSIM4ndep = 3.01248e22 * T0 * T0;
            end

            BSIM4phi = Vtm0 * ln(BSIM4ndep / ni) + BSIM4phin + 0.4;

            BSIM4sqrtPhi = sqrt(BSIM4phi);
            BSIM4phis3 = BSIM4sqrtPhi * BSIM4phi;

            BSIM4Xdep0 = sqrt(2.0 * epssubl / (`P_Q * BSIM4ndep * 1.0e6))
                      * BSIM4sqrtPhi;
            BSIM4sqrtXdep0 = sqrt(BSIM4Xdep0);

            //BSIM4litl = sqrt(3.0 * BSIM4xj * BSIM4toxe);
            //New model version >4.3
            if (BSIM4mtrlmod == 0)
                BSIM4litl = sqrt(3.0 * 3.9 / epsroxl * BSIM4xj * toxel);
            else
                BSIM4litl = sqrt(BSIM4epsrsub/epsroxl * BSIM4xj * toxel);

            BSIM4vbi = Vtm0 * ln(BSIM4nsd * BSIM4ndep / (ni * ni));

            if (BSIM4mtrlmod == 0) begin
                if (BSIM4ngate > 0.0)
                    BSIM4vfbsd = Vtm0 * ln(BSIM4ngate / BSIM4nsd);
                else
                    BSIM4vfbsd = 0.0;
            end
            else begin
                T0 = Vtm0 * ln(BSIM4nsd/ni);
                T1 = 0.5 * Eg0;
                if (T0 > T1)
                    T0 = T1;
                T2 = BSIM4easub + T1 - BSIM4type * T0;
                BSIM4vfbsd = BSIM4phig - T2;
            end

            BSIM4cdep0 = sqrt(`P_Q * epssubl * BSIM4ndep * 1.0e6 / 2.0 / BSIM4phi);

            BSIM4ToxRatio = exp(BSIM4ntox * ln(BSIM4toxref / toxel))
                            / toxel / toxel;
            BSIM4ToxRatioEdge = exp(BSIM4ntox * ln(BSIM4toxref /
                (toxel * BSIM4poxedge))) /
                toxel / toxel / BSIM4poxedge / BSIM4poxedge;
            BSIM4Aechvb = (BSIM4type == `NMOS) ? 4.97232e-7 : 3.42537e-7;
            BSIM4Bechvb = (BSIM4type == `NMOS) ? 7.45669e11 : 1.16645e12;
            BSIM4AechvbEdgeS = BSIM4Aechvb * BSIM4weff * BSIM4dlcig
                                * BSIM4ToxRatioEdge;
            BSIM4AechvbEdgeD = BSIM4Aechvb * BSIM4weff * BSIM4dlcigd
            * BSIM4ToxRatioEdge;

            BSIM4BechvbEdge = -BSIM4Bechvb * toxel * BSIM4poxedge;
            BSIM4Aechvb = BSIM4Aechvb * ( BSIM4weff * BSIM4leff * BSIM4ToxRatio);
            BSIM4Bechvb = BSIM4Bechvb * ( -toxel);

            BSIM4mstar = 0.5 + atan(BSIM4minv) / `M_PI;
            BSIM4mstarcv = 0.5 + atan(BSIM4minvcv) / `M_PI;
            BSIM4voffcbn = BSIM4voff + BSIM4voffl / BSIM4leff;
            BSIM4voffcbncv =  BSIM4voffcv + BSIM4voffcvl / BSIM4leff;
            BSIM4ldeb = sqrt( epssubl * Vtm0 / (`P_Q * BSIM4ndep * 1.0e6)) / 3.0;
            BSIM4acde = BSIM4acde * (  pow((BSIM4ndep / 2.0e16), -0.25));
            if (verbose ==1) begin
                $strobe("BSIM4AechvbEdgeS,D=%g,%g\n",BSIM4AechvbEdgeS, BSIM4AechvbEdgeD);
                $strobe("BSIM4BechvbEdge,BSIM4Aechvb,BSIM4Bechvb=%g,%g,%g\n",BSIM4BechvbEdge,BSIM4Aechvb,BSIM4Bechvb);
            end

            if ($param_given(k1) || $param_given(k2)) begin
                if (!$param_given(k1)) begin
                    $strobe("Warning: (instance X*) k1 should be specified with k2.\n");
                    BSIM4k1 = 0.53;
                end
                if (!$param_given(k2)) begin
                    $strobe("Warning: (instance X*) k2 should be specified with k1.\n");
                    BSIM4k2 = -0.0186;
                end
                if ($param_given(nsub))
                    $strobe("Warning: (instance X*) nsub is ignored because k1 or k2 is given.\n");
                if ($param_given(xt))
                    $strobe("Warning: (instance X*) xt is ignored because k1 or k2 is given.\n");
                if ($param_given(vbx))
                    $strobe("Warning: (instance X*) vbx is ignored because k1 or k2 is given.\n");
                if ($param_given(gamma1))
                    $strobe("Warning: (instance X*) gamma1 is ignored because k1 or k2 \
                             is given.\n");
                if ($param_given(gamma2))
                    $strobe("Warning: (instance X*) gamma2 is ignored because k1 or k2 \
                             is given.\n");
            end
            else begin
                if (!$param_given(vbx))
                    $strobe("\n RECALCULATION for no K1 or K2");
                BSIM4vbx = BSIM4phi - 7.7348e-4 * BSIM4ndep * BSIM4xt * BSIM4xt;

                if (BSIM4vbx > 0.0)
                    BSIM4vbx = -BSIM4vbx;
                if (BSIM4vbm > 0.0)
                    BSIM4vbm = -BSIM4vbm;
                if (!$param_given(gamma1))
                    BSIM4gamma1 = 5.753e-12 * sqrt(BSIM4ndep) / BSIM4coxe;
                if (!$param_given(gamma2))
                    BSIM4gamma2 = 5.753e-12 * sqrt(BSIM4nsub) / BSIM4coxe;

                T0 = BSIM4gamma1 - BSIM4gamma2;
                T1 = sqrt(BSIM4phi - BSIM4vbx) - BSIM4sqrtPhi;
                T2 = sqrt(BSIM4phi * (BSIM4phi - BSIM4vbm)) - BSIM4phi;
                BSIM4k2 = T0 * T1 / (2.0 * T2 + BSIM4vbm);
                BSIM4k1 = BSIM4gamma2 - 2.0 * BSIM4k2 * sqrt(BSIM4phi - BSIM4vbm);
            end


            if (!$param_given(vfb)) begin
                if ($param_given(vth0))
                    BSIM4vfb = BSIM4type * BSIM4vth0 - BSIM4phi
                                - BSIM4k1 * BSIM4sqrtPhi;
                else begin
                    if ((BSIM4mtrlmod) && ($param_given(phig)) &&
                        ($param_given(nsub)))
                    begin
                        T0 = Vtm0 * ln(BSIM4nsub/ni);
                        T1 = 0.5 * Eg0;
                        if (T0 > T1)
                            T0 = T1;
                        T2 = BSIM4easub + T1 + BSIM4type * T0;
                        BSIM4vfb = BSIM4phig - T2;
                    end
                    else
                        BSIM4vfb = -1.0;
                end
            end
            if (!$param_given(vth0)) begin
                BSIM4vth0 = BSIM4type * (BSIM4vfb + BSIM4phi
                         + BSIM4k1 * BSIM4sqrtPhi);
            end

            BSIM4k1ox = BSIM4k1 * toxel / BSIM4toxm;
            tmp = sqrt(epssubl / (epsroxl * `EPS0) * toxel * BSIM4Xdep0);

            T0 = BSIM4dsub * BSIM4leff / tmp;
            if (T0 < `EXP_THRESHOLD) begin
                T1 = exp(T0);
                T2 = T1 - 1.0;
                T3 = T2 * T2;
                T4 = T3 + 2.0 * T1 * `MIN_EXP;
                BSIM4theta0vb0 = T1 / T4;
            end
            else
                BSIM4theta0vb0 = 1.0 / (`MAX_EXP - 2.0);

            T0 = BSIM4drout * BSIM4leff / tmp;
            if (T0 < `EXP_THRESHOLD) begin
                T1 = exp(T0);
                T2 = T1 - 1.0;
                T3 = T2 * T2;
                T4 = T3 + 2.0 * T1 * `MIN_EXP;
                T5 = T1 / T4;
            end
            else
                T5 = 1.0 / (`MAX_EXP - 2.0); /* 3.0 * `MIN_EXP omitted */
            BSIM4thetaRout = BSIM4pdibl1 * T5 + BSIM4pdibl2;

            tmp = sqrt(BSIM4Xdep0);
            tmp1 = BSIM4vbi - BSIM4phi;
            tmp2 = BSIM4factor1 * tmp;

            T0 = BSIM4dvt1w * BSIM4weff * BSIM4leff / tmp2;
            if (T0 < `EXP_THRESHOLD) begin
                T1 = exp(T0);
                T2 = T1 - 1.0;
                T3 = T2 * T2;
                T4 = T3 + 2.0 * T1 * `MIN_EXP;
                T8 = T1 / T4;
            end
            else
                T8 = 1.0 / (`MAX_EXP - 2.0);

            T0 = BSIM4dvt0w * T8;
            T8 = T0 * tmp1;

            T0 = BSIM4dvt1 * BSIM4leff / tmp2;
            if (T0 < `EXP_THRESHOLD) begin
                T1 = exp(T0);
                T2 = T1 - 1.0;
                T3 = T2 * T2;
                T4 = T3 + 2.0 * T1 * `MIN_EXP;
                T9 = T1 / T4;
            end
            else
                T9 = 1.0 / (`MAX_EXP - 2.0);

            T9 = BSIM4dvt0 * T9 * tmp1;
            T4 = toxel * BSIM4phi / (BSIM4weff + BSIM4w0);

            T0 = sqrt(1.0 + BSIM4lpe0 / BSIM4leff);
            if ((BSIM4tempMod == 1) || (BSIM4tempMod == 0))
                T3 = (BSIM4kt1 + BSIM4kt1l / BSIM4leff) * (TRatio - 1.0);
            if ((BSIM4tempMod == 2)||(BSIM4tempMod == 3))
                T3 = - BSIM4kt1 * (TRatio - 1.0);

            T5 = BSIM4k1ox * (T0 - 1.0) * BSIM4sqrtPhi
                  + T3;
            BSIM4vfbzbfactor = - T8 - T9 + BSIM4k3 * T4 + T5
            - BSIM4phi - BSIM4k1 * BSIM4sqrtPhi;

            /* Stress effect */
            if (BSIM4wlod < 0.0) begin
                $strobe("Warning: WLOD = %g is less than 0. 0.0 is used\n",BSIM4wlod);
                BSIM4wlod = 0.0;
            end
            T0 = pow(Lnew, BSIM4llodku0);
            W_tmp = Wnew + BSIM4wlod;
            T1 = pow(W_tmp, BSIM4wlodku0);
            tmp1 = BSIM4lku0 / T0 + BSIM4wku0 / T1 + BSIM4pku0 / (T0 * T1);
            T9 = 1.0 + tmp1;

            T0 = pow(Lnew, BSIM4llodvth);
            T1 = pow(W_tmp, BSIM4wlodvth);
            tmp1 = BSIM4lkvth0 / T0 + BSIM4wkvth0 / T1 + BSIM4pkvth0 / (T0 * T1);
            param_BSIM4kvth0 = 1.0 + tmp1;
            param_BSIM4kvth0 = sqrt(param_BSIM4kvth0*param_BSIM4kvth0 + `DELTA);

            T0 = (TRatio - 1.0);
            BSIM4ku0temp = T9 * (1.0 + BSIM4tku0 * T0) + `DELTA;

            Inv_saref = 1.0/(BSIM4saref + 0.5*Ldrn);
            Inv_sbref = 1.0/(BSIM4sbref + 0.5*Ldrn);
            BSIM4inv_od_ref = Inv_saref + Inv_sbref;
            BSIM4rho_ref = BSIM4ku0 / BSIM4ku0temp * BSIM4inv_od_ref;

            //New model paramsters version > 4.3
            /*high k*/
            /*Calculate VgsteffVth for mobMod=3*/
            if (BSIM4mobMod == 3) begin
                /*Calculate n @ Vbs=Vds=0*/
                lt1 = BSIM4factor1* BSIM4sqrtXdep0;
                T0 = BSIM4dvt1 * BSIM4leff / lt1;
                if (T0 < `EXP_THRESHOLD) begin
                    T1 = exp(T0);
                    T2 = T1 - 1.0;
                    T3 = T2 * T2;
                    T4 = T3 + 2.0 * T1 * `MIN_EXP;
                    Theta0 = T1 / T4;
                end
                else
                    Theta0 = 1.0 / (`MAX_EXP - 2.0);

                tmp1 = epssubl / BSIM4Xdep0;
                tmp2 = BSIM4nfactor * tmp1;
                tmp3 = (tmp2 + BSIM4cdsc * Theta0 + BSIM4cit) / BSIM4coxe;
                if (tmp3 >= -0.5)
                    N0 = 1.0 + tmp3;
                else begin
                    T0 = 1.0 / (3.0 + 8.0 * tmp3);
                    N0 = (1.0 + 3.0 * tmp3) * T0;
                end

                T0 = N0 * BSIM4vtm;
                T1 = BSIM4voffcbn;
                T2 = T1/T0;
                if (T2 < -`EXP_THRESHOLD) begin
                    T3 = BSIM4coxe * `MIN_EXP / BSIM4cdep0;
                    T4 = BSIM4mstar + T3 * N0;
                end
                else if (T2 > `EXP_THRESHOLD) begin
                    T3 = BSIM4coxe * `MAX_EXP / BSIM4cdep0;
                    T4 = BSIM4mstar + T3 * N0;
                end
                else begin
                    T3 = exp(T2)* BSIM4coxe / BSIM4cdep0;
                    T4 = BSIM4mstar + T3 * N0;
                end
                BSIM4VgsteffVth = T0 * ln(2.0)/T4;
            end /*BSIM4mobMod == 3*/

            /* New DITS term added in 4.7 */
            T0 = -BSIM4dvtp3 * ln(BSIM4leff);
            `DEXP(T0, T1)
            BSIM4dvtp2factor = BSIM4dvtp5 + BSIM4dvtp2 * T1;

            /*  Stress effect */
            if ( (BSIM4sa > 0.0) && (BSIM4sb > 0.0) &&

                ((BSIM4nf == 1.0) || ((BSIM4nf > 1.0) && (BSIM4sd > 0.0))) ) begin
                Inv_sa = 0.0;
                Inv_sb = 0.0;
                if (BSIM4kvsat < -1.0 )
                begin
                    $strobe("Warning: KVSAT = %g is too small; -1.0 is used.\n",BSIM4kvsat);
                    BSIM4kvsat = -1.0;
                end
                if (BSIM4kvsat > 1.0)
                begin
                    $strobe("Warning: KVSAT = %g is too big; 1.0 is used.\n",BSIM4kvsat);
                    BSIM4kvsat = 1.0;
                end

                for (i = 0; i < BSIM4nf; i = i + 1) begin
                    T0 = 1.0 / BSIM4nf / (BSIM4sa + 0.5*Ldrn + i * (BSIM4sd +Ldrn));
                    T1 = 1.0 / BSIM4nf / (BSIM4sb + 0.5*Ldrn + i * (BSIM4sd +Ldrn));
                    Inv_sa = Inv_sa +T0;
                    Inv_sb = Inv_sb + T1;
                end

                Inv_ODeff = Inv_sa + Inv_sb;
                rho = BSIM4ku0 / BSIM4ku0temp * Inv_ODeff;

                T0 = (1.0 + rho)/(1.0 + BSIM4rho_ref);
                here_BSIM4u0temp = BSIM4u0temp * T0;
                T1 = (1.0 + BSIM4kvsat * rho)/(1.0 + BSIM4kvsat * BSIM4rho_ref);
                here_BSIM4vsattemp = BSIM4vsattemp * T1;

                OD_offset = Inv_ODeff - BSIM4inv_od_ref;
                dvth0_lod = BSIM4kvth0 / param_BSIM4kvth0 * OD_offset;

                dk2_lod = BSIM4stk2 / pow(param_BSIM4kvth0, BSIM4lodk2)* OD_offset;
                deta0_lod = BSIM4steta0 / pow(param_BSIM4kvth0, BSIM4lodeta0)
                             * OD_offset;

                here_BSIM4vth0 = BSIM4vth0 + dvth0_lod;
                here_BSIM4eta0 = BSIM4eta0 + deta0_lod;
                here_BSIM4k2 = BSIM4k2 + dk2_lod;
            end
            else begin
                here_BSIM4u0temp = BSIM4u0temp;
                here_BSIM4vth0 = BSIM4vth0;
                here_BSIM4vsattemp = BSIM4vsattemp;
                here_BSIM4eta0 = BSIM4eta0;
                here_BSIM4k2 = BSIM4k2;
            end

            /*  Well Proximity Effect  */
            if (BSIM4wpemod) begin
                if ( (!$param_given(sca)) && (!$param_given(scb)) && (!$param_given(scc)) )
                begin
                    if ($param_given(sc) && (BSIM4sc > 0.0) ) begin
                        T1 = BSIM4sc + Wdrn;
                        T2 = 1.0 / BSIM4scref;
                        BSIM4sca = BSIM4scref * BSIM4scref
                        / (BSIM4sc * T1);
                        BSIM4scb = ( (0.1 * BSIM4sc + 0.01 * BSIM4scref)
                        * exp(-10.0 * BSIM4sc * T2)
                        - (0.1 * T1 + 0.01 * BSIM4scref)
                        * exp(-10.0 * T1 * T2) ) / Wdrn;
                        BSIM4scc = ( (0.05 * BSIM4sc + 0.0025 * BSIM4scref)
                                        * exp(-20.0 * BSIM4sc * T2)
                                        - (0.05 * T1 + 0.0025 * BSIM4scref)
                                        * exp(-20.0 * T1 * T2) ) / Wdrn;
                    end else
                        $strobe("Warning: No WPE as none of SCA, SCB, SCC, SC is given and/or SC not positive.\n");

                end

                if (BSIM4sca < 0.0) begin
                    $strobe("Warning: SCA = %g is negative. Set to 0.0.\n", BSIM4sca);
                    BSIM4sca = 0.0;
                end
                if (BSIM4scb < 0.0) begin
                    $strobe("Warning: SCB = %g is negative. Set to 0.0.\n", BSIM4scb);
                    BSIM4scb = 0.0;
                end
                if (BSIM4scc < 0.0) begin
                    $strobe("Warning: SCC = %g is negative. Set to 0.0.\n", BSIM4scc);
                    BSIM4scc = 0.0;
                end
                if (BSIM4sc < 0.0) begin
                    $strobe("Warning: SC = %g is negative. Set to 0.0.\n", BSIM4sc);
                    BSIM4sc = 0.0;
                end
                /*4.6.2*/
                sceff = BSIM4sca + BSIM4web * BSIM4scb
                      + BSIM4wec * BSIM4scc;
                here_BSIM4vth0 = here_BSIM4vth0 + BSIM4kvth0we * sceff;
                here_BSIM4k2 = here_BSIM4k2 +  BSIM4k2we * sceff;
                T3 =  1.0 + BSIM4ku0we * sceff;
                if (T3 <= 0.0)
                begin   T3 = 0.0;
                    $strobe("Warning: ku0we = %g is negatively too high. Negative mobility! \n",BSIM4ku0we);
                end
                here_BSIM4u0temp = here_BSIM4u0temp * T3;
            end

            /* adding delvto  */
            here_BSIM4vth0 = here_BSIM4vth0 + BSIM4delvto;
            here_BSIM4vfb = BSIM4vfb + BSIM4type * BSIM4delvto;

            /* Instance variables calculation  */
            T3 = BSIM4type * here_BSIM4vth0
               - here_BSIM4vfb - BSIM4phi;
            T4 = T3 + T3;
            T5 = 2.5 * T3;
            here_BSIM4vtfbphi1 = (BSIM4type == `NMOS) ? T4 : T5;
            if (here_BSIM4vtfbphi1 < 0.0)
                here_BSIM4vtfbphi1 = 0.0;

            here_BSIM4vtfbphi2 = 4.0 * T3;
            if (here_BSIM4vtfbphi2 < 0.0)
                here_BSIM4vtfbphi2 = 0.0;

            if (here_BSIM4k2 < 0.0)
            begin   T0 = 0.5 * BSIM4k1 / here_BSIM4k2;
                here_BSIM4vbsc = 0.9 * (BSIM4phi - T0 * T0);
                if (here_BSIM4vbsc > -3.0)
                    here_BSIM4vbsc = -3.0;
                else if (here_BSIM4vbsc < -30.0)
                    here_BSIM4vbsc = -30.0;
            end
            else
                here_BSIM4vbsc = -30.0;
            if (here_BSIM4vbsc > BSIM4vbm)
                here_BSIM4vbsc = BSIM4vbm;
            here_BSIM4k2ox = here_BSIM4k2 * toxel
                              / BSIM4toxm;

            here_BSIM4vfbzb = BSIM4vfbzbfactor
            +  BSIM4type * here_BSIM4vth0 ;

            //`ifdef __RBODYMOD__
            //New model rbodyMod >1
            lnl = ln(BSIM4leff * 1.0e6);
            lnw = ln(BSIM4weff * 1.0e6);
            lnnf =ln(BSIM4nf);

            bodymode = 5;
            if ( ( !$param_given(rbps0)) ||
                ( !$param_given(rbpd0)) )
                bodymode = 1;
            else
                if ( (!$param_given(rbsbx0) && !$param_given(rbsby0)) ||
                    (!$param_given(rbdbx0) && !$param_given(rbdby0)) )
                    bodymode = 3;

            if (BSIM4rbodyMod == 2)
            begin
                if (bodymode == 5)
                begin
                    T0 =  BSIM4rbsbx0 * exp( BSIM4rbsdbxl * lnl +  BSIM4rbsdbxw * lnw + BSIM4rbsdbxnf * lnnf ); //rbsbx -> T0
                    T1 =  BSIM4rbsby0 * exp( BSIM4rbsdbyl * lnl +  BSIM4rbsdbyw * lnw + BSIM4rbsdbynf * lnnf ); //rbsby -> T1
                    BSIM4rbsb = T0 * T1 / (T0 + T1);

                    T0 =  BSIM4rbdbx0 * exp( BSIM4rbsdbxl * lnl +  BSIM4rbsdbxw * lnw + BSIM4rbsdbxnf * lnnf );
                    T1 =  BSIM4rbdby0 * exp(  BSIM4rbsdbyl * lnl +  BSIM4rbsdbyw * lnw + BSIM4rbsdbynf * lnnf );
                    BSIM4rbdb = T0 * T1 / (T0 + T1);
                end

                if ((bodymode == 3)|| (bodymode == 5))
                begin
                    BSIM4rbps = BSIM4rbps0 * exp( BSIM4rbpsl * lnl +  BSIM4rbpsw * lnw + BSIM4rbpsnf * lnnf );
                    BSIM4rbpd = BSIM4rbpd0 * exp( BSIM4rbpdl * lnl +  BSIM4rbpdw * lnw + BSIM4rbpdnf * lnnf );

                end
                T0 =  BSIM4rbpbx0 * exp(  BSIM4rbpbxl * lnl +
                BSIM4rbpbxw * lnw + BSIM4rbpbxnf * lnnf );
                T1 =  BSIM4rbpby0 * exp(  BSIM4rbpbyl * lnl +
                BSIM4rbpbyw * lnw + BSIM4rbpbynf * lnnf );

                BSIM4rbpb = T0*T1/(T0 + T1);
            end


            if ((BSIM4rbodyMod == 1 ) || ((BSIM4rbodyMod == 2 ) && (bodymode == 5)) )
            begin
                if (BSIM4rbdb < 1.0e-3)
                    BSIM4grbdb = 1.0e3; /* in mho */
                else
                    BSIM4grbdb = BSIM4gbmin + 1.0 / BSIM4rbdb;
                if (BSIM4rbpb < 1.0e-3)
                    BSIM4grbpb = 1.0e3;
                else
                    BSIM4grbpb = BSIM4gbmin + 1.0 / BSIM4rbpb;
                if (BSIM4rbps < 1.0e-3)
                    BSIM4grbps = 1.0e3;
                else
                    BSIM4grbps = BSIM4gbmin + 1.0 / BSIM4rbps;
                if (BSIM4rbsb < 1.0e-3)
                    BSIM4grbsb = 1.0e3;
                else
                    BSIM4grbsb = BSIM4gbmin + 1.0 / BSIM4rbsb;
                if (BSIM4rbpd < 1.0e-3)
                    BSIM4grbpd = 1.0e3;
                else
                    BSIM4grbpd = BSIM4gbmin + 1.0 / BSIM4rbpd;
            end

            if ((BSIM4rbodyMod == 2) && (bodymode == 3))
            begin
                BSIM4grbdb = BSIM4gbmin;
                BSIM4grbsb = BSIM4gbmin;
                if (BSIM4rbpb < 1.0e-3)
                    BSIM4grbpb = 1.0e3;
                else
                    BSIM4grbpb = BSIM4gbmin + 1.0 / BSIM4rbpb;
                if (BSIM4rbps < 1.0e-3)
                    BSIM4grbps = 1.0e3;
                else
                    BSIM4grbps = BSIM4gbmin + 1.0 / BSIM4rbps;
                if (BSIM4rbpd < 1.0e-3)
                    BSIM4grbpd = 1.0e3;
                else
                    BSIM4grbpd = BSIM4gbmin + 1.0 / BSIM4rbpd;
            end

            if ((BSIM4rbodyMod == 2) && (bodymode == 1))
            begin
                BSIM4grbsb = BSIM4gbmin;
                BSIM4grbdb = BSIM4gbmin;
                BSIM4grbps = 1.0e3;
                BSIM4grbpd = 1.0e3;
                if (BSIM4rbpb < 1.0e-3)
                    BSIM4grbpb = 1.0e3;
                else
                    BSIM4grbpb = BSIM4gbmin + 1.0 / BSIM4rbpb;
            end
            //`endif


            /*
             * Process geometry dependent parasitics
             */

            BSIM4grgeltd = BSIM4rshg * (BSIM4xgw + BSIM4weffCJ / 3.0 / BSIM4ngcon)
                            / (BSIM4ngcon * BSIM4nf * (Lnew - BSIM4xgl));

            if (BSIM4grgeltd > 0.0)
                BSIM4grgeltd = 1.0 / BSIM4grgeltd;
            else begin
                BSIM4grgeltd = 1.0e3; /* mho */
                if (BSIM4rgateMod != 0)
                    $strobe("Warning: (instance X*) The gate conductance reset to 1.0e3 mho.\n");
            end

            DMCGeff = BSIM4dmcg - BSIM4dmcgt;
            DMCIeff = BSIM4dmci;
            DMDGeff = BSIM4dmdg - BSIM4dmcgt;

            /* New Diode Model v4.7*/
            if ($param_given(ps))
                //if (BSIM4perMod == 0)
                //    BSIM4Pseff = BSIM4sourcePerimeter;
                //else
                //    BSIM4Pseff = BSIM4sourcePerimeter - BSIM4weffCJ * BSIM4nf;
            begin   /* given */
                if (BSIM4sourcePerimeter == 0.0)
                    BSIM4Pseff = 0.0;
                else if (BSIM4sourcePerimeter < 0.0)
                begin
                    $strobe("Warning: Source Perimeter is specified as negative, it is set to zero.\n");
                    BSIM4Pseff = 0.0;
                end else begin
                    if (BSIM4perMod == 0)
                        BSIM4Pseff = BSIM4sourcePerimeter;
                    else
                        BSIM4Pseff = BSIM4sourcePerimeter - BSIM4weffCJ * BSIM4nf;
                end
            end
            else begin  /* not given */
                `BSIM4PAeffGeo(BSIM4nf, BSIM4geoMod, BSIM4min, BSIM4weffCJ, DMCGeff, DMCIeff, DMDGeff, BSIM4Pseff, dumPd, dumAs, dumAd)
            end
            if (BSIM4Pseff < 0.0) begin
                /* v4.7 final check */
                BSIM4Pseff = 0.0;
                $strobe("Warning: Pseff is negative, it is set to zero.\n");
            end
            if ($param_given(pd))
                //if (BSIM4perMod == 0)
                //    BSIM4Pdeff = BSIM4drainPerimeter;
                //else
                //    BSIM4Pdeff = BSIM4drainPerimeter - BSIM4weffCJ * BSIM4nf;
            begin   /* given */
                if (BSIM4drainPerimeter == 0.0)
                    BSIM4Pdeff = 0.0;
                else if (BSIM4drainPerimeter < 0.0)
                begin
                    $strobe("Warning: Drain Perimeter is specified as negative, it is set to zero.\n");
                    BSIM4Pdeff = 0.0;
                end else begin
                    if (BSIM4perMod == 0)
                        BSIM4Pdeff = BSIM4drainPerimeter;
                    else
                        BSIM4Pdeff = BSIM4drainPerimeter - BSIM4weffCJ * BSIM4nf;
                end
            end
            else begin /* not given */
                `BSIM4PAeffGeo(BSIM4nf, BSIM4geoMod, BSIM4min, BSIM4weffCJ, DMCGeff, DMCIeff, DMDGeff, dumPs, BSIM4Pdeff, dumAs, dumAd)
            end

            /*New Diode v4.7*/
            if (BSIM4Pdeff < 0.0) begin
                BSIM4Pdeff = 0.0;
                $strobe("Warning: Pdeff is negative, it is set to zero.\n");
            end
            if ($param_given(as))
                BSIM4Aseff = BSIM4sourceArea;
            else begin
                `BSIM4PAeffGeo(BSIM4nf, BSIM4geoMod, BSIM4min, BSIM4weffCJ, DMCGeff, DMCIeff, DMDGeff, dumPs, dumPd, BSIM4Aseff, dumAd)
            end
            if (BSIM4Aseff < 0.0) begin
                BSIM4Aseff = 0.0; /* v4.7 */
                $strobe("Warning: Aseff is negative, it is set to zero.\n");
            end
            if ($param_given(ad))
                BSIM4Adeff = BSIM4drainArea;
            else begin
                `BSIM4PAeffGeo(BSIM4nf, BSIM4geoMod, BSIM4min, BSIM4weffCJ, DMCGeff, DMCIeff, DMDGeff, dumPs, dumPd, dumAs, BSIM4Adeff)
            end
            if (BSIM4Adeff < 0.0) begin
                BSIM4Adeff = 0.0; /* v4.7 */
                $strobe("Warning: Adeff is negative, it is set to zero.\n");
            end

            /* Processing S/D resistance and conductance below */
            //VA: if   (BSIM4sNodePrime != BSIM4sNode)
            BSIM4sourceConductance = 0.0;
            if ($param_given(nrs)) begin
                BSIM4sourceConductance = BSIM4sheetResistance * BSIM4sourceSquares;
            end
            else if (BSIM4rgeoMod > 0) begin
                `BSIM4RdseffGeo(BSIM4nf, BSIM4geoMod, BSIM4rgeoMod, BSIM4min, BSIM4weffCJ, BSIM4sheetResistance, DMCGeff, DMCIeff, DMDGeff, 1, BSIM4sourceConductance)
            end
            else
                BSIM4sourceConductance = 0.0;

            if (BSIM4sourceConductance > 0.0)
                BSIM4sourceConductance = 1.0 / BSIM4sourceConductance;
            else begin
                //if (BSIM4sourceConductance == 0.0 ) begin /*TODO: always keeps internal nodes,we used all full static nodes at setup.*/
                if (BSIM4sourceConductance == 0.0 && (BSIM4rsh > 0
                    && (!$param_given(nrs) && BSIM4rgeoMod != 0)
                    || BSIM4rdsMod != 0) ) begin
                    BSIM4sourceConductance = 1.0e3; /* mho */
                    $strobe ("Warning: (instance X*) Source diffusion conductance reset to 1.0e3 mho.\n");
                end
            end

            //VA: if (BSIM4dNodePrime != BSIM4dNode)
            BSIM4drainConductance = 0.0;
            if ($param_given(nrd))
                BSIM4drainConductance = BSIM4sheetResistance * BSIM4drainSquares;
            else if (BSIM4rgeoMod > 0) begin
                `BSIM4RdseffGeo(BSIM4nf, BSIM4geoMod, BSIM4rgeoMod, BSIM4min, BSIM4weffCJ, BSIM4sheetResistance, DMCGeff, DMCIeff, DMDGeff, 0, BSIM4drainConductance)
            end
            else
                BSIM4drainConductance = 0.0;

            if (BSIM4drainConductance > 0.0)
                BSIM4drainConductance = 1.0 / BSIM4drainConductance;
            else begin
                //if (BSIM4drainConductance == 0.0 ) begin /*TODO: need to remove internal nodes? but we used all full static nodes at setup.*/
                if (BSIM4drainConductance == 0.0 && (BSIM4rsh > 0
                    && (!$param_given(nrd) && BSIM4rgeoMod != 0)
                    || BSIM4rdsMod != 0 ) ) begin
                    BSIM4drainConductance = 1.0e3; /* mho */
                    $strobe ("Warning: (instance X*) Drain diffusion conductance reset to 1.0e3 mho.\n");
                end
            end

            if (verbose == 1) begin
                $strobe("BSIM4geoMod, BSIM4rgeoMod, d/s-conductance=%d,%d,%e,%e\n",BSIM4geoMod, BSIM4rgeoMod,BSIM4drainConductance,BSIM4sourceConductance);
                $strobe("ps,pd,ad,as(given):%e,%e,%d,%e,%e,%d,%e,%e,%d,%e,%e,%d\n",
                  BSIM4Pseff,BSIM4sourcePerimeter,$param_given(ps),
                  BSIM4Pdeff,BSIM4drainPerimeter,$param_given(pd),
                  BSIM4Adeff,BSIM4drainArea,$param_given(ad),
                  BSIM4Aseff,BSIM4sourceArea,$param_given(as));
            end
            /* End of Rsd processing */

            Nvtms = BSIM4vtm * BSIM4SjctEmissionCoeff;
            if ((BSIM4Aseff <= 0.0) && (BSIM4Pseff <= 0.0))
                //SourceSatCurrent = 1.0e-14;
                SourceSatCurrent = 0.0; /* v4.7 */
            else
                SourceSatCurrent = BSIM4Aseff * BSIM4SjctTempSatCurDensity
                       + BSIM4Pseff * BSIM4SjctSidewallTempSatCurDensity
                       + BSIM4weffCJ * BSIM4nf
                       * BSIM4SjctGateSidewallTempSatCurDensity;

            if (SourceSatCurrent > 0.0) begin
                case (BSIM4dioMod)
                    0: begin
                        if ((BSIM4bvs / Nvtms) > `EXP_THRESHOLD)
                            BSIM4XExpBVS = BSIM4xjbvs * `MIN_EXP;
                        else
                            BSIM4XExpBVS = BSIM4xjbvs * exp(-BSIM4bvs / Nvtms);
                    end // case: 0
                    1: begin
                        BSIM4vjsmFwd=BSIM4DioIjthVjmEval(Nvtms, BSIM4ijthsfwd, SourceSatCurrent, 0.0);
                        BSIM4IVjsmFwd = SourceSatCurrent * exp(BSIM4vjsmFwd / Nvtms);
                    end
                    2: begin
                        if ((BSIM4bvs / Nvtms) > `EXP_THRESHOLD)
                        begin
                            BSIM4XExpBVS = BSIM4xjbvs * `MIN_EXP;
                            tmp = `MIN_EXP;
                        end
                        else begin
                            BSIM4XExpBVS = exp(-BSIM4bvs / Nvtms);
                            tmp = BSIM4XExpBVS;
                            BSIM4XExpBVS = BSIM4XExpBVS * (  BSIM4xjbvs);
                        end
                        BSIM4vjsmFwd=BSIM4DioIjthVjmEval(Nvtms, BSIM4ijthsfwd, SourceSatCurrent, BSIM4XExpBVS);
                        T0 = exp(BSIM4vjsmFwd / Nvtms);
                        BSIM4IVjsmFwd = SourceSatCurrent * (T0 - BSIM4XExpBVS / T0
                        + BSIM4XExpBVS - 1.0);
                        BSIM4SslpFwd = SourceSatCurrent
                        * (T0 + BSIM4XExpBVS / T0) / Nvtms;

                        T2 = BSIM4ijthsrev / SourceSatCurrent;
                        if (T2 < 1.0) begin
                            T2 = 10.0;
                            $strobe("Warning: (instance X*) ijthsrev too small and set to 10 times IsbSat.\n");
                        end
                        BSIM4vjsmRev = -BSIM4bvs
                        - Nvtms * ln((T2 - 1.0) / BSIM4xjbvs);
                        T1 = BSIM4xjbvs * exp(-(BSIM4bvs
                        + BSIM4vjsmRev) / Nvtms);
                        BSIM4IVjsmRev = SourceSatCurrent * (1.0 + T1);
                        BSIM4SslpRev = -SourceSatCurrent * T1 / Nvtms;
                    end
                    default:
                    $strobe("Specified dioMod = %d not matched\n", BSIM4dioMod);
                endcase

                Nvtmd = BSIM4vtm * BSIM4DjctEmissionCoeff;
                if ((BSIM4Adeff <= 0.0) && (BSIM4Pdeff <= 0.0))
                    /* DrainSatCurrent = 1.0e-14; v4.7 */
                    DrainSatCurrent = 0.0;
                else
                    DrainSatCurrent = BSIM4Adeff * BSIM4DjctTempSatCurDensity
                        + BSIM4Pdeff * BSIM4DjctSidewallTempSatCurDensity
                        + BSIM4weffCJ * BSIM4nf
                        * BSIM4DjctGateSidewallTempSatCurDensity;
            end

            if (DrainSatCurrent > 0.0) begin
                case (BSIM4dioMod)
                    0: begin
                        if ((BSIM4bvd / Nvtmd) > `EXP_THRESHOLD)
                            BSIM4XExpBVD = BSIM4xjbvd * `MIN_EXP;
                        else
                            BSIM4XExpBVD = BSIM4xjbvd * exp(-BSIM4bvd / Nvtmd);
                    end
                    1: begin
                        BSIM4vjdmFwd=BSIM4DioIjthVjmEval(Nvtmd, BSIM4ijthdfwd, DrainSatCurrent, 0.0);
                        BSIM4IVjdmFwd = DrainSatCurrent * exp(BSIM4vjdmFwd / Nvtmd);
                    end
                    2: begin
                        if ((BSIM4bvd / Nvtmd) > `EXP_THRESHOLD)
                            BSIM4XExpBVD = BSIM4xjbvd * `MIN_EXP;
                        else begin
                            BSIM4XExpBVD = exp(-BSIM4bvd / Nvtmd);
                            BSIM4XExpBVD = BSIM4XExpBVD * BSIM4xjbvd;
                        end
                        BSIM4vjdmFwd=BSIM4DioIjthVjmEval(Nvtmd, BSIM4ijthdfwd, DrainSatCurrent, BSIM4XExpBVD);

                        T0 = exp(BSIM4vjdmFwd / Nvtmd);
                        BSIM4IVjdmFwd = DrainSatCurrent * (T0 - BSIM4XExpBVD / T0
                                        + BSIM4XExpBVD - 1.0);
                        BSIM4DslpFwd = DrainSatCurrent
                                        * (T0 + BSIM4XExpBVD / T0) / Nvtmd;

                        T2 = BSIM4ijthdrev / DrainSatCurrent;
                        if (T2 < 1.0) begin
                            T2 = 10.0;
                            $strobe("Warning: (instance X*) ijthdrev too small and set to 10 times IdbSat.\n");
                        end
                        BSIM4vjdmRev = -BSIM4bvd - Nvtmd * ln((T2 - 1.0)
                                      / BSIM4xjbvd);
                        T1 = BSIM4xjbvd * exp(-(BSIM4bvd + BSIM4vjdmRev) / Nvtmd);
                        BSIM4IVjdmRev = DrainSatCurrent * (1.0 + T1);
                        BSIM4DslpRev = -DrainSatCurrent * T1 / Nvtmd;
                    end
                    default:
                    $strobe("Specified dioMod = %d not matched\n", BSIM4dioMod);
                endcase

            end
            /* GEDL current reverse bias */
            T0 = (TRatio - 1.0);
            BSIM4njtsstemp = BSIM4njts * (1.0 + BSIM4tnjts * T0);
            BSIM4njtsswstemp = BSIM4njtssw * (1.0 + BSIM4tnjtssw * T0);
            BSIM4njtsswgstemp = BSIM4njtsswg * (1.0 + BSIM4tnjtsswg * T0);
            BSIM4njtsdtemp = BSIM4njtsd * (1.0 + BSIM4tnjtsd * T0);
            BSIM4njtsswdtemp = BSIM4njtsswd * (1.0 + BSIM4tnjtsswd * T0);
            BSIM4njtsswgdtemp = BSIM4njtsswgd * (1.0 + BSIM4tnjtsswgd * T0);
            T7 = Eg0 / BSIM4vtm * T0;
            T9 = BSIM4xtss * T7;
            `DEXP(T9, T1)
            T9 = BSIM4xtsd * T7;
            `DEXP(T9, T2)
            T9 = BSIM4xtssws * T7;
            `DEXP(T9, T3)
            T9 = BSIM4xtsswd * T7;
            `DEXP(T9, T4)
            T9 = BSIM4xtsswgs * T7;
            `DEXP(T9, T5)
            T9 = BSIM4xtsswgd * T7;
            `DEXP(T9, T6)
            /*IBM TAT*/
            if (BSIM4jtweff < 0.0) begin
                BSIM4jtweff = 0.0;
                $strobe("TAT width dependence effect is negative. Jtweff is clamped to zero.\n");
            end
            T11 = sqrt(BSIM4jtweff / BSIM4weffCJ) + 1.0;

            T10 = BSIM4weffCJ * BSIM4nf;
            BSIM4SjctTempRevSatCur = T1 * BSIM4Aseff * BSIM4jtss;
            BSIM4DjctTempRevSatCur = T2 * BSIM4Adeff * BSIM4jtsd;
            BSIM4SswTempRevSatCur = T3 * BSIM4Pseff * BSIM4jtssws;
            BSIM4DswTempRevSatCur = T4 * BSIM4Pdeff * BSIM4jtsswd;
            BSIM4SswgTempRevSatCur = T5 * T10 * T11 * BSIM4jtsswgs;
            BSIM4DswgTempRevSatCur = T6 * T10 * T11 * BSIM4jtsswgd;

            if (BSIM4mtrlmod != 0 && BSIM4mtrlcompatmod == 0)
            begin
                /* Calculate TOXP from EOT */
                /* Calculate Vgs_eff @ Vgs = VDD with Poly Depletion Effect */
                Vtm0eot = `KboQ * BSIM4tempeot;
                Vtmeot  = Vtm0eot;
                vbieot = Vtm0eot * ln(BSIM4nsd
                * BSIM4ndep / (ni * ni));
                phieot = Vtm0eot * ln(BSIM4ndep / ni)
                + BSIM4phin + 0.4;
                tmp2 = BSIM4vfb + phieot;
                vddeotl = BSIM4type * BSIM4vddeot;
                T0 = BSIM4epsrgate * `EPS0;
                if ((BSIM4ngate > 1.0e18) && (BSIM4ngate < 1.0e25)
                    && (vddeotl > tmp2) && (T0!=0))
                begin
                    T1 = 1.0e6 * `P_Q * T0 * BSIM4ngate /
                    (BSIM4coxe * BSIM4coxe);
                    T8 = vddeotl - tmp2;
                    T4 = sqrt(1.0 + 2.0 * T8 / T1);
                    T2 = 2.0 * T8 / (T4 + 1.0);
                    T3 = 0.5 * T2 * T2 / T1;
                    T7 = 1.12 - T3 - 0.05;
                    T6 = sqrt(T7 * T7 + 0.224);
                    T5 = 1.12 - 0.5 * (T7 + T6);
                    Vgs_eff = vddeotl - T5;
                end
                else
                    Vgs_eff = vddeotl;

                /* Calculate Vth @ Vds=Vbs=0 */

                V0 = vbieot - phieot;
                lt1 = BSIM4factor1* BSIM4sqrtXdep0;
                ltw = lt1;
                T0 = BSIM4dvt1 * BSIM4leffeot / lt1;
                if (T0 < `EXP_THRESHOLD)
                begin
                    T1 = exp(T0);
                    T2 = T1 - 1.0;
                    T3 = T2 * T2;
                    T4 = T3 + 2.0 * T1 * `MIN_EXP;
                    Theta0 = T1 / T4;
                end
                else
                    Theta0 = 1.0 / (`MAX_EXP - 2.0);
                Delt_vth = BSIM4dvt0 * Theta0 * V0;
                T0 = BSIM4dvt1w * BSIM4weffeot * BSIM4leffeot / ltw;
                if (T0 < `EXP_THRESHOLD) begin
                    T1 = exp(T0);
                    T2 = T1 - 1.0;
                    T3 = T2 * T2;
                    T4 = T3 + 2.0 * T1 * `MIN_EXP;
                    T5 = T1 / T4;
                end
                else
                    T5 = 1.0 / (`MAX_EXP - 2.0); /* 3.0 * MIN_EXP omitted */
                T2 = BSIM4dvt0w * T5 * V0;
                TempRatioeot =  BSIM4tempeot / BSIM4tnom - 1.0;
                T0 = sqrt(1.0 + BSIM4lpe0 / BSIM4leffeot);
                T1 = BSIM4k1ox * (T0 - 1.0) * sqrt(phieot)
                + (BSIM4kt1 + BSIM4kt1l / BSIM4leffeot) * TempRatioeot;
                Vth_NarrowW = toxel * phieot
                / (BSIM4weffeot + BSIM4w0);
                Lpe_Vb = sqrt(1.0 + BSIM4lpeb / BSIM4leffeot);
                Vth = BSIM4type * BSIM4vth0 +
                (BSIM4k1ox - BSIM4k1)*sqrt(phieot)*Lpe_Vb
                - Delt_vth - T2 + BSIM4k3 * Vth_NarrowW + T1;

                /* Calculate n */
                tmp1 = epssubl / BSIM4Xdep0;
                tmp2 = BSIM4nfactor * tmp1;
                tmp3 = (tmp2 + BSIM4cdsc * Theta0 + BSIM4cit) / BSIM4coxe;
                if (tmp3 >= -0.5)
                    n = 1.0 + tmp3;
                else begin
                    T0 = 1.0 / (3.0 + 8.0 * tmp3);
                    n = (1.0 + 3.0 * tmp3) * T0;
                end

                /* Vth correction for Pocket implant */
                if (BSIM4dvtp0 > 0.0)
                begin
                    T3 = BSIM4leffeot + BSIM4dvtp0 * 2.0;
                    if (BSIM4tempMod < 2)
                        T4 = Vtmeot * ln(BSIM4leffeot / T3);
                    else
                        T4 = Vtm0eot * ln(BSIM4leffeot / T3);
                    Vth = Vth - n * T4;
                end
                Vgsteff = Vgs_eff-Vth;
                /* calculating Toxp */
                T3 = BSIM4type * BSIM4vth0 - BSIM4vfb - phieot;
                T4 = T3 + T3;
                T5 = 2.5 * T3;

                vtfbphi2eot = 4.0 * T3;
                if (vtfbphi2eot < 0.0)
                    vtfbphi2eot = 0.0;

                niter = 0;
                toxpf = toxel;
                toxpi = 0.0;
                while ((niter<=4) && (abs(toxpf-toxpi)>1e-12))
                begin
                    toxpi = toxpf;
                    tmp2 = 2.0e8 * toxpf;
                    T0 = (Vgsteff + vtfbphi2eot) / tmp2;
                    T1 = 1.0 + exp(BSIM4bdos * 0.7 * ln(T0));
                    Tcen = BSIM4ados * 1.9e-9 / T1;
                    toxpf = toxel - epsroxl/BSIM4epsrsub * Tcen;
                    niter = niter+1;
                    if (verbose == 1)
                        $strobe("niter,toxpf,toxpi=%g,%g,%g\n",niter,toxpf,toxpi);
                end
                BSIM4toxp = toxpf;  //changed code order to fix
                BSIM4coxp = epsroxl * `EPS0 / BSIM4toxp;
            end
            //else {
            //    here->BSIM4toxp = model->BSIM4toxp;
            //    here->BSIM4coxp = model->BSIM4coxp;
            //}
            if (verbose == 1) begin
                $strobe("New model param check starts...\n");
                $strobe("Topology Selection: rdsmod=%d rgatemod=%d rbodymod=%d\n", BSIM4rdsMod, BSIM4rgateMod, BSIM4rbodyMod);
            end
            if ((BSIM4version-4.8) > 0.0001)
                $strobe("\nWarning: (instance X*) The latest version is BSIM4.8.0; you specified a wrong version number.\n");

            if ((BSIM4rgateMod == 2) || (BSIM4rgateMod == 3)) begin
                if ((BSIM4trnqsMod == 1) || (BSIM4acnqsMod == 1))
                    $strobe("Warning: (instance X*) You've selected both Rg and charge deficit NQS; select one only.\n");
            end

            if (BSIM4toxe <= 0.0) begin
                $strobe("Fatal: Toxe = %g is not positive.\n", BSIM4toxe);
                Fatal_Flag = 1;
            end
            if (BSIM4toxp <= 0.0) begin
                $strobe("Fatal: Toxp = %g is not positive.\n", BSIM4toxp);
                Fatal_Flag = 1;
            end
            if (BSIM4eot <= 0.0) begin
                $strobe("Fatal: EOT = %g is not positive.\n", BSIM4eot);
                Fatal_Flag = 1;
            end
            if (BSIM4epsrgate < 0.0)
            begin
                $strobe("Fatal: Epsrgate = %g is not positive.\n", BSIM4epsrgate);
                Fatal_Flag = 1;
            end
            if (BSIM4epsrsub < 0.0)
            begin
                $strobe("Fatal: Epsrsub = %g is not positive.\n", BSIM4epsrsub);
                Fatal_Flag = 1;
            end
            if (BSIM4easub < 0.0)
            begin
                $strobe("Fatal: Easub = %g is not positive.\n", BSIM4easub);
                Fatal_Flag = 1;
            end
            if (BSIM4ni0sub <= 0.0)
            begin
                $strobe("Fatal: Easub = %g is not positive.\n", BSIM4ni0sub);
                Fatal_Flag = 1;
            end

            if (BSIM4toxm <= 0.0)
            begin
                $strobe("Fatal: Toxm = %g is not positive.\n", BSIM4toxm);
                Fatal_Flag = 1;
            end

            if (BSIM4toxref <= 0.0) begin
                $strobe("Fatal: Toxref = %g is not positive.\n", BSIM4toxref);
                Fatal_Flag = 1;
            end

            if (BSIM4lpe0 < -BSIM4leff) begin
                $strobe("Fatal: Lpe0 = %g is less than -Leff.\n", BSIM4lpe0);
                Fatal_Flag = 1;
            end
            if (BSIM4lpeb < -BSIM4leff) begin
                $strobe("Fatal: Lpeb = %g is less than -Leff.\n", BSIM4lpeb);
                Fatal_Flag = 1;
            end

            if (BSIM4phin < -0.4) begin
                $strobe("Fatal: Phin = %g is less than -0.4.\n", BSIM4phin);
                Fatal_Flag = 1;
            end
            if (BSIM4ndep <= 0.0) begin
                $strobe("Fatal: Ndep = %g is not positive.\n", BSIM4ndep);
                Fatal_Flag = 1;
            end
            if (BSIM4phi <= 0.0)
            begin
                $strobe("Fatal: Phi = %g is not positive. Please check Phin and Ndep\n", BSIM4phi);
                $strobe("      Phin = %g  Ndep = %g \n",
                BSIM4phin, BSIM4ndep);
                Fatal_Flag = 1;
            end

            if (BSIM4nsub <= 0.0) begin
                $strobe("Fatal: Nsub = %g is not positive.\n", BSIM4nsub);
                Fatal_Flag = 1;
            end

            if (BSIM4ngate < 0.0) begin
                $strobe("Fatal: Ngate = %g Ngate is not positive.\n", BSIM4ngate);
                Fatal_Flag = 1;
            end
            if (BSIM4ngate > 1.0e25) begin
                $strobe("Fatal: Ngate = %g Ngate is too high\n", BSIM4ngate);
                Fatal_Flag = 1;
            end
            if (BSIM4xj <= 0.0) begin
                $strobe("Fatal: Xj = %g is not positive.\n", BSIM4xj);
                Fatal_Flag = 1;
            end
            if (BSIM4dvt1 < 0.0) begin
                $strobe("Fatal: Dvt1 = %g is negative.\n", BSIM4dvt1);
                Fatal_Flag = 1;
            end
            if (BSIM4dvt1w < 0.0) begin
                $strobe("Fatal: Dvt1w = %g is negative.\n", BSIM4dvt1w);
                Fatal_Flag = 1;
            end
            if (BSIM4w0 == -BSIM4weff) begin
                $strobe("Fatal: (W0 + Weff) = 0 causing divided-by-zero.\n");
                Fatal_Flag = 1;
            end
            if (BSIM4dsub < 0.0) begin
                $strobe("Fatal: Dsub = %g is negative.\n", BSIM4dsub);
                Fatal_Flag = 1;
            end
            if (BSIM4b1 == -BSIM4weff) begin
                $strobe("Fatal: (B1 + Weff) = 0 causing divided-by-zero.\n");
                Fatal_Flag = 1;
            end
            if (here_BSIM4u0temp <= 0.0) begin
                $strobe("Fatal: u0 at current temperature = %g is not positive.\n", here_BSIM4u0temp);
                Fatal_Flag = 1;
            end
            if (BSIM4delta < 0.0) begin
                $strobe("Fatal: Delta = %g is less than zero.\n", BSIM4delta);
                Fatal_Flag = 1;
            end
            if (here_BSIM4vsattemp <= 0.0) begin
                $strobe("Fatal: Vsat at current temperature = %g is not positive.\n", here_BSIM4vsattemp);
                Fatal_Flag = 1;
            end
            if (BSIM4pclm <= 0.0) begin
                $strobe("Fatal: Pclm = %g is not positive.\n", BSIM4pclm);
                Fatal_Flag = 1;
            end
            if (BSIM4drout < 0.0) begin
                $strobe("Fatal: Drout = %g is negative.\n", BSIM4drout);
                Fatal_Flag = 1;
            end
            if (BSIM4pscbe2 <= 0.0) begin
                $strobe("Warning: (instance X*) Pscbe2 = %g is not positive.\n", BSIM4pscbe2);
            end

            if (BSIM4nf < 1.0) begin
                $strobe("Fatal: Number of finger = %g is smaller than one.\n", BSIM4nf);
                Fatal_Flag = 1;
            end
            if ((BSIM4sa > 0.0) && (BSIM4sb > 0.0) &&
                ((BSIM4nf == 1.0) || ((BSIM4nf > 1.0) && (BSIM4sd > 0.0))) )
            begin
                if (BSIM4saref <= 0.0)
                begin
                    $strobe("Fatal: SAref = %g is not positive.\n",BSIM4saref);
                    Fatal_Flag = 1;
                end
                if (BSIM4sbref <= 0.0)
                begin
                    $strobe("Fatal: SBref = %g is not positive.\n",BSIM4sbref);
                    Fatal_Flag = 1;
                end
            end
            if ((BSIM4l + BSIM4xl) <= BSIM4xgl) begin
                $strobe("Fatal: The parameter xgl must be smaller than Ldrawn+XL.\n");
                Fatal_Flag = 1;
            end
            if (BSIM4ngcon < 1.0) begin
                $strobe("Fatal: The parameter ngcon cannot be smaller than one.\n");
                Fatal_Flag = 1;
            end
            if ((BSIM4ngcon != 1.0) && (BSIM4ngcon != 2.0)) begin
                BSIM4ngcon = 1.0;
                $strobe("Warning: (instance X*) Ngcon must be equal to one or two; reset to 1.0.\n");
            end
            if (BSIM4gbmin < 1.0e-20)
                $strobe("Warning: (instance X*) Gbmin = %g is too small.\n", BSIM4gbmin);
            if (BSIM4noff < 0.1)
                $strobe("Warning: (instance X*) Noff = %g is too small.\n", BSIM4noff);
            if (BSIM4noff > 4.0)
                $strobe("Warning: (instance X*) Noff = %g is too large.\n", BSIM4noff);
            if (BSIM4voffcv < -0.5)
                $strobe("Warning: (instance X*) Voffcv = %g is too small.\n", BSIM4voffcv);
            if (BSIM4voffcv > 0.5)
                $strobe("Warning: (instance X*) Voffcv = %g is too large.\n", BSIM4voffcv);

            /* Check capacitance parameters */
            if (BSIM4clc < 0.0) begin
                $strobe("Fatal: Clc = %g is negative.\n", BSIM4clc);
                Fatal_Flag = 1;
            end
            /* Check overlap capacitance parameters */
            if (BSIM4ckappas < 0.02)
            begin
                $strobe("Warning: ckappas = %g is too small.\n", BSIM4ckappas);
                BSIM4ckappas = 0.02;
            end
            if (BSIM4ckappad < 0.02)
            begin
                $strobe("Warning: ckappad = %g is too small.\n", BSIM4ckappad);
                BSIM4ckappad = 0.02;
            end
            if (BSIM4vtss < 0.0)
            begin
                $strobe("Fatal: Vtss = %g is negative.\n",
                BSIM4vtss);
                Fatal_Flag = 1;
            end
            if (BSIM4vtsd < 0.0)
            begin
                $strobe("Fatal: Vtsd = %g is negative.\n",
                BSIM4vtsd);
                Fatal_Flag = 1;
            end
            if (BSIM4vtssws < 0.0)
            begin
                $strobe("Fatal: Vtssws = %g is negative.\n",
                BSIM4vtssws);
                Fatal_Flag = 1;
            end
            if (BSIM4vtsswd < 0.0)
            begin
                $strobe("Fatal: Vtsswd = %g is negative.\n",
                BSIM4vtsswd);
                Fatal_Flag = 1;
            end
            if (BSIM4vtsswgs < 0.0)
            begin
                $strobe("Fatal: Vtsswgs = %g is negative.\n",
                BSIM4vtsswgs);
                Fatal_Flag = 1;
            end
            if (BSIM4vtsswgd < 0.0)
            begin
                $strobe("Fatal: Vtsswgd = %g is negative.\n",
                BSIM4vtsswgd);
                Fatal_Flag = 1;
            end

            if (BSIM4moin < 5.0)
                $strobe("Warning: (instance X*) Moin = %g is too small.\n", BSIM4moin);
            if (BSIM4moin > 25.0)
                $strobe("Warning: (instance X*) Moin = %g is too large.\n", BSIM4moin);
            if (BSIM4capMod ==2) begin
                if (BSIM4acde < 0.1)
                    $strobe("Warning: (instance X*) Acde = %g is too small.\n", BSIM4acde);
                if (BSIM4acde > 1.6)
                    $strobe("Warning: (instance X*) Acde = %g is too large.\n", BSIM4acde);
            end

            if (BSIM4paramChk ==1) begin

                /* Check L and W parameters */
                if (BSIM4leff <= 1.0e-9)
                    $strobe("Warning: (instance X*) Leff = %g <= 1.0e-9. Recommended Leff >= 1e-8 \n", BSIM4leff);
                if (BSIM4leffCV <= 1.0e-9)
                    $strobe("Warning: (instance X*) Leff for CV = %g <= 1.0e-9. Recommended LeffCV >=1e-8 \n", BSIM4leffCV);
                if (BSIM4weff <= 1.0e-9)
                    $strobe("Warning: (instance X*) Weff = %g <= 1.0e-9. Recommended Weff >=1e-7 \n", BSIM4weff);
                if (BSIM4weffCV <= 1.0e-9)
                    $strobe("Warning: (instance X*) Weff for CV = %g <= 1.0e-9. Recommended WeffCV >= 1e-7 \n", BSIM4weffCV);

                /* Check threshold voltage parameters */
                if (BSIM4toxe < 1.0e-10)
                    $strobe("Warning: (instance X*) Toxe = %g is less than 1A. Recommended Toxe >= 5A\n", BSIM4toxe);
                if (BSIM4toxp < 1.0e-10)
                    $strobe("Warning: (instance X*) Toxp = %g is less than 1A. Recommended Toxp >= 5A\n", BSIM4toxp);
                if (BSIM4toxm < 1.0e-10)
                    $strobe("Warning: (instance X*) Toxm = %g is less than 1A. Recommended Toxm >= 5A\n", BSIM4toxm);
                if (BSIM4ndep <= 1.0e12)
                    $strobe("Warning: (instance X*) Ndep = %g may be too small.\n", BSIM4ndep);
                else if (BSIM4ndep >= 1.0e21)
                    $strobe("Warning: (instance X*) Ndep = %g may be too large.\n", BSIM4ndep);
                if (BSIM4nsub <= 1.0e14)
                    $strobe("Warning: (instance X*) Nsub = %g may be too small.\n", BSIM4nsub);
                else if (BSIM4nsub >= 1.0e21)
                    $strobe("Warning: (instance X*) Nsub = %g may be too large.\n", BSIM4nsub);
                if ((BSIM4ngate > 0.0) &&  (BSIM4ngate <= 1.0e18))
                    $strobe("Warning: (instance X*) Ngate = %g is less than 1.E18cm^-3.\n", BSIM4ngate);
                if (BSIM4dvt0 < 0.0)
                    $strobe("Warning: (instance X*) Dvt0 = %g is negative.\n", BSIM4dvt0);
                if (abs(1.0e-6 / (BSIM4w0 + BSIM4weff)) > 10.0)
                    $strobe("Warning: (instance X*) (W0 + Weff) may be too small.\n");

                /* Check subthreshold parameters */
                if (BSIM4nfactor < 0.0)
                begin
                    $strobe("Warning: (instance X*) Nfactor = %g is negative.\n", BSIM4nfactor);
                end
                if (BSIM4cdsc < 0.0)
                begin
                    $strobe("Warning: (instance X*) Cdsc = %g is negative.\n", BSIM4cdsc);
                end
                if (BSIM4cdscd < 0.0)
                begin
                    $strobe("Warning: (instance X*) Cdscd = %g is negative.\n", BSIM4cdscd);
                end
                /* Check DIBL parameters */
                if (BSIM4eta0 < 0.0)
                begin
                    $strobe("Warning: (instance X*) Eta0 = %g is negative.\n", BSIM4eta0);
                end

                /* Check Abulk parameters */
                if (abs(1.0e-6 / (BSIM4b1 + BSIM4weff)) > 10.0)
                begin
                    $strobe("Warning: (instance X*) (B1 + Weff) may be too small.\n");
                end

                /* Check Saturation parameters */
                if (BSIM4a2 < 0.01)
                begin
                    $strobe("Warning: (instance X*) A2 = %g is too small. Set to 0.01.\n", BSIM4a2);
                    BSIM4a2 = 0.01;
                end
                else if (BSIM4a2 > 1.0)
                begin
                    $strobe("Warning: (instance X*) A2 = %g is larger than 1. A2 is set to 1 and A1 is set to 0.\n", BSIM4a2);
                    BSIM4a2 = 1.0;
                    BSIM4a1 = 0.0;

                end

                if (BSIM4prwg < 0.0)
                begin
                    $strobe("Warning: (instance X*) Prwg = %g is negative. Set to zero.\n", BSIM4prwg);
                    BSIM4prwg = 0.0;
                end
                if (BSIM4rdsw < 0.0)
                begin
                    $strobe("Warning: (instance X*) Rdsw = %g is negative. Set to zero.\n", BSIM4rdsw);
                    BSIM4rdsw = 0.0;
                    BSIM4rds0 = 0.0;
                end
                if (BSIM4rds0 < 0.0)
                begin
                    $strobe("Warning: (instance X*) Rds at current temperature = %g is negative. Set to zero.\n", BSIM4rds0);
                    BSIM4rds0 = 0.0;
                end

                if (BSIM4rdswmin < 0.0)
                begin
                    $strobe("Warning: (instance X*) Rdswmin at current temperature = %g is negative. Set to zero.\n", BSIM4rdswmin);
                    BSIM4rdswmin = 0.0;
                end

                if (BSIM4vsattemp < 1.0e3)
                begin
                    $strobe("Warning: (instance X*) Vsat at current temperature = %g may be too small.\n", BSIM4vsattemp);
                end

                if (BSIM4fprout < 0.0)
                begin
                    $strobe("Fatal: fprout = %g is negative.\n", BSIM4fprout);
                    Fatal_Flag = 1;
                end
                if (BSIM4pdits < 0.0)
                begin
                    $strobe("Fatal: pdits = %g is negative.\n", BSIM4pdits);
                    Fatal_Flag = 1;
                end
                if (BSIM4pditsl < 0.0)
                begin
                    $strobe("Fatal: pditsl = %g is negative.\n", BSIM4pditsl);
                    Fatal_Flag = 1;
                end

                if (BSIM4pdibl1 < 0.0)
                begin
                    $strobe("Warning: (instance X*) Pdibl1 = %g is negative.\n", BSIM4pdibl1);
                end
                if (BSIM4pdibl2 < 0.0)
                begin
                    $strobe("Warning: (instance X*) Pdibl2 = %g is negative.\n", BSIM4pdibl2);
                end

                if (BSIM4nigbinv <= 0.0)
                begin
                    $strobe("Fatal: nigbinv = %g is non-positive.\n", BSIM4nigbinv);
                    Fatal_Flag = 1;
                end
                if (BSIM4nigbacc <= 0.0)
                begin
                    $strobe("Fatal: nigbacc = %g is non-positive.\n", BSIM4nigbacc);
                    Fatal_Flag = 1;
                end
                if (BSIM4nigc <= 0.0)
                begin
                    $strobe("Fatal: nigc = %g is non-positive.\n", BSIM4nigc);
                    Fatal_Flag = 1;
                end
                if (BSIM4poxedge <= 0.0)
                begin
                    $strobe("Fatal: poxedge = %g is non-positive.\n", BSIM4poxedge);
                    Fatal_Flag = 1;
                end
                if (BSIM4pigcd <= 0.0)
                begin
                    $strobe("Fatal: pigcd = %g is non-positive.\n", BSIM4pigcd);
                    Fatal_Flag = 1;
                end

                /* Check stress effect parameters */
                if ((BSIM4sa > 0.0) && (BSIM4sb > 0.0) &&
                    ((BSIM4nf == 1.0) || ((BSIM4nf > 1.0) && (BSIM4sd > 0.0))) )
                begin
                    if (BSIM4lodk2 <= 0.0)
                    begin
                        $strobe("Warning: LODK2 = %g is not positive.\n",BSIM4lodk2);
                    end
                    if (BSIM4lodeta0 <= 0.0)
                    begin
                        $strobe("Warning: LODETA0 = %g is not positive.\n",BSIM4lodeta0);
                    end
                end

                /* Check gate resistance parameters */
                if (BSIM4rgateMod == 1)
                begin   if (BSIM4rshg <= 0.0)
                    $strobe("Warning: rshg should be positive for rgateMod = 1.\n");
                end
                else if (BSIM4rgateMod == 2)
                begin
                    if (BSIM4rshg <= 0.0)
                        $strobe("Warning: rshg <= 0.0 for rgateMod = 2.\n");
                    else if (BSIM4xrcrg1 <= 0.0)
                        $strobe("Warning: xrcrg1 <= 0.0 for rgateMod = 2.\n");
                end
                if (BSIM4rgateMod == 3)
                begin
                    if (BSIM4rshg <= 0.0)
                        $strobe("Warning: rshg should be positive for rgateMod = 3.\n");
                    else if (BSIM4xrcrg1 <= 0.0)
                        $strobe("Warning: xrcrg1 should be positive for rgateMod = 3.\n");
                end

                /* Check body resistance parameters */
                if (BSIM4rbps0 <= 0.0)
                begin
                    $strobe("Fatal: RBPS0 = %g is not positive.\n", BSIM4rbps0);
                    Fatal_Flag = 1;
                end
                if (BSIM4rbpd0 <= 0.0)
                begin
                    $strobe("Fatal: RBPD0 = %g is not positive.\n", BSIM4rbpd0);
                    Fatal_Flag = 1;
                end
                if (BSIM4rbpbx0 <= 0.0)
                begin
                    $strobe("Fatal: RBPBX0 = %g is not positive.\n", BSIM4rbpbx0);
                    Fatal_Flag = 1;
                end
                if (BSIM4rbpby0 <= 0.0)
                begin
                    $strobe("Fatal: RBPBY0 = %g is not positive.\n", BSIM4rbpby0);
                    Fatal_Flag = 1;
                end
                if (BSIM4rbdbx0 <= 0.0)
                begin
                    $strobe("Fatal: RBDBX0 = %g is not positive.\n", BSIM4rbdbx0);
                    Fatal_Flag = 1;
                end
                if (BSIM4rbdby0 <= 0.0)
                begin
                    $strobe("Fatal: RBDBY0 = %g is not positive.\n", BSIM4rbdby0);
                    Fatal_Flag = 1;
                end
                if (BSIM4rbsbx0 <= 0.0)
                begin
                    $strobe("Fatal: RBSBX0 = %g is not positive.\n", BSIM4rbsbx0);
                    Fatal_Flag = 1;
                end
                if (BSIM4rbsby0 <= 0.0)
                begin
                    $strobe("Fatal: RBSBY0 = %g is not positive.\n", BSIM4rbsby0);
                    Fatal_Flag = 1;
                end

                /* Check capacitance parameters */
                if (BSIM4noff < 0.1)
                    $strobe("Warning: Noff = %g is too small.\n", BSIM4noff);

                if (BSIM4voffcv < -0.5)
                    $strobe("Warning: Voffcv = %g is too small.\n", BSIM4voffcv);
                if (BSIM4moin < 5.0)
                    $strobe("Warning: Moin = %g is too small.\n", BSIM4moin);
                if (BSIM4moin > 25.0)
                    $strobe("Warning: Moin = %g is too large.\n", BSIM4moin);
                if (BSIM4capMod ==2) begin
                    if (BSIM4acde < 0.1)
                        $strobe("Warning: Acde = %g is too small.\n", BSIM4acde);
                    if (BSIM4acde > 1.6)
                        $strobe("Warning: Acde = %g is too large.\n", BSIM4acde);
                end

                /* Check overlap capacitance parameters */
                if (BSIM4cgdo < 0.0)
                begin
                    $strobe("Warning: (instance X*) cgdo = %g is negative. Set to zero.\n", BSIM4cgdo);
                    BSIM4cgdo = 0.0;
                end
                if (BSIM4cgso < 0.0)
                begin
                    $strobe("Warning: (instance X*) cgso = %g is negative. Set to zero.\n", BSIM4cgso);
                    BSIM4cgso = 0.0;
                end

                if (BSIM4tnoia < 0.0)
                begin
                    $strobe("Warning: (instance X*) tnoia = %g is negative. Set to zero.\n", BSIM4tnoia);
                    BSIM4tnoia = 0.0;
                end
                if (BSIM4tnoib < 0.0)
                begin
                    $strobe("Warning: (instance X*) tnoib = %g is negative. Set to zero.\n", BSIM4tnoib);
                    BSIM4tnoib = 0.0;
                end
                if (BSIM4ntnoi < 0.0)
                begin
                    $strobe("Warning: (instance X*) ntnoi = %g is negative. Set to zero.\n", BSIM4ntnoi);
                    BSIM4ntnoi = 0.0;
                end
                /* Limits of Njs and Njd modified in BSIM4.7 */
                if (BSIM4SjctEmissionCoeff < 0.1) begin
                    $strobe("Warning: Njs = %g is less than 0.1. Setting Njs to 0.1.\n", BSIM4SjctEmissionCoeff);
                    BSIM4SjctEmissionCoeff = 0.1;
                end
                else if (BSIM4SjctEmissionCoeff < 0.7) begin
                    $strobe("Warning: Njs = %g is less than 0.7.\n", BSIM4SjctEmissionCoeff);
                end
                if (BSIM4DjctEmissionCoeff < 0.1) begin
                    $strobe("Warning: Njd = %g is less than 0.1. Setting Njd to 0.1.\n", BSIM4DjctEmissionCoeff);
                    BSIM4DjctEmissionCoeff = 0.1;
                end
                else if (BSIM4DjctEmissionCoeff < 0.7) begin
                    $strobe("Warning: Njd = %g is less than 0.7.\n", BSIM4DjctEmissionCoeff);
                end

                if (BSIM4njtsstemp < 0.0)
                begin
                    $strobe("Warning: Njts = %g is negative at temperature = %g.\n",
                    BSIM4njtsstemp, T);
                end
                if (BSIM4njtsswstemp < 0.0)
                begin
                    $strobe("Warning: Njtssw = %g is negative at temperature = %g.\n",
                    BSIM4njtsswstemp, T);
                end
                if (BSIM4njtsswgstemp < 0.0)
                begin
                    $strobe("Warning: Njtsswg = %g is negative at temperature = %g.\n",
                    BSIM4njtsswgstemp, T);
                end

                if ($param_given(njtsd) && BSIM4njtsdtemp < 0.0)
                begin
                    $strobe("Warning: Njtsd = %g is negative at temperature = %g.\n",
                    BSIM4njtsdtemp, T);
                end
                if ($param_given(njtsswd) && BSIM4njtsswdtemp < 0.0)
                begin
                    $strobe("Warning: Njtsswd = %g is negative at temperature = %g.\n",
                    BSIM4njtsswdtemp, T);
                end
                if ($param_given(njtsswgd) && BSIM4njtsswgdtemp < 0.0)
                begin
                    $strobe("Warning: Njtsswgd = %g is negative at temperature = %g.\n",
                    BSIM4njtsswgdtemp, T);
                end

                if (BSIM4ntnoi < 0.0)
                begin
                    $strobe("Warning: ntnoi = %g is negative. Set to zero.\n", BSIM4ntnoi);
                    BSIM4ntnoi = 0.0;
                end

                /* diode model */
                if (BSIM4SbulkJctBotGradingCoeff >= 0.99)
                begin
                    $strobe("Warning: MJS = %g is too big. Set to 0.99.\n", BSIM4SbulkJctBotGradingCoeff);
                    BSIM4SbulkJctBotGradingCoeff = 0.99;
                end
                if (BSIM4SbulkJctSideGradingCoeff >= 0.99)
                begin
                    $strobe("Warning: MJSWS = %g is too big. Set to 0.99.\n", BSIM4SbulkJctSideGradingCoeff);
                    BSIM4SbulkJctSideGradingCoeff = 0.99;
                end
                if (BSIM4SbulkJctGateSideGradingCoeff >= 0.99)
                begin
                    $strobe("Warning: MJSWGS = %g is too big. Set to 0.99.\n", BSIM4SbulkJctGateSideGradingCoeff);
                    BSIM4SbulkJctGateSideGradingCoeff = 0.99;
                end

                if (BSIM4DbulkJctBotGradingCoeff >= 0.99)
                begin
                    $strobe("Warning: MJD = %g is too big. Set to 0.99.\n", BSIM4DbulkJctBotGradingCoeff);
                    BSIM4DbulkJctBotGradingCoeff = 0.99;
                end
                if (BSIM4DbulkJctSideGradingCoeff >= 0.99)
                begin
                    $strobe("Warning: MJSWD = %g is too big. Set to 0.99.\n", BSIM4DbulkJctSideGradingCoeff);
                    BSIM4DbulkJctSideGradingCoeff = 0.99;
                end
                if (BSIM4DbulkJctGateSideGradingCoeff >= 0.99)
                begin
                    $strobe("Warning: MJSWGD = %g is too big. Set to 0.99.\n", BSIM4DbulkJctGateSideGradingCoeff);
                    BSIM4DbulkJctGateSideGradingCoeff = 0.99;
                end
                if (BSIM4wpemod == 1)
                begin
                    if (BSIM4scref <= 0.0)
                    begin
                        $strobe("Warning: SCREF = %g is not positive. Set to 1e-6.\n", BSIM4scref);
                        BSIM4scref = 1e-6;
                    end

                end

            end // if (BSIM4paramChk ==1)
            else
                $strobe("Warning: (instance X*) Can't open log file; parameter checking skipped.\n");

        end // initial_step

        if (verbose == 1)
            $strobe("New model main evaluation starts...\n");
        //New model main evaluation starts

        // Get voltages:
        vds  = BSIM4type * V(di,si);
        vgs  = BSIM4type * V(gi,si);
        vbs  = BSIM4type * V(bi,si);
        vges = BSIM4type * V(g,si);
        vgms = BSIM4type * V(gm,si);
        //`ifdef __RBODYMOD__
        vdbs = BSIM4type * V(dbulk,si);
        vsbs = BSIM4type * V(sbulk,si);
        //`else
        //        vdbs = vbs;
        //        vsbs = vbs;
        //`endif
        vses = BSIM4type * V(s,si);
        vdes = BSIM4type * V(d,si);
        if (verbose == 1)
            $strobe("Volts:%g,%g,%g,%g,%g,%g,%g,%g,%g\n",vds,vgs,vbs,vges,vgms,vdbs,vsbs,vses,vdes);


        /* Calculate DC currents and their derivatives */
        vbd = vbs - vds;
        vgd = vgs - vds;
        vgb = vgs - vbs;
        vgmd = vgms - vds;
        vgmb = vgms - vbs;
        vdbd = vdbs - vds;

        vbs_jct = (!BSIM4rbodyMod) ? vbs : vsbs;
        vbd_jct = (!BSIM4rbodyMod) ? vbd : vdbd;

        /* Source/drain junction diode DC model begins */
        Nvtms = BSIM4vtm * BSIM4SjctEmissionCoeff;
        if ((BSIM4Aseff <= 0.0) && (BSIM4Pseff <= 0.0)) begin
            SourceSatCurrent = 0.0;
        end
        else begin
            SourceSatCurrent = BSIM4Aseff * BSIM4SjctTempSatCurDensity
                           + BSIM4Pseff * BSIM4SjctSidewallTempSatCurDensity
                           + BSIM4weffCJ * BSIM4nf
                           * BSIM4SjctGateSidewallTempSatCurDensity;
        end

        if (SourceSatCurrent <= 0.0) begin
            BSIM4gbs = `Gmin;
            BSIM4cbs = BSIM4gbs * vbs_jct;
        end
        else begin
            case (BSIM4dioMod)
                0: begin
                    evbs = exp(vbs_jct / Nvtms);
                    T1 = BSIM4xjbvs * exp(-(BSIM4bvs + vbs_jct) / Nvtms);
                    // WDLiu: Magic T1 in this form; different from BSIM4 beta.
                    BSIM4gbs = SourceSatCurrent * (evbs + T1) / Nvtms + `Gmin;
                    BSIM4cbs = SourceSatCurrent * (evbs + BSIM4XExpBVS
                    - T1 - 1.0) + `Gmin * vbs_jct;
                end
                1: begin
                    T2 = vbs_jct / Nvtms;
                    if (T2 < -`EXP_THRESHOLD) begin
                        BSIM4gbs = `Gmin;
                        BSIM4cbs = SourceSatCurrent * (`MIN_EXP - 1.0)
                                         + `Gmin * vbs_jct;
                    end
                    else if (vbs_jct <= BSIM4vjsmFwd) begin
                        evbs = exp(T2);
                        BSIM4gbs = SourceSatCurrent * evbs / Nvtms + `Gmin;
                        BSIM4cbs = SourceSatCurrent * (evbs - 1.0)
                                         + `Gmin * vbs_jct;
                    end
                    else begin
                        T0 = BSIM4IVjsmFwd / Nvtms;
                        BSIM4gbs = T0 + `Gmin;
                        BSIM4cbs = BSIM4IVjsmFwd - SourceSatCurrent + T0
                        * (vbs_jct - BSIM4vjsmFwd) + `Gmin * vbs_jct;
                    end
                end
                2: begin
                    if (vbs_jct < BSIM4vjsmRev) begin
                        T0 = vbs_jct / Nvtms;
                        if (T0 < -`EXP_THRESHOLD) begin
                            evbs = `MIN_EXP;
                            devbs_dvb = 0.0;
                        end
                        else begin
                            evbs = exp(T0);
                            devbs_dvb = evbs / Nvtms;
                        end

                        T1 = evbs - 1.0;
                        T2 = BSIM4IVjsmRev + BSIM4SslpRev *
                            (vbs_jct - BSIM4vjsmRev);
                        BSIM4gbs = devbs_dvb * T2 + T1 * BSIM4SslpRev + `Gmin;
                        BSIM4cbs = T1 * T2 + `Gmin * vbs_jct;
                    end
                    else if (vbs_jct <= BSIM4vjsmFwd) begin
                        T0 = vbs_jct / Nvtms;
                        if (T0 < -`EXP_THRESHOLD) begin
                            evbs = `MIN_EXP;
                            devbs_dvb = 0.0;
                        end
                        else begin
                            evbs = exp(T0);
                            devbs_dvb = evbs / Nvtms;
                        end

                        T1 = (BSIM4bvs + vbs_jct) / Nvtms;
                        if (T1 > `EXP_THRESHOLD) begin
                            T2 = `MIN_EXP;
                            T3 = 0.0;
                        end
                        else begin
                            T2 = exp(-T1);
                            T3 = -T2 /Nvtms;
                        end
                        BSIM4gbs = SourceSatCurrent * (devbs_dvb -
                            BSIM4xjbvs * T3) + `Gmin;
                        BSIM4cbs = SourceSatCurrent * (evbs + BSIM4XExpBVS - 1.0
                        - BSIM4xjbvs * T2) + `Gmin * vbs_jct;
                    end
                    else begin
                        BSIM4gbs = BSIM4SslpFwd + `Gmin;
                        BSIM4cbs = BSIM4IVjsmFwd + BSIM4SslpFwd * (vbs_jct
                        - BSIM4vjsmFwd) + `Gmin * vbs_jct;
                    end
                end // case: 2
            endcase // case(BSIM4dioMod)

        end // else: !if(SourceSatCurrent <= 0.0)

        Nvtmd = BSIM4vtm * BSIM4DjctEmissionCoeff;
        if ((BSIM4Adeff <= 0.0) && (BSIM4Pdeff <= 0.0))
            DrainSatCurrent = 0.0;
        else
            DrainSatCurrent = BSIM4Adeff * BSIM4DjctTempSatCurDensity
                  + BSIM4Pdeff * BSIM4DjctSidewallTempSatCurDensity
                  + BSIM4weffCJ * BSIM4nf
                  * BSIM4DjctGateSidewallTempSatCurDensity;

        if (DrainSatCurrent <= 0.0) begin
            BSIM4gbd = `Gmin;
            BSIM4cbd = BSIM4gbd * vbd_jct;
        end
        else begin
            case (BSIM4dioMod)
                0: begin
                    evbd = exp(vbd_jct / Nvtmd);
                    T1 = BSIM4xjbvd * exp(-(BSIM4bvd + vbd_jct) / Nvtmd);
                    // WDLiu: Magic T1 in this form; different from BSIM4 beta.
                    BSIM4gbd = DrainSatCurrent * (evbd + T1) / Nvtmd + `Gmin;
                    BSIM4cbd = DrainSatCurrent * (evbd + BSIM4XExpBVD
                                     - T1 - 1.0) + `Gmin * vbd_jct;
                end
                1: begin
                    T2 = vbd_jct / Nvtmd;
                    if (T2 < -`EXP_THRESHOLD) begin
                        BSIM4gbd = `Gmin;
                        BSIM4cbd = DrainSatCurrent * (`MIN_EXP - 1.0)
                                         + `Gmin * vbd_jct;
                    end
                    else if (vbd_jct <= BSIM4vjdmFwd) begin
                        evbd = exp(T2);
                        BSIM4gbd = DrainSatCurrent * evbd / Nvtmd + `Gmin;
                        BSIM4cbd = DrainSatCurrent * (evbd - 1.0)
                                         + `Gmin * vbd_jct;
                    end
                    else begin
                        T0 = BSIM4IVjdmFwd / Nvtmd;
                        BSIM4gbd = T0 + `Gmin;
                        BSIM4cbd = BSIM4IVjdmFwd - DrainSatCurrent + T0
                                         * (vbd_jct - BSIM4vjdmFwd) + `Gmin * vbd_jct;
                    end
                end
                2: begin
                    if (vbd_jct < BSIM4vjdmRev) begin
                        T0 = vbd_jct / Nvtmd;
                        if (T0 < -`EXP_THRESHOLD) begin
                            evbd = `MIN_EXP;
                            devbd_dvb = 0.0;
                        end
                        else begin
                            evbd = exp(T0);
                            devbd_dvb = evbd / Nvtmd;
                        end

                        T1 = evbd - 1.0;
                        T2 = BSIM4IVjdmRev + BSIM4DslpRev *
                            (vbd_jct - BSIM4vjdmRev);
                        BSIM4gbd = devbd_dvb * T2 + T1 * BSIM4DslpRev + `Gmin;
                        BSIM4cbd = T1 * T2 + `Gmin * vbd_jct;
                    end
                    else if (vbd_jct <= BSIM4vjdmFwd) begin
                        T0 = vbd_jct / Nvtmd;
                        if (T0 < -`EXP_THRESHOLD) begin
                            evbd = `MIN_EXP;
                            devbd_dvb = 0.0;
                        end
                        else begin
                            evbd = exp(T0);
                            devbd_dvb = evbd / Nvtmd;
                        end

                        T1 = (BSIM4bvd + vbd_jct) / Nvtmd;
                        if (T1 > `EXP_THRESHOLD) begin
                            T2 = `MIN_EXP;
                            T3 = 0.0;
                        end
                        else begin
                            T2 = exp(-T1);
                            T3 = -T2 /Nvtmd;
                        end
                        BSIM4gbd = DrainSatCurrent * (devbd_dvb - BSIM4xjbvd *
                            T3) + `Gmin;
                        BSIM4cbd = DrainSatCurrent * (evbd + BSIM4XExpBVD - 1.0
                                         - BSIM4xjbvd * T2) + `Gmin * vbd_jct;
                    end
                    else begin
                        BSIM4gbd = BSIM4DslpFwd + `Gmin;
                        BSIM4cbd = BSIM4IVjdmFwd + BSIM4DslpFwd * (vbd_jct
                                         - BSIM4vjdmFwd) + `Gmin * vbd_jct;
                    end
                end
            endcase
        end // else: !if(DrainSatCurrent <= 0.0)

        /* trap-assisted tunneling and recombination current for reverse bias  */
        Nvtmrssws = Vtm0 * BSIM4njtsswstemp;
        Nvtmrsswgs = Vtm0 * BSIM4njtsswgstemp;
        Nvtmrss = Vtm0 * BSIM4njtsstemp;
        Nvtmrsswd = Vtm0 * BSIM4njtsswdtemp;
        Nvtmrsswgd = Vtm0 * BSIM4njtsswgdtemp;
        Nvtmrsd = Vtm0 * BSIM4njtsdtemp;

        if ((BSIM4vtss - vbs_jct) < (BSIM4vtss * 1e-3))
        begin
            T9 = 1.0e3;
            T0 = - vbs_jct / Nvtmrss * T9;
            `DEXP2(T0, T1, T10)
            dT1_dVb = T10 / Nvtmrss * T9;
        end else begin
            T9 = 1.0 / (BSIM4vtss - vbs_jct);
            T0 = -vbs_jct / Nvtmrss * BSIM4vtss * T9;
            dT0_dVb = BSIM4vtss / Nvtmrss * (T9 + vbs_jct * T9 * T9) ;
            `DEXP2(T0, T1, T10)
            dT1_dVb = T10 * dT0_dVb;
        end

        if ((BSIM4vtsd - vbd_jct) < (BSIM4vtsd * 1e-3) )
        begin T9 = 1.0e3;
            T0 = -vbd_jct / Nvtmrsd * T9;
            `DEXP2(T0, T2, T10)
            dT2_dVb = T10 / Nvtmrsd * T9;
        end else begin
            T9 = 1.0 / (BSIM4vtsd - vbd_jct);
            T0 = -vbd_jct / Nvtmrsd * BSIM4vtsd * T9;
            dT0_dVb = BSIM4vtsd / Nvtmrsd * (T9 + vbd_jct * T9 * T9) ;
            `DEXP2(T0, T2, T10)
            dT2_dVb = T10 * dT0_dVb;
        end

        if ((BSIM4vtssws - vbs_jct) < (BSIM4vtssws * 1e-3) )
        begin T9 = 1.0e3;
            T0 = -vbs_jct / Nvtmrssws * T9;
            `DEXP2(T0, T3, T10)
            dT3_dVb = T10 / Nvtmrssws * T9;
        end else begin
            T9 = 1.0 / (BSIM4vtssws - vbs_jct);
            T0 = -vbs_jct / Nvtmrssws * BSIM4vtssws * T9;
            dT0_dVb = BSIM4vtssws / Nvtmrssws * (T9 + vbs_jct * T9 * T9) ;
            `DEXP2(T0, T3, T10)
            dT3_dVb = T10 * dT0_dVb;
        end

        if ((BSIM4vtsswd - vbd_jct) < (BSIM4vtsswd * 1e-3) )
        begin T9 = 1.0e3;
            T0 = -vbd_jct / Nvtmrsswd * T9;
            `DEXP2(T0, T4, T10)
            dT4_dVb = T10 / Nvtmrsswd * T9;
        end else begin
            T9 = 1.0 / (BSIM4vtsswd - vbd_jct);
            T0 = -vbd_jct / Nvtmrsswd * BSIM4vtsswd * T9;
            dT0_dVb = BSIM4vtsswd / Nvtmrsswd * (T9 + vbd_jct * T9 * T9) ;
            `DEXP2(T0, T4, T10)
            dT4_dVb = T10 * dT0_dVb;
        end

        if ((BSIM4vtsswgs - vbs_jct) < (BSIM4vtsswgs * 1e-3) )
        begin T9 = 1.0e3;
            T0 = -vbs_jct / Nvtmrsswgs * T9;
            `DEXP2(T0, T5, T10)
            dT5_dVb = T10 / Nvtmrsswgs * T9;
        end else begin
            T9 = 1.0 / (BSIM4vtsswgs - vbs_jct);
            T0 = -vbs_jct / Nvtmrsswgs * BSIM4vtsswgs * T9;
            dT0_dVb = BSIM4vtsswgs / Nvtmrsswgs * (T9 + vbs_jct * T9 * T9) ;
            `DEXP2(T0, T5, T10)
            dT5_dVb = T10 * dT0_dVb;
        end

        if ((BSIM4vtsswgd - vbd_jct) < (BSIM4vtsswgd * 1e-3) )
        begin T9 = 1.0e3;
            T0 = -vbd_jct / Nvtmrsswgd * T9;
            `DEXP2(T0, T6, T10)
            dT6_dVb = T10 / Nvtmrsswgd * T9;
        end else begin
            T9 = 1.0 / (BSIM4vtsswgd - vbd_jct);
            T0 = -vbd_jct / Nvtmrsswgd * BSIM4vtsswgd * T9;
            dT0_dVb = BSIM4vtsswgd / Nvtmrsswgd * (T9 + vbd_jct * T9 * T9) ;
            `DEXP2(T0, T6, T10)
            dT6_dVb = T10 * dT0_dVb;
        end

        BSIM4gbs = BSIM4gbs + BSIM4SjctTempRevSatCur * dT1_dVb
        + BSIM4SswTempRevSatCur * dT3_dVb
        + BSIM4SswgTempRevSatCur * dT5_dVb;
        BSIM4cbs = BSIM4cbs -(BSIM4SjctTempRevSatCur * (T1 - 1.0)
        + BSIM4SswTempRevSatCur * (T3 - 1.0)
        + BSIM4SswgTempRevSatCur * (T5 - 1.0));
        BSIM4gbd = BSIM4gbd + BSIM4DjctTempRevSatCur * dT2_dVb
        + BSIM4DswTempRevSatCur * dT4_dVb
        + BSIM4DswgTempRevSatCur * dT6_dVb;
        BSIM4cbd = BSIM4cbd -(BSIM4DjctTempRevSatCur * (T2 - 1.0)
        + BSIM4DswTempRevSatCur * (T4 - 1.0)
        + BSIM4DswgTempRevSatCur * (T6 - 1.0));
        if (verbose == 1) begin
            $strobe("BSIM4cbd,s=%g,%g\n", BSIM4cbd, BSIM4cbs);
            $strobe("BSIM4cbd's RHS=%g,%g,%g,%g,%g,%g\n", BSIM4DjctTempRevSatCur,BSIM4DswTempRevSatCur, BSIM4DswgTempRevSatCur,T2,T4,T6);
        end
        /* End of diode DC model */

        if (vds >= 0.0) begin
            BSIM4mode = 1;
            Vds = vds;
            Vgs = vgs;
            Vbs = vbs;
            Vdb = vds - vbs;  /* WDLiu: for GIDL */
        end
        else begin
            BSIM4mode = -1;
            Vds = -vds;
            Vgs = vgd;
            Vbs = vbd;
            Vdb = -vbs;
        end

        T0 = Vbs - here_BSIM4vbsc - 0.001;
        T1 = sqrt(T0 * T0 - 0.004 * here_BSIM4vbsc);
        if (T0 >= 0.0)
            Vbseff = here_BSIM4vbsc + 0.5 * (T0 + T1);
        else begin
            T2 = -0.002 / (T1 - T0);
            Vbseff = here_BSIM4vbsc * (1.0 + T2);
        end
        if (verbose == 1) begin
            $strobe("Vbseff=%g,%g,%g,%g,%g\n", Vbseff,Vds,Vgs,Vbs,Vdb);
            $strobe("gbs,d=%g,%g\n", BSIM4gbs,BSIM4gbd);
        end

        /* JX: Correction to forward body bias */
        T9 = 0.95 * BSIM4phi;
        T0 = T9 - Vbseff - 0.001;
        T1 = sqrt(T0 * T0 + 0.004 * T9);
        Vbseff = T9 - 0.5 * (T0 + T1);

        Phis = BSIM4phi - Vbseff;
        sqrtPhis = sqrt(Phis);
        if (verbose == 1)
            $strobe("Vbseff=%g\n", Vbseff);

        Xdep = BSIM4Xdep0 * sqrtPhis / BSIM4sqrtPhi;

        Leff = BSIM4leff;
        Vtm = BSIM4vtm;
        if (verbose == 1) begin
            $strobe("Leff=%g\n", Leff);
            $strobe("Vtm=%g\n", Vtm);
            $strobe("BSIM4phi=%g\n", BSIM4phi);
            $strobe("Xdep=%g\n", Xdep);
            $strobe("here_BSIM4vbsc=%g\n", here_BSIM4vbsc);
            $strobe("DrainSatCurrent,SourceSatCurrent=%g,%g\n", DrainSatCurrent, SourceSatCurrent);
        end

`ifdef NOISE_DERIVATIVES
            if (verbose == 1)
                $strobe("analysis(noise)=%g\n", analysis("noise"));
            if ((BSIM4tnoiMod == 1) && analysis("noise") == `NOISE) begin
                // Derivatives only needed for this mode.
                if (T0 >= 0.0)
                    dVbseff_dVb = 0.5 * (1.0 + T0 / T1);
                else
                    dVbseff_dVb = T2 * here_BSIM4vbsc / T1;

                if (Vbseff > 0.0) begin
                    T0 = BSIM4phi / (BSIM4phi + Vbseff);
                    dsqrtPhis_dVb = -0.5 * sqrtPhis * sqrtPhis / BSIM4phis3;
                end
                else begin
                    dsqrtPhis_dVb = -0.5 / sqrtPhis;
                end

                dXdep_dVb = (BSIM4Xdep0 / BSIM4sqrtPhi)
                        * dsqrtPhis_dVb;
            end
`endif

        /* Vth Calculation */
        T3 = sqrt(Xdep);
        V0 = BSIM4vbi - BSIM4phi;

        T0 = BSIM4dvt2 * Vbseff;
        if (T0 >= - 0.5) begin
            T1 = 1.0 + T0;
            T2 = BSIM4dvt2;
        end
        else begin
            T4 = 1.0 / (3.0 + 8.0 * T0);
            T1 = (1.0 + 3.0 * T0) * T4;
            T2 = BSIM4dvt2 * T4 * T4;
        end
        lt1 = BSIM4factor1 * T3 * T1;

        T0 = BSIM4dvt2w * Vbseff;
        if (T0 >= - 0.5) begin
            T1 = 1.0 + T0;
            T2 = BSIM4dvt2w;
        end
        else begin
            T4 = 1.0 / (3.0 + 8.0 * T0);
            T1 = (1.0 + 3.0 * T0) * T4;
            T2 = BSIM4dvt2w * T4 * T4;
        end
        ltw = BSIM4factor1 * T3 * T1;

        T0 = BSIM4dvt1 * Leff / lt1;
        if (T0 < `EXP_THRESHOLD) begin
            T1 = exp(T0);
            T2 = T1 - 1.0;
            T3 = T2 * T2;
            T4 = T3 + 2.0 * T1 * `MIN_EXP;
            Theta0 = T1 / T4;
        end
        else
            Theta0 = 1.0 / (`MAX_EXP - 2.0); /* 3.0 * `MIN_EXP omitted */

        BSIM4thetavth = BSIM4dvt0 * Theta0;
        Delt_vth = BSIM4thetavth * V0;
        if (verbose == 1)
            $strobe("Delt_vth=%g,%g,%g,%g,%g\n", Delt_vth, BSIM4dvt0,lt1,BSIM4factor1,BSIM4vbi);

`ifdef NOISE_DERIVATIVES
            if ((BSIM4tnoiMod == 1) && analysis("noise") == `NOISE) begin
                // Derivatives only needed for this mode.
                T3 = sqrt(Xdep);

                T0 = BSIM4dvt2 * Vbseff;
                if (T0 >= - 0.5) begin
                    T1 = 1.0 + T0;
                    T2 = BSIM4dvt2;
                end
                else begin
                    T4 = 1.0 / (3.0 + 8.0 * T0);
                    T1 = (1.0 + 3.0 * T0) * T4;
                    T2 = BSIM4dvt2 * T4 * T4;
                end
                dlt1_dVb = BSIM4factor1 * (0.5 / T3 * T1
                        * dXdep_dVb + T3 * T2);

                T0 = BSIM4dvt2w * Vbseff;
                if (T0 >= - 0.5) begin
                    T1 = 1.0 + T0;
                    T2 = BSIM4dvt2w;
                end
                else begin
                    T4 = 1.0 / (3.0 + 8.0 * T0);
                    T1 = (1.0 + 3.0 * T0) * T4;
                    T2 = BSIM4dvt2w * T4 * T4;
                end
                dltw_dVb = BSIM4factor1 * (0.5 / T3 * T1
                        * dXdep_dVb + T3 * T2);

                T0 = BSIM4dvt1 * Leff / lt1;
                if (T0 < `EXP_THRESHOLD) begin
                    T1 = exp(T0);
                    T2 = T1 - 1.0;
                    T3 = T2 * T2;
                    T4 = T3 + 2.0 * T1 * `MIN_EXP;
                    dT1_dVb = -T0 * T1 * dlt1_dVb / lt1;
                    dTheta0_dVb = dT1_dVb * (T4 - 2.0 * T1 * (T2 + `MIN_EXP)) / T4 / T4;
                end
                else
                    dTheta0_dVb = 0.0;

                dDelt_vth_dVb = BSIM4dvt0 * dTheta0_dVb * V0;
            end
`endif

        T0 = BSIM4dvt1w * BSIM4weff * Leff / ltw;
        if (T0 < `EXP_THRESHOLD) begin
            T1 = exp(T0);
            T2 = T1 - 1.0;
            T3 = T2 * T2;
            T4 = T3 + 2.0 * T1 * `MIN_EXP;
            T5 = T1 / T4;
        end
        else
            T5 = 1.0 / (`MAX_EXP - 2.0); /* 3.0 * `MIN_EXP omitted */

        T0 = BSIM4dvt0w * T5;
        T2 = T0 * V0;

        TempRatio = T / BSIM4tnom - 1.0;
        T0 = sqrt(1.0 + BSIM4lpe0 / Leff);
        T1 = BSIM4k1ox * (T0 - 1.0) * BSIM4sqrtPhi +
            (BSIM4kt1 + BSIM4kt1l / Leff +
            BSIM4kt2 * Vbseff) * TempRatio;
        Vth_NarrowW = toxel * BSIM4phi / (BSIM4weff + BSIM4w0);

        T3 = here_BSIM4eta0 + BSIM4etab * Vbseff;
        if (T3 < 1.0e-4) begin
            T9 = 1.0 / (3.0 - 2.0e4 * T3);
            T3 = (2.0e-4 - T3) * T9;
        end
        dDIBL_Sft_dVd = T3 * BSIM4theta0vb0;
        DIBL_Sft = dDIBL_Sft_dVd * Vds;

        Lpe_Vb = sqrt(1.0 + BSIM4lpeb / Leff);

        Vth = BSIM4type * here_BSIM4vth0 + (BSIM4k1ox * sqrtPhis -
            BSIM4k1 * BSIM4sqrtPhi) * Lpe_Vb -
            here_BSIM4k2ox * Vbseff - Delt_vth - T2 + (BSIM4k3 +
            BSIM4k3b * Vbseff) * Vth_NarrowW + T1 - DIBL_Sft;
        if (verbose == 1)
            $strobe("Vth=%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,%g\n", Vth,here_BSIM4vth0,sqrtPhis,Lpe_Vb,here_BSIM4k2ox,
            Vbseff,Delt_vth,T2, Vth_NarrowW,T1,DIBL_Sft);

`ifdef NOISE_DERIVATIVES
            if ((BSIM4tnoiMod == 1) && analysis("noise") == `NOISE) begin
                // Derivatives only needed for this mode.

                T0 = BSIM4dvt1w * BSIM4weff * Leff / ltw;
                if (T0 < `EXP_THRESHOLD) begin
                    T1 = exp(T0);
                    T2 = T1 - 1.0;
                    T3 = T2 * T2;
                    T4 = T3 + 2.0 * T1 * `MIN_EXP;
                    T5 = T1 / T4;
                    dT1_dVb = -T0 * T1 * dltw_dVb / ltw; /* bugfix -JX */
                    dT5_dVb = dT1_dVb * (T4 - 2.0 * T1 * (T2 + `MIN_EXP)) / T4 / T4;
                end
                else
                    dT5_dVb = 0.0;

                dT2_dVb = BSIM4dvt0w * dT5_dVb * V0;

                dVth_dVb = Lpe_Vb * BSIM4k1ox * dsqrtPhis_dVb
                       - here_BSIM4k2ox - dDelt_vth_dVb - dT2_dVb
                       + BSIM4k3b * Vth_NarrowW
                       - BSIM4etab * Vds * BSIM4theta0vb0 * T4
                       + BSIM4kt2 * TempRatio;
                dVth_dVd = -dDIBL_Sft_dVd;

            end
`endif

        /* Calculate n */
        tmp1 = `EPSSI / Xdep;
        BSIM4nstar = BSIM4vtm / `P_Q * (BSIM4coxe + tmp1 + BSIM4cit);
        tmp2 = BSIM4nfactor * tmp1;
        tmp3 = BSIM4cdsc + BSIM4cdscb * Vbseff + BSIM4cdscd * Vds;
        tmp4 = (tmp2 + tmp3 * Theta0 + BSIM4cit) / BSIM4coxe;
        if (tmp4 >= -0.5)
            n = 1.0 + tmp4;
        else begin
            T0 = 1.0 / (3.0 + 8.0 * tmp4);
            n = (1.0 + 3.0 * tmp4) * T0;
        end

`ifdef NOISE_DERIVATIVES
            if ((BSIM4tnoiMod == 1) && analysis("noise") == `NOISE) begin
                // Derivatives only needed for this mode.
                if (tmp4 >= -0.5) begin
                    dn_dVb = (-tmp2 / Xdep * dXdep_dVb + tmp3 * dTheta0_dVb
                          + BSIM4cdscb * Theta0) / BSIM4coxe;
                    dn_dVd = BSIM4cdscd * Theta0 / BSIM4coxe;
                end
                else begin
                    T0 = 1.0 / (3.0 + 8.0 * tmp4);
                    n = (1.0 + 3.0 * tmp4) * T0;
                    T0 = T0 * (  T0);
                    dn_dVb = (-tmp2 / Xdep * dXdep_dVb + tmp3 * dTheta0_dVb
                          + BSIM4cdscb * Theta0) / BSIM4coxe * T0;
                    dn_dVd = BSIM4cdscd * Theta0 / BSIM4coxe * T0;
                end
            end
`endif
        if (verbose == 1)
            $strobe("n=%g\n", n);

        /* Vth correction for Pocket implant */
        if (BSIM4dvtp0 > 0.0) begin
            T0 = -BSIM4dvtp1 * Vds;
            if (T0 < -`EXP_THRESHOLD)
                T2 = `MIN_EXP;
            else
                T2 = exp(T0);

            T3 = Leff + BSIM4dvtp0 * (1.0 + T2);
            if (BSIM4tempMod < 2)
                T4 = Vtm * ln(Leff / T3);
            else
                T4 = Vtm0 * ln(Leff / T3);
            Vth = Vth - (n * T4);
        end
`ifdef NOISE_DERIVATIVES
            if ((BSIM4tnoiMod == 1) && analysis("noise") == `NOISE) begin
                // Derivatives only needed for this mode.
                if (BSIM4dvtp0 > 0.0) begin
                    T0 = -BSIM4dvtp1 * Vds;
                    if (T0 < -`EXP_THRESHOLD)
                        dT2_dVd = 0.0;
                    else
                        dT2_dVd = -BSIM4dvtp1 * T2;

                    dT3_dVd = BSIM4dvtp0 * dT2_dVd;
                    dT4_dVd = -Vtm * dT3_dVd / T3;
                    dDITS_Sft_dVd = dn_dVd * T4 + n * dT4_dVd;
                    dDITS_Sft_dVb = T4 * dn_dVb;

                    dVth_dVd = dVth_dVd - (  dDITS_Sft_dVd);
                    dVth_dVb = dVth_dVb - (  dDITS_Sft_dVb);
                end
            end
`endif
        /* v4.7 DITS_SFT2  */
        if ((BSIM4dvtp4  == 0.0) || (BSIM4dvtp2factor == 0.0)) begin
            T0 = 0.0;
            DITS_Sft2 = 0.0;
        end
        else
        begin
            //T0 = exp(2.0 * BSIM4dvtp4 * Vds);   /* beta code */
            T1 = 2.0 * BSIM4dvtp4 * Vds;
            `DEXP2(T1, T0, T10)
            DITS_Sft2 = BSIM4dvtp2factor * (T0-1) / (T0+1);
            //dDITS_Sft2_dVd = BSIM4dvtp2factor * BSIM4dvtp4 * 4.0 * T0 / ((T0+1) * (T0+1));   /* beta code */
            dDITS_Sft2_dVd = BSIM4dvtp2factor * BSIM4dvtp4 * 4.0 * T10 / ((T0+1) * (T0+1));
            Vth = Vth - DITS_Sft2;
            dVth_dVd = dVth_dVd - dDITS_Sft2_dVd;
        end
        if (verbose == 1)
            $strobe("Vth=%g\n", Vth);

        /* Poly Gate Si Depletion Effect */
        T0 = here_BSIM4vfb + BSIM4phi;
        if (BSIM4mtrlmod == 0)
            T1 = `EPSSI;
        else
            T1 = BSIM4epsrgate * `EPS0;
        if (verbose == 1) begin
            $strobe("T0,T1=%g,%g\n", T0, T1);
        end

        `BSIM4polyDepletion(T0, BSIM4ngate,T1, BSIM4coxe, vgs, vgs_eff, dvgs_eff_dvg)

        `BSIM4polyDepletion(T0, BSIM4ngate,T1, BSIM4coxe, vgd, vgd_eff, dvgd_eff_dvg)

        if (BSIM4mode > 0)
            Vgs_eff = vgs_eff;
        else
            Vgs_eff = vgd_eff;

`ifdef NOISE_DERIVATIVES
            if ((BSIM4tnoiMod == 1) && analysis("noise") == `NOISE) begin
                // Derivatives only needed for this mode.
                if (BSIM4mode>0)
                    dVgs_eff_dVg = dvgs_eff_dvg;
                else
                    dVgs_eff_dVg = dvgd_eff_dvg;
            end
`endif

        Vgst = Vgs_eff - Vth;
        if (verbose == 1) begin
            $strobe("T0,T1=%g,%g\n", T0, T1);
            $strobe("Vgst=%g,%g,%g\n", Vgst,Vgs_eff,vgs,vgd);
            $strobe("Vgs,d_eff=%g,%g\n", vgs_eff, vgd_eff);
        end

        /* Calculate Vgsteff */
        T0 = n * Vtm;
        T1 = BSIM4mstar * Vgst;
        T2 = T1 / T0;
        if (T2 > `EXP_THRESHOLD)
            T10 = T1;
        else if (T2 < -`EXP_THRESHOLD) begin
            T10 = Vtm * ln(1.0 + `MIN_EXP);
            T10 = T10 * n;
        end
        else begin
            ExpVgst = exp(T2);
            T3 = Vtm * ln(1.0 + ExpVgst);
            T10 = n * T3;
        end

        T1 = BSIM4voffcbn - (1.0 - BSIM4mstar) * Vgst;
        T2 = T1 / T0;
        if (T2 < -`EXP_THRESHOLD) begin
            T3 = BSIM4coxe * `MIN_EXP / BSIM4cdep0;
            T9 = BSIM4mstar + T3 * n;
        end
        else if (T2 > `EXP_THRESHOLD) begin
            T3 = BSIM4coxe * `MAX_EXP / BSIM4cdep0;
            T9 = BSIM4mstar + T3 * n;
        end
        else begin
            ExpVgst = exp(T2);
            T3 = BSIM4coxe / BSIM4cdep0;
            T4 = T3 * ExpVgst;
            T5 = T1 * T4 / T0;
            T9 = BSIM4mstar + n * T4;
        end

        Vgsteff = T10 / T9;
        here_Vgsteff = Vgsteff;

`ifdef NOISE_DERIVATIVES
            if ((BSIM4tnoiMod == 1) && analysis("noise") == `NOISE) begin
                // Derivatives only needed for this mode.
                T0 = n * Vtm;
                T1 = BSIM4mstar * Vgst;
                T2 = T1 / T0;
                if (T2 > `EXP_THRESHOLD) begin
                    T10 = T1;
                    dT10_dVg = BSIM4mstar * dVgs_eff_dVg;
                    dT10_dVd = -dVth_dVd * BSIM4mstar;
                    dT10_dVb = -dVth_dVb * BSIM4mstar;
                end
                else if (T2 < -`EXP_THRESHOLD) begin
                    T10 = Vtm * ln(1.0 + `MIN_EXP);
                    dT10_dVg = 0.0;
                    dT10_dVd = T10 * dn_dVd;
                    dT10_dVb = T10 * dn_dVb;
                    T10 = T10 * n;
                end
                else begin
                    ExpVgst = exp(T2);
                    T3 = Vtm * ln(1.0 + ExpVgst);
                    T10 = n * T3;
                    dT10_dVg = BSIM4mstar * ExpVgst / (1.0 + ExpVgst);
                    dT10_dVb = T3 * dn_dVb - dT10_dVg * (dVth_dVb + Vgst * dn_dVb / n);
                    dT10_dVd = T3 * dn_dVd - dT10_dVg * (dVth_dVd + Vgst * dn_dVd / n);
                    dT10_dVg = dT10_dVg * (  dVgs_eff_dVg);
                end

                T1 = BSIM4voffcbn - (1.0 - BSIM4mstar) * Vgst;
                T2 = T1 / T0;
                if (T2 < -`EXP_THRESHOLD) begin
                    T3 = BSIM4coxe * `MIN_EXP / BSIM4cdep0;
                    T9 = BSIM4mstar + T3 * n;
                    dT9_dVg = 0.0;
                    dT9_dVd = dn_dVd * T3;
                    dT9_dVb = dn_dVb * T3;
                end
                else if (T2 > `EXP_THRESHOLD) begin
                    T3 = BSIM4coxe * `MAX_EXP / BSIM4cdep0;
                    T9 = BSIM4mstar + T3 * n;
                    dT9_dVg = 0.0;
                    dT9_dVd = dn_dVd * T3;
                    dT9_dVb = dn_dVb * T3;
                end
                else begin
                    ExpVgst = exp(T2);
                    T3 = BSIM4coxe / BSIM4cdep0;
                    T4 = T3 * ExpVgst;
                    T5 = T1 * T4 / T0;
                    T9 = BSIM4mstar + n * T4;
                    dT9_dVg = T3 * (BSIM4mstar - 1.0) * ExpVgst / Vtm;
                    dT9_dVb = T4 * dn_dVb - dT9_dVg * dVth_dVb - T5 * dn_dVb;
                    dT9_dVd = T4 * dn_dVd - dT9_dVg * dVth_dVd - T5 * dn_dVd;
                    dT9_dVg = dT9_dVg * (  dVgs_eff_dVg);
                end
                T11 = T9 * T9;
                dVgsteff_dVg = (T9 * dT10_dVg - T10 * dT9_dVg) / T11;
                dVgsteff_dVd = (T9 * dT10_dVd - T10 * dT9_dVd) / T11;
                dVgsteff_dVb = (T9 * dT10_dVb - T10 * dT9_dVb) / T11;

            end
`endif
        if (verbose == 1)
            $strobe("Vgsteff=%g\n", Vgsteff);

        /* Calculate Effective Channel Geometry */
        T9 = sqrtPhis - BSIM4sqrtPhi;
        Weff = BSIM4weff - 2.0 * (BSIM4dwg * Vgsteff + BSIM4dwb * T9);

        /* to avoid the discontinuity problem due to Weff*/
        if (Weff < 2.0e-8) begin
            T0 = 1.0 / (6.0e-8 - 2.0 * Weff);
            Weff = 2.0e-8 * (4.0e-8 - Weff) * T0;
            T0 = T0 * (T0 * 4.0e-16);
        end
`ifdef NOISE_DERIVATIVES
            if ((BSIM4tnoiMod == 1) && analysis("noise") == `NOISE) begin
                // Derivatives only needed for this mode.
                dWeff_dVg = -2.0 * BSIM4dwg;
                dWeff_dVb = -2.0 * BSIM4dwb * dsqrtPhis_dVb;

                if (Weff < 2.0e-8) begin
                    T0 = T0 * T0 * 4.0e-16;
                    dWeff_dVg = dWeff_dVg * T0;
                    dWeff_dVb = dWeff_dVb * T0;
                end
            end
`endif
        if (verbose == 1)
            $strobe("Weff=%g\n", Weff);

        if (BSIM4rdsMod == 1)
            Rds = 0.0;
        else begin
            T0 = 1.0 + BSIM4prwg * Vgsteff;
            T1 = BSIM4prwb * T9;
            T2 = 1.0 / T0 + T1;
            T3 = T2 + sqrt(T2 * T2 + 0.01); /* 0.01 = 4.0 * 0.05 * 0.05 */
            T4 = BSIM4rds0 * 0.5;
            Rds = BSIM4rdswmin + T3 * T4;
            if (Rds > 0.0)
                //grdsw = 1.0 / (Rds * BSIM4nf);
                grdsw = 1.0 / Rds* BSIM4nf; /*4.6.2 */
            else
                grdsw = 0.0;
        end
`ifdef NOISE_DERIVATIVES
            if ((BSIM4tnoiMod == 1) && analysis("noise") == `NOISE) begin
                // Derivatives only needed for this mode.
                if (BSIM4rdsMod == 1) begin
                    dRds_dVg = 0.0;
                    dRds_dVb = 0.0;
                end
                else begin
                    T0 = 1.0 + BSIM4prwg * Vgsteff;
                    dT0_dVg = -BSIM4prwg / T0 / T0;
                    T1 = BSIM4prwb * T9;
                    dT1_dVb = BSIM4prwb * dsqrtPhis_dVb;
                    T2 = 1.0 / T0 + T1;
                    T3 = T2 + sqrt(T2 * T2 + 0.01); /* 0.01 = 4.0 * 0.05 * 0.05 */
                    dT3_dVg = 1.0 + T2 / (T3 - T2);
                    dT3_dVb = dT3_dVg * dT1_dVb;
                    dT3_dVg = dT3_dVg * (  dT0_dVg);
                    T4 = BSIM4rds0 * 0.5;
                    dRds_dVg = T4 * dT3_dVg;
                    dRds_dVb = T4 * dT3_dVb;
                end
            end
`endif
        if (verbose == 1)
            $strobe("Rds=%g\n", Rds);

        /* Calculate Abulk */
        T9 = 0.5 * BSIM4k1ox * Lpe_Vb / sqrtPhis;
        T1 = T9 + here_BSIM4k2ox - BSIM4k3b * Vth_NarrowW;
        T9 = sqrt(BSIM4xj * Xdep);
        tmp1 = Leff + 2.0 * T9;
        T5 = Leff / tmp1;
        tmp2 = BSIM4a0 * T5;
        tmp3 = BSIM4weff + BSIM4b1;
        tmp4 = BSIM4b0 / tmp3;
        T2 = tmp2 + tmp4;
        T7 = T5 * T5 * T5;
        Abulk0 = 1.0 + T1 * T2;
        T8 = BSIM4ags * BSIM4a0 * T7;
        dAbulk_dVg = -T1 * T8;
        Abulk = Abulk0 + dAbulk_dVg * Vgsteff;

        /* added to avoid the problems caused by Abulk0 */
        if (Abulk0 < 0.1) begin
            T9 = 1.0 / (3.0 - 20.0 * Abulk0);
            Abulk0 = (0.2 - Abulk0) * T9;
        end

        if (Abulk < 0.1) begin
            T9 = 1.0 / (3.0 - 20.0 * Abulk);
            Abulk = (0.2 - Abulk) * T9;
            T10 = T9 * T9;
            dAbulk_dVg = dAbulk_dVg * T10;
        end
        here_Abulk = Abulk;

        T2 = BSIM4keta * Vbseff;
        if (T2 >= -0.9)
            T0 = 1.0 / (1.0 + T2);
        else begin
            T1 = 1.0 / (0.8 + T2);
            T0 = (17.0 + 20.0 * T2) * T1;
        end
        Abulk = Abulk * T0;
        Abulk0 = Abulk0 * T0;

`ifdef NOISE_DERIVATIVES
            if ((BSIM4tnoiMod == 1) && analysis("noise") == `NOISE) begin
                // Derivatives only needed for this mode.
                T9 = 0.5 * BSIM4k1ox * Lpe_Vb / sqrtPhis;
                T1 = T9 + here_BSIM4k2ox - BSIM4k3b * Vth_NarrowW;
                dT1_dVb = -T9 / sqrtPhis * dsqrtPhis_dVb;

                T9 = sqrt(BSIM4xj * Xdep);
                tmp1 = Leff + 2.0 * T9;
                T5 = Leff / tmp1;
                tmp2 = BSIM4a0 * T5;
                tmp3 = BSIM4weff + BSIM4b1;
                tmp4 = BSIM4b0 / tmp3;
                T2 = tmp2 + tmp4;
                dT2_dVb = -T9 / tmp1 / Xdep * dXdep_dVb;
                T6 = T5 * T5;
                T7 = T5 * T6;

                dAbulk0_dVb = T1 * tmp2 * dT2_dVb + T2 * dT1_dVb;

                dAbulk_dVb = dAbulk0_dVb - T8 * Vgsteff * (dT1_dVb
                              + 3.0 * T1 * dT2_dVb);

                if (Abulk0 < 0.1) begin
                    T9 = 1.0 / (3.0 - 20.0 * Abulk0);
                    dAbulk0_dVb = dAbulk0_dVb * T9 * T9;
                end

                if (Abulk < 0.1) begin
                    T9 = 1.0 / (3.0 - 20.0 * Abulk);
                    T10 = T9 * T9;
                    dAbulk_dVb = dAbulk_dVb * T10;
                end

                T2 = BSIM4keta * Vbseff;
                if (T2 >= -0.9) begin
                    T0 = 1.0 / (1.0 + T2);
                    dT0_dVb = -BSIM4keta * T0 * T0;
                end
                else begin
                    T1 = 1.0 / (0.8 + T2);
                    T0 = (17.0 + 20.0 * T2) * T1;
                    dT0_dVb = -BSIM4keta * T1 * T1;
                end
                dAbulk_dVg = dAbulk_dVg * (  T0);
                dAbulk_dVb = dAbulk_dVb * T0 + Abulk * dT0_dVb;
                dAbulk0_dVb = dAbulk0_dVb * T0 + Abulk0 * dT0_dVb;
            end
`endif

        if (verbose == 1) begin
            $strobe("Abulk,0=%g,%g\n", Abulk,Abulk0);
        end

        /* Mobility calculation */
        if (BSIM4mtrlmod && BSIM4mtrlcompatmod == 0)
            T14 = 2.0 * BSIM4type *(BSIM4phig - BSIM4easub - 0.5*BSIM4Eg0 + 0.45);
        else
            T14 = 0.0;
        if (BSIM4mobMod == 0) begin
            T0 = Vgsteff + Vth + Vth - T14;
            T2 = BSIM4ua + BSIM4uc * Vbseff;
            T3 = T0 / toxel;
            T12 = sqrt(Vth * Vth + 0.0001);
            T9 = 1.0/(Vgsteff + 2*T12);
            T10 = T9*toxel;
            T8 = BSIM4ud * T10 * T10 * Vth;
            T6 = T8 * Vth;
            T5 = T3 * (T2 + BSIM4ub * T3) + T6;
        end
        else if (BSIM4mobMod == 1) begin
            T0 = Vgsteff + Vth + Vth - T14;
            T2 = 1.0 + BSIM4uc * Vbseff;
            T3 = T0 / toxel;
            T4 = T3 * (BSIM4ua + BSIM4ub * T3);
            T12 = sqrt(Vth * Vth + 0.0001);
            T9 = 1.0/(Vgsteff + 2*T12);
            T10 = T9*toxel;
            T8 = BSIM4ud * T10 * T10 * Vth;
            T6 = T8 * Vth;
            T5 = T4 * T2 + T6;
        end
        else if (BSIM4mobMod == 2) begin
            T0 = (Vgsteff + here_BSIM4vtfbphi1) / toxel;
            T1 = exp(BSIM4eu * ln(T0));
            T2 = BSIM4ua + BSIM4uc * Vbseff;
            T12 = sqrt(Vth * Vth + 0.0001);
            T9 = 1.0/(Vgsteff + 2*T12);
            T10 = T9*toxel;
            T8 = BSIM4ud * T10 * T10 * Vth;
            T6 = T8 * Vth;
            T5 = T1 * T2 + T6;
        end
        else if (BSIM4mobMod == 4) begin
            T0 = Vgsteff + here_BSIM4vtfbphi1 - T14;
            T2 = BSIM4ua + BSIM4uc * Vbseff;
            T3 = T0 / toxel;
            T12 = sqrt(here_BSIM4vtfbphi1*here_BSIM4vtfbphi1 + 0.0001);
            T9 = 1.0/(Vgsteff + 2*T12);
            T10 = T9*toxel;
            T8 = BSIM4ud * T10 * T10 * here_BSIM4vtfbphi1;
            T6 = T8 * here_BSIM4vtfbphi1;
            T5 = T3 * (T2 + BSIM4ub * T3) + T6;
        end
        else if (BSIM4mobMod == 5) begin
            T0 = Vgsteff + here_BSIM4vtfbphi1 - T14;
            T2 = 1.0 + BSIM4uc * Vbseff;
            T3 = T0 / toxel;
            T4 = T3 * (BSIM4ua + BSIM4ub * T3);
            T12 = sqrt(here_BSIM4vtfbphi1 * here_BSIM4vtfbphi1 + 0.0001);
            T9 = 1.0/(Vgsteff + 2*T12);
            T10 = T9*toxel;
            T8 = BSIM4ud * T10 * T10 * here_BSIM4vtfbphi1;
            T6 = T8 * here_BSIM4vtfbphi1;
            T5 = T4 * T2 + T6;
        end
        else if (BSIM4mobMod == 6) begin
            T0 = (Vgsteff + here_BSIM4vtfbphi1) / toxel;
            T1 = exp(BSIM4eu * ln(T0));
            T2 = BSIM4ua + BSIM4uc * Vbseff;
            T12 = sqrt(here_BSIM4vtfbphi1 * here_BSIM4vtfbphi1 + 0.0001);
            T9 = 1.0/(Vgsteff + 2*T12);
            T10 = T9*toxel;
            T8 = BSIM4ud * T10 * T10 * here_BSIM4vtfbphi1;
            T6 = T8 * here_BSIM4vtfbphi1;
            T5 = T1 * T2 + T6;
        end
        /*high K mobility*/
        else begin // mobmod==3, and others
            /*univsersal mobility*/
            T0 = (Vgsteff + here_BSIM4vtfbphi1)* 1.0e-8 / toxel / 6.0;
            T1 = exp(BSIM4eu * ln(T0));
            T2 = BSIM4ua + BSIM4uc * Vbseff;
            /*Coulombic*/
            T10 = exp(BSIM4ucs * ln(0.5 + 0.5 * Vgsteff/BSIM4VgsteffVth));
            T11 =  BSIM4ud/T10;
            T5 = T1 * T2 + T11;
        end

        if (T5 >= -0.8)
            Denomi = 1.0 + T5;
        else begin
            T9 = 1.0 / (7.0 + 10.0 * T5);
            Denomi = (0.6 + T5) * T9;
            //T9 = T9 * T9;
        end

        if (verbose == 1)
            $strobe("T0=%g,T2=%g,T3=%g,T12=%g,T9=%g,T10=%g,T5=%g,T6=%g,T8=%g\n", T0,T2,T3,T12,T9,T10,T5,T6,T8);
        BSIM4ueff = here_BSIM4u0temp / Denomi;
        ueff      = BSIM4ueff;
        if (verbose == 1)
            $strobe("ueff=%g,here_BSIM4u0temp=%g,Denomi=%g\n", ueff,here_BSIM4u0temp,Denomi);

`ifdef NOISE_DERIVATIVES
            //Enh: not impl mobmod > 2 for Noise
            if ((BSIM4tnoiMod == 1) && analysis("noise") == `NOISE) begin
                // Derivatives only needed for this mode.
                if (BSIM4mobMod == 0) begin
                    T0 = Vgsteff + Vth + Vth;
                    T2 = BSIM4ua + BSIM4uc * Vbseff;
                    T3 = T0 / toxel;
                    T5 = T3 * (T2 + BSIM4ub * T3);
                    dDenomi_dVg = (T2 + 2.0 * BSIM4ub * T3) / toxel;
                    dDenomi_dVd = dDenomi_dVg * 2.0 * dVth_dVd;
                    dDenomi_dVb = dDenomi_dVg * 2.0 * dVth_dVb + BSIM4uc * T3;
                end
                else if (BSIM4mobMod == 1) begin
                    T0 = Vgsteff + Vth + Vth;
                    T2 = 1.0 + BSIM4uc * Vbseff;
                    T3 = T0 / toxel;
                    T4 = T3 * (BSIM4ua + BSIM4ub * T3);
                    T5 = T4 * T2;
                    dDenomi_dVg = (BSIM4ua + 2.0 * BSIM4ub * T3) * T2
                              / toxel;
                    dDenomi_dVd = dDenomi_dVg * 2.0 * dVth_dVd;
                    dDenomi_dVb = dDenomi_dVg * 2.0 * dVth_dVb + BSIM4uc * T4;
                end
                else begin
                    T0 = (Vgsteff + here_BSIM4vtfbphi1) / toxel;
                    T1 = exp(BSIM4eu * ln(T0));
                    dT1_dVg = T1 * BSIM4eu / T0 / toxel;
                    T2 = BSIM4ua + BSIM4uc * Vbseff;
                    T5 = T1 * T2;
                    dDenomi_dVg = T2 * dT1_dVg;
                    dDenomi_dVd = 0.0;
                    dDenomi_dVb = T1 * BSIM4uc;
                end

                if (T5 >= -0.8)
                    Denomi = 1.0 + T5;
                else begin
                    T9 = 1.0 / (7.0 + 10.0 * T5);
                    Denomi = (0.6 + T5) * T9;
                    T9 = T9 * T9;
                    dDenomi_dVg = dDenomi_dVg * T9;
                    dDenomi_dVd = dDenomi_dVd * T9;
                    dDenomi_dVb = dDenomi_dVb * T9;
                end

                T9 = -ueff / Denomi;
                dueff_dVg = T9 * dDenomi_dVg;
                dueff_dVd = T9 * dDenomi_dVd;
                dueff_dVb = T9 * dDenomi_dVb;
            end
`endif


        /* Saturation Drain Voltage  Vdsat */
        WVCox = Weff * here_BSIM4vsattemp * BSIM4coxe;
        WVCoxRds = WVCox * Rds;
        Esat = 2.0 * here_BSIM4vsattemp / ueff;
        EsatL = Esat * Leff;

`ifdef NOISE_DERIVATIVES
            if ((BSIM4tnoiMod == 1) && analysis("noise") == `NOISE) begin
                // Derivatives only needed for this mode.
                T0 = -EsatL /ueff;
                dEsatL_dVg = T0 * dueff_dVg;
                dEsatL_dVd = T0 * dueff_dVd;
                dEsatL_dVb = T0 * dueff_dVb;
            end
`endif

        if (verbose == 1) begin
            $strobe("Esat,L=%g,%g\n", Esat,EsatL);
        end

        /* Sqrt() */
        a1l = BSIM4a1;
        if (a1l == 0.0)
            Lambda = BSIM4a2;
        else if (a1l > 0.0) begin
            T0 = 1.0 - BSIM4a2;
            T1 = T0 - BSIM4a1 * Vgsteff - 0.0001;
            T2 = sqrt(T1 * T1 + 0.0004 * T0);
            Lambda = BSIM4a2 + T0 - 0.5 * (T1 + T2);
        end
        else begin
            T1 = BSIM4a2 + BSIM4a1 * Vgsteff - 0.0001;
            T2 = sqrt(T1 * T1 + 0.0004 * BSIM4a2);
            Lambda = 0.5 * (T1 + T2);
        end // else: !if(a1 > 0.0)

`ifdef NOISE_DERIVATIVES
            if ((BSIM4tnoiMod == 1) && analysis("noise") == `NOISE) begin
                // Derivatives only needed for this mode.
                if (a1l == 0.0)
                    dLambda_dVg = 0.0;
                else if (a1l > 0.0)
                    dLambda_dVg = 0.5 * BSIM4a1 * (1.0 + T1 / T2);
                else
                    dLambda_dVg = 0.5 * BSIM4a1 * (1.0 + T1 / T2);
            end
`endif

        if (verbose == 1)
            $strobe("Lambda=%g\n", Lambda);

        Vgst2Vtm = Vgsteff + 2.0 * Vtm;
        if ((Rds == 0.0) && (Lambda == 1.0)) begin
            T0 = 1.0 / (Abulk * EsatL + Vgst2Vtm);
            T1 = T0 * T0;
            T2 = Vgst2Vtm * T0;
            T3 = EsatL * Vgst2Vtm;
            Vdsat = T3 * T0;
        end
        else begin
            T9 = Abulk * WVCoxRds;
            T8 = Abulk * T9;
            T7 = Vgst2Vtm * T9;
            T6 = Vgst2Vtm * WVCoxRds;
            T0 = 2.0 * Abulk * (T9 - 1.0 + 1.0 / Lambda);
            T1 = Vgst2Vtm * (2.0 / Lambda - 1.0) + Abulk * EsatL + 3.0 * T7;
            T2 = Vgst2Vtm * (EsatL + 2.0 * T6);
            T3 = sqrt(T1 * T1 - 2.0 * T0 * T2);
            Vdsat = (T1 - T3) / T0;
        end


`ifdef NOISE_DERIVATIVES
            if ((BSIM4tnoiMod == 1) && analysis("noise") == `NOISE) begin
                // Derivatives only needed for this mode.
                if (Rds > 0) begin
                    tmp2 = dRds_dVg / Rds + dWeff_dVg / Weff;
                    tmp3 = dRds_dVb / Rds + dWeff_dVb / Weff;
                end
                else begin
                    tmp2 = dWeff_dVg / Weff;
                    tmp3 = dWeff_dVb / Weff;
                end
                if ((Rds == 0.0) && (Lambda == 1.0)) begin
                    tmp1 = 0.0;

                    dT0_dVg = -(Abulk * dEsatL_dVg + EsatL * dAbulk_dVg + 1.0) * T1;
                    dT0_dVd = -(Abulk * dEsatL_dVd) * T1;
                    dT0_dVb = -(Abulk * dEsatL_dVb + dAbulk_dVb * EsatL) * T1;

                    dVdsat_dVg = T3 * dT0_dVg + T2 * dEsatL_dVg + EsatL * T0;
                    dVdsat_dVd = T3 * dT0_dVd + T2 * dEsatL_dVd;
                    dVdsat_dVb = T3 * dT0_dVb + T2 * dEsatL_dVb;
                end
                else begin
                    tmp1 = dLambda_dVg / (Lambda * Lambda);
                    dT0_dVg = 2.0 * (T8 * tmp2 - Abulk * tmp1
                             + (2.0 * T9 + 1.0 / Lambda - 1.0) * dAbulk_dVg);

                    dT0_dVb = 2.0 * (T8 * (2.0 / Abulk * dAbulk_dVb + tmp3)
                               + (1.0 / Lambda - 1.0) * dAbulk_dVb);
                    dT0_dVd = 0.0;

                    dT1_dVg = (2.0 / Lambda - 1.0) - 2.0 * Vgst2Vtm * tmp1
                           + Abulk * dEsatL_dVg + EsatL * dAbulk_dVg + 3.0 *
                           (T9 + T7 * tmp2 + T6 * dAbulk_dVg);
                    dT1_dVb = Abulk * dEsatL_dVb + EsatL * dAbulk_dVb
                           + 3.0 * (T6 * dAbulk_dVb + T7 * tmp3);
                    dT1_dVd = Abulk * dEsatL_dVd;

                    dT2_dVg = EsatL + Vgst2Vtm * dEsatL_dVg
                           + T6 * (4.0 + 2.0 * Vgst2Vtm * tmp2);
                    dT2_dVb = Vgst2Vtm * (dEsatL_dVb + 2.0 * T6 * tmp3);
                    dT2_dVd = Vgst2Vtm * dEsatL_dVd;

                    dT3_dVg = (T1 * dT1_dVg - 2.0 * (T0 * dT2_dVg + T2 * dT0_dVg))
                             / T3;
                    dT3_dVd = (T1 * dT1_dVd - 2.0 * (T0 * dT2_dVd + T2 * dT0_dVd))
                             / T3;
                    dT3_dVb = (T1 * dT1_dVb - 2.0 * (T0 * dT2_dVb + T2 * dT0_dVb))
                             / T3;

                    dVdsat_dVg = (dT1_dVg - (T1 * dT1_dVg - dT0_dVg * T2
                                - T0 * dT2_dVg) / T3 - Vdsat * dT0_dVg) / T0;
                    dVdsat_dVb = (dT1_dVb - (T1 * dT1_dVb - dT0_dVb * T2
                                - T0 * dT2_dVb) / T3 - Vdsat * dT0_dVb) / T0;
                    dVdsat_dVd = (dT1_dVd - (T1 * dT1_dVd - T0 * dT2_dVd) / T3) / T0;
                end
            end
`endif

        if (verbose == 1)
            $strobe("Vdsat=%g\n", Vdsat);

        /* Calculate Vdseff */
        T1 = Vdsat - Vds - BSIM4delta;
        T2 = sqrt(T1 * T1 + 4.0 * BSIM4delta * Vdsat);

        T0 = T1 / T2;
        T9 = 2.0 * BSIM4delta;
        T3 = T9 / T2;

        if (T1 >= 0.0)
            Vdseff = Vdsat - 0.5 * (T1 + T2);
        else begin
            T4 = T9 / (T2 - T1);
            T5 = 1.0 - T4;
            T6 = Vdsat * T4 / (T2 - T1);
            Vdseff = Vdsat * T5;
        end

        if (Vds == 0.0)
            Vdseff = 0.0;

        if (Vdseff > Vds)
            Vdseff = Vds;

        diffVds = Vds - Vdseff;
        here_Vdseff = Vdseff;
        if (verbose == 1)
            $strobe("diffVds=%g\n", diffVds);

`ifdef NOISE_DERIVATIVES
            if ((BSIM4tnoiMod == 1) && analysis("noise") == `NOISE) begin
                // Derivatives only needed for this mode.
                dT1_dVg = dVdsat_dVg;
                dT1_dVd = dVdsat_dVd - 1.0;
                dT1_dVb = dVdsat_dVb;

                dT2_dVg = T0 * dT1_dVg + T3 * dVdsat_dVg;
                dT2_dVd = T0 * dT1_dVd + T3 * dVdsat_dVd;
                dT2_dVb = T0 * dT1_dVb + T3 * dVdsat_dVb;

                if (T1 >= 0.0) begin
                    dVdseff_dVg = dVdsat_dVg - 0.5 * (dT1_dVg + dT2_dVg);
                    dVdseff_dVd = dVdsat_dVd - 0.5 * (dT1_dVd + dT2_dVd);
                    dVdseff_dVb = dVdsat_dVb - 0.5 * (dT1_dVb + dT2_dVb);
                end
                else begin
                    dVdseff_dVg = dVdsat_dVg * T5 + T6 * (dT2_dVg - dT1_dVg);
                    dVdseff_dVd = dVdsat_dVd * T5 + T6 * (dT2_dVd - dT1_dVd);
                    dVdseff_dVb = dVdsat_dVb * T5 + T6 * (dT2_dVb - dT1_dVb);
                end

                if (Vds == 0.0) begin
                    dVdseff_dVg = 0.0;
                    dVdseff_dVb = 0.0;
                end

            end
`endif

        if (verbose == 1)
            $strobe("Vdseff=%g\n", Vdseff);

        /* Velocity Overshoot */
        if (($param_given(lambda)) && (BSIM4lambda > 0.0) ) begin
            T1 = Leff * ueff;
            T2 = BSIM4lambda / T1;
            T3 = -T2 / T1 * Leff;
            T5 = 1.0 / (Esat * BSIM4litl);
            T6 = 1.0 + diffVds  * T5;
            T7 = 2.0 / (T6 * T6 + 1.0);
            T8 = 1.0 - T7;
            T10 = 1.0 + T2 * T8;
            EsatL = EsatL * T10;
            Esat = EsatL / Leff;  /* bugfix by Wenwei Yang (4.6.4) */
        end

        /* Calculate Vasat */
        tmp4 = 1.0 - 0.5 * Abulk * Vdsat / Vgst2Vtm;
        T9 = WVCoxRds * Vgsteff;
        T8 = T9 / Vgst2Vtm;
        T0 = EsatL + Vdsat + 2.0 * T9 * tmp4;
        T9 = WVCoxRds * Abulk;
        T1 = 2.0 / Lambda - 1.0 + T9;

        Vasat = T0 / T1;

`ifdef NOISE_DERIVATIVES
            if ((BSIM4tnoiMod == 1) && analysis("noise") == `NOISE) begin
                // Derivatives only needed for this mode.
                dT0_dVg = dEsatL_dVg + dVdsat_dVg + T7 * (1.0 + tmp2 * Vgsteff)
                - T8 * (Abulk * dVdsat_dVg - Abulk * Vdsat / Vgst2Vtm
                + Vdsat * dAbulk_dVg);
                dT0_dVb = dEsatL_dVb + dVdsat_dVb + T7 * tmp3 * Vgsteff
                - T8 * (dAbulk_dVb * Vdsat + Abulk * dVdsat_dVb);
                dT0_dVd = dEsatL_dVd + dVdsat_dVd - T8 * Abulk * dVdsat_dVd;
                dT1_dVg = -2.0 * tmp1 +  WVCoxRds * (Abulk * tmp2 + dAbulk_dVg);
                dT1_dVb = dAbulk_dVb * WVCoxRds + T9 * tmp3;
                dVasat_dVg = (dT0_dVg - Vasat * dT1_dVg) / T1;
                dVasat_dVb = (dT0_dVb - Vasat * dT1_dVb) / T1;
                dVasat_dVd = dT0_dVd / T1;
            end
`endif

        if (verbose == 1)
            $strobe("Vasat=%g\n", Vasat);

        /* Calculate Idl first */
        tmp1 = here_BSIM4vtfbphi2;
        tmp2 = 2.0e8 * BSIM4toxp;
        T0 = (Vgsteff + tmp1) / tmp2;

        tmp3 = exp(BSIM4bdos * 0.7 * ln(T0));
        T1 = 1.0 + tmp3;
        T2 = BSIM4bdos * 0.7 * tmp3 / T0;
        Tcen = BSIM4ados * 1.9e-9 / T1;

        Coxeff = epssubl * BSIM4coxp / ( epssubl + BSIM4coxp * Tcen);
        CoxeffWovL = Coxeff * Weff / Leff;
        beta = ueff * CoxeffWovL;
        T3 = ueff / Leff;
        AbovVgst2Vtm = Abulk / Vgst2Vtm;
        T0 = 1.0 - 0.5 * Vdseff * AbovVgst2Vtm;
        fgche1 = Vgsteff * T0;
        T9 = Vdseff / EsatL;
        fgche2 = 1.0 + T9;
        gche = beta * fgche1 / fgche2;
        T0 = 1.0 + gche * Rds;
        Idl = gche / T0;
        // T1 = (1.0 - Idl * Rds) / T0;
        // T2 = Idl * Idl;

`ifdef NOISE_DERIVATIVES
            if ((BSIM4tnoiMod == 1) && analysis("noise") == `NOISE) begin
                // Derivatives only needed for this mode.
                dT0_dVg = 1.0 / tmp2;
                T0 = (Vgsteff + tmp1) * dT0_dVg;

                tmp3 = exp(0.7 * ln(T0));
                T1 = 1.0 + tmp3;
                T2 = 0.7 * tmp3 / T0;
                dTcen_dVg = -Tcen * T2 * dT0_dVg / T1;
                dCoxeff_dVg = -Coxeff * Coxeff * dTcen_dVg / `EPSSI;

                dbeta_dVg = CoxeffWovL * dueff_dVg + ueff / Leff
                        * (Weff * dCoxeff_dVg + Coxeff * dWeff_dVg);
                dbeta_dVd = CoxeffWovL * dueff_dVd;
                dbeta_dVb = CoxeffWovL * dueff_dVb + T3 * Coxeff * dWeff_dVb;

                T0 = 1.0 - 0.5 * Vdseff * AbovVgst2Vtm;
                dT0_dVg = -0.5 * (Abulk * dVdseff_dVg
                         - Abulk * Vdseff / Vgst2Vtm + Vdseff * dAbulk_dVg)
                         / Vgst2Vtm;
                dT0_dVd = -0.5 * Abulk * dVdseff_dVd / Vgst2Vtm;
                dT0_dVb = -0.5 * (Abulk * dVdseff_dVb + dAbulk_dVb * Vdseff)
                        / Vgst2Vtm;

                dfgche1_dVg = Vgsteff * dT0_dVg + T0;
                dfgche1_dVd = Vgsteff * dT0_dVd;
                dfgche1_dVb = Vgsteff * dT0_dVb;

                dfgche2_dVg = (dVdseff_dVg - T9 * dEsatL_dVg) / EsatL;
                dfgche2_dVd = (dVdseff_dVd - T9 * dEsatL_dVd) / EsatL;
                dfgche2_dVb = (dVdseff_dVb - T9 * dEsatL_dVb) / EsatL;

                dgche_dVg = (beta * dfgche1_dVg + fgche1 * dbeta_dVg
                         - gche * dfgche2_dVg) / fgche2;
                dgche_dVd = (beta * dfgche1_dVd + fgche1 * dbeta_dVd
                         - gche * dfgche2_dVd) / fgche2;
                dgche_dVb = (beta * dfgche1_dVb + fgche1 * dbeta_dVb
                         - gche * dfgche2_dVb) / fgche2;

                T0 = 1.0 + gche * Rds;
                T1 = (1.0 - Idl * Rds) / T0;
                T2 = Idl * Idl;
                dIdl_dVg = T1 * dgche_dVg - T2 * dRds_dVg;
                dIdl_dVd = T1 * dgche_dVd;
                dIdl_dVb = T1 * dgche_dVb - T2 * dRds_dVb;
            end
`endif

        if (verbose == 1)
            $strobe("Idl=%g\n", Idl);

        /* Calculate degradation factor due to pocket implant */

        if (BSIM4fprout <= 0.0) begin
            FP = 1.0;

`ifdef NOISE_DERIVATIVES
                if ((BSIM4tnoiMod == 1) && analysis("noise") == `NOISE) begin
                    // Derivatives only needed for this mode.
                    dFP_dVg = 0.0;
                end
`endif
        end
        else begin
            T9 = BSIM4fprout * sqrt(Leff) / Vgst2Vtm;
            FP = 1.0 / (1.0 + T9);

`ifdef NOISE_DERIVATIVES
                if ((BSIM4tnoiMod == 1) && analysis("noise") == `NOISE) begin
                    // Derivatives only needed for this mode.
                    dFP_dVg = FP * FP * T9 / Vgst2Vtm;
                end
`endif
        end
        if (verbose == 1)
            $strobe("FP=%g\n", FP);

        /* Calculate VACLM */
        T8 = BSIM4pvag / EsatL;
        T9 = T8 * Vgsteff;
        if (T9 > -0.9) begin
            PvagTerm = 1.0 + T9;

`ifdef NOISE_DERIVATIVES
                if ((BSIM4tnoiMod == 1) && analysis("noise") == `NOISE) begin
                    // Derivatives only needed for this mode.
                    dPvagTerm_dVg = T8 * (1.0 - Vgsteff * dEsatL_dVg / EsatL);
                    dPvagTerm_dVb = -T9 * dEsatL_dVb / EsatL;
                    dPvagTerm_dVd = -T9 * dEsatL_dVd / EsatL;
                end
`endif
        end
        else begin
            T4 = 1.0 / (17.0 + 20.0 * T9);
            PvagTerm = (0.8 + T9) * T4;

`ifdef NOISE_DERIVATIVES
                if ((BSIM4tnoiMod == 1) && analysis("noise") == `NOISE) begin
                    // Derivatives only needed for this mode.
                    T4 = T4 * (  T4);
                    dPvagTerm_dVg = T8 * (1.0 - Vgsteff * dEsatL_dVg / EsatL) * T4;
                    T9 = T9 * (  T4 / EsatL);
                    dPvagTerm_dVb = -T9 * dEsatL_dVb;
                    dPvagTerm_dVd = -T9 * dEsatL_dVd;
                end
`endif
        end

        if ((BSIM4pclm > `MIN_EXP) && (diffVds > 1.0e-10)) begin
            T0 = 1.0 + Rds * Idl;
            T2 = Vdsat / Esat;
            T1 = Leff + T2;

            Cclm = FP * PvagTerm * T0 * T1 / (BSIM4pclm * BSIM4litl);
            VACLM = Cclm * diffVds;

`ifdef NOISE_DERIVATIVES
                if ((BSIM4tnoiMod == 1) && analysis("noise") == `NOISE) begin
                    // Derivatives only needed for this mode.
                    dT0_dVg = dRds_dVg * Idl + Rds * dIdl_dVg;
                    dT0_dVd = Rds * dIdl_dVd;
                    dT0_dVb = dRds_dVb * Idl + Rds * dIdl_dVb;
                    dT1_dVg = (dVdsat_dVg - T2 * dEsatL_dVg / Leff) / Esat;
                    dT1_dVd = (dVdsat_dVd - T2 * dEsatL_dVd / Leff) / Esat;
                    dT1_dVb = (dVdsat_dVb - T2 * dEsatL_dVb / Leff) / Esat;

                    dCclm_dVg = Cclm * (dFP_dVg / FP + dPvagTerm_dVg / PvagTerm
                          + dT0_dVg / T0 + dT1_dVg / T1);
                    dCclm_dVb = Cclm * (dPvagTerm_dVb / PvagTerm + dT0_dVb / T0
                          + dT1_dVb / T1);
                    dCclm_dVd = Cclm * (dPvagTerm_dVd / PvagTerm + dT0_dVd / T0
                          + dT1_dVd / T1);

                    dVACLM_dVg = dCclm_dVg * diffVds - dVdseff_dVg * Cclm;
                    dVACLM_dVb = dCclm_dVb * diffVds - dVdseff_dVb * Cclm;
                    dVACLM_dVd = dCclm_dVd * diffVds + (1.0 - dVdseff_dVd) * Cclm;
                end
`endif
        end
        else begin
            VACLM = `MAX_EXP;
            Cclm = `MAX_EXP;

`ifdef NOISE_DERIVATIVES
                if ((BSIM4tnoiMod == 1) && analysis("noise") == `NOISE) begin
                    // Derivatives only needed for this mode.
                    dVACLM_dVd = 0.0;
                    dVACLM_dVg = 0.0;
                    dVACLM_dVb = 0.0;
                    dCclm_dVd = 0.0;
                    dCclm_dVg = 0.0;
                end
`endif
        end
        if (verbose == 1)
            $strobe("VACLM=%g\n", VACLM);

        /* Calculate VADIBL */
        if (BSIM4thetaRout > `MIN_EXP) begin
            T8 = Abulk * Vdsat;
            T0 = Vgst2Vtm * T8;
            T1 = Vgst2Vtm + T8;
            T9 = T1 * T1;
            T2 = BSIM4thetaRout;

            VADIBL = (Vgst2Vtm - T0 / T1) / T2;

            T7 = BSIM4pdiblb * Vbseff;
            if (T7 >= -0.9) begin
                T3 = 1.0 / (1.0 + T7);
                VADIBL = VADIBL * T3;
            end
            else begin
                T4 = 1.0 / (0.8 + T7);
                T3 = (17.0 + 20.0 * T7) * T4;
                VADIBL = VADIBL * T3;
            end
            VADIBL = VADIBL * (  PvagTerm);
        end
        else
            VADIBL = `MAX_EXP;

        if (verbose == 1)
            $strobe("ELSE VADIBL=%g\n", VADIBL);

`ifdef NOISE_DERIVATIVES
            if ((BSIM4tnoiMod == 1) && analysis("noise") == `NOISE) begin
                // Derivatives only needed for this mode.
                if (BSIM4thetaRout > 0.0) begin
                    T8 = Abulk * Vdsat;
                    T0 = Vgst2Vtm * T8;
                    dT0_dVg = Vgst2Vtm * Abulk * dVdsat_dVg + T8
                          + Vgst2Vtm * Vdsat * dAbulk_dVg;
                    dT0_dVb = Vgst2Vtm * (dAbulk_dVb * Vdsat + Abulk * dVdsat_dVb);
                    dT0_dVd = Vgst2Vtm * Abulk * dVdsat_dVd;

                    T1 = Vgst2Vtm + T8;
                    dT1_dVg = 1.0 + Abulk * dVdsat_dVg + Vdsat * dAbulk_dVg;
                    dT1_dVb = Abulk * dVdsat_dVb + dAbulk_dVb * Vdsat;
                    dT1_dVd = Abulk * dVdsat_dVd;

                    T9 = T1 * T1;
                    T2 = BSIM4thetaRout;
                    VADIBL = (Vgst2Vtm - T0 / T1) / T2;
                    dVADIBL_dVg = (1.0 - dT0_dVg / T1 + T0 * dT1_dVg / T9) / T2;
                    dVADIBL_dVb = (-dT0_dVb / T1 + T0 * dT1_dVb / T9) / T2;
                    dVADIBL_dVd = (-dT0_dVd / T1 + T0 * dT1_dVd / T9) / T2;

                    T7 = BSIM4pdiblb * Vbseff;
                    if (T7 >= -0.9) begin
                        T3 = 1.0 / (1.0 + T7);
                        VADIBL = VADIBL * T3;
                        dVADIBL_dVg = dVADIBL_dVg * T3;
                        dVADIBL_dVb = (dVADIBL_dVb - VADIBL * BSIM4pdiblb)
                                   * T3;
                        dVADIBL_dVd = dVADIBL_dVd * T3;
                    end
                    else begin
                        T4 = 1.0 / (0.8 + T7);
                        T3 = (17.0 + 20.0 * T7) * T4;
                        dVADIBL_dVg = dVADIBL_dVg * T3;
                        dVADIBL_dVb = dVADIBL_dVb * T3
                                  - VADIBL * BSIM4pdiblb * T4 * T4;
                        dVADIBL_dVd = dVADIBL_dVd * T3;
                        VADIBL = VADIBL * T3;
                    end

                    dVADIBL_dVg = dVADIBL_dVg * PvagTerm + VADIBL * dPvagTerm_dVg;
                    dVADIBL_dVb = dVADIBL_dVb * PvagTerm + VADIBL * dPvagTerm_dVb;
                    dVADIBL_dVd = dVADIBL_dVd * PvagTerm + VADIBL * dPvagTerm_dVd;
                    VADIBL = VADIBL * (  PvagTerm);
                end
                else begin
                    VADIBL = `MAX_EXP;

                    dVADIBL_dVd = 0.0;
                    dVADIBL_dVg = 0.0;
                    dVADIBL_dVb = 0.0;
                end
            end
            if (verbose == 1)
                $strobe("NOISE VADIBL=%g\n", VADIBL);
`endif


        /* Calculate Va */
        Va = Vasat + VACLM;

`ifdef NOISE_DERIVATIVES
            if ((BSIM4tnoiMod == 1) && analysis("noise") == `NOISE) begin
                // Derivatives only needed for this mode.
                dVa_dVg = dVasat_dVg + dVACLM_dVg;
                dVa_dVb = dVasat_dVb + dVACLM_dVb;
                dVa_dVd = dVasat_dVd + dVACLM_dVd;
            end
`endif

        if (verbose == 1)
            $strobe("Va=%g\n", Va);

        /* Calculate VADITS */
        T0 = BSIM4pditsd * Vds;
        if (T0 > `EXP_THRESHOLD)
            T1 = `MAX_EXP;
        else
            T1 = exp(T0);

        if (BSIM4pdits > `MIN_EXP) begin
            T2 = 1.0 + BSIM4pditsl * Leff;
            VADITS = (1.0 + T2 * T1) / BSIM4pdits;
            VADITS = VADITS * FP;
        end
        else
            VADITS = `MAX_EXP;

        if (verbose == 1)
            $strobe("VADITS=%g\n", VADITS);

`ifdef NOISE_DERIVATIVES
            if ((BSIM4tnoiMod == 1) && analysis("noise") == `NOISE) begin
                // Derivatives only needed for this mode.
                T0 = BSIM4pditsd * Vds;
                if (T0 > `EXP_THRESHOLD)
                    dT1_dVd = 0;
                else
                    dT1_dVd = T1 * BSIM4pditsd;
            end
`endif

`ifdef NOISE_DERIVATIVES
            if ((BSIM4tnoiMod == 1) && analysis("noise") == `NOISE) begin
                // Derivatives only needed for this mode.
                dVASCBE_dVg = 0.0;
                dVASCBE_dVd = 0.0;
                dVASCBE_dVb = 0.0;
            end
`endif

        /* Calculate VASCBE */
        if (BSIM4pscbe2 > 0.0 && BSIM4pscbe1 >=0.0) begin
            if (diffVds > BSIM4pscbe1 * BSIM4litl / `EXP_THRESHOLD) begin
                T0 = BSIM4pscbe1 * BSIM4litl / diffVds;
                VASCBE = Leff * exp(T0) / BSIM4pscbe2;

`ifdef NOISE_DERIVATIVES
                    if ((BSIM4tnoiMod == 1) && analysis("noise") == `NOISE) begin
                        // Derivatives only needed for this mode.
                        T1 = T0 * VASCBE / diffVds;
                        dVASCBE_dVg = T1 * dVdseff_dVg;
                        dVASCBE_dVd = -T1 * (1.0 - dVdseff_dVd);
                        dVASCBE_dVb = T1 * dVdseff_dVb;
                    end
`endif
            end
            else
                VASCBE = `MAX_EXP * Leff/BSIM4pscbe2;
        end
        else
            VASCBE = `MAX_EXP;

        if (verbose == 1)
            $strobe("VASCBE=%g\n", VASCBE);

        /* Add DIBL to Ids */
        T9 = diffVds / VADIBL;
        T0 = 1.0 + T9;
        if (verbose == 1) begin
            $strobe("T9=%g\n", T9);
            $strobe("VADIBL=%g\n", VADIBL);
            $strobe("diffVds=%g\n", diffVds);
            $strobe("Idl=%g\n", Idl);
        end
        Idsa = Idl * T0;

        /* Add DITS to Ids */
        T9 = diffVds / VADITS;
        if (verbose == 1)
            $strobe("T9=%g\n", T9);
        T0 = 1.0 + T9;
        Idsa = Idsa * T0;
        if (verbose == 1)
            $strobe("Idsa=%g\n", Idsa);

        /* Add CLM to Ids */
        T0 = ln(Va / Vasat);
        T1 = T0 / Cclm;
        T9 = 1.0 + T1;

        Idsa = Idsa * T9;
        if (verbose == 1)
            $strobe("Idsa=%g\n", Idsa);

`ifdef NOISE_DERIVATIVES
            if ((BSIM4tnoiMod == 1) && analysis("noise") == `NOISE) begin
                // Derivatives only needed for this mode.
                dIdsa_dVg = T0 * dIdl_dVg - Idl * (dVdseff_dVg + T9 * dVADIBL_dVg)
                         / VADIBL;
                dIdsa_dVd = T0 * dIdl_dVd + Idl
                         * (1.0 - dVdseff_dVd - T9 * dVADIBL_dVd) / VADIBL;
                dIdsa_dVb = T0 * dIdl_dVb - Idl * (dVdseff_dVb + T9 * dVADIBL_dVb)
                         / VADIBL;
            end
`endif

`ifdef NOISE_DERIVATIVES
            if ((BSIM4tnoiMod == 1) && analysis("noise") == `NOISE) begin
                // Derivatives only needed for this mode.
                dT0_dVg = dVa_dVg / Va - dVasat_dVg / Vasat;
                dT0_dVb = dVa_dVb / Va - dVasat_dVb / Vasat;
                dT0_dVd = dVa_dVd / Va - dVasat_dVd / Vasat;
                dT9_dVg = (dT0_dVg - T1 * dCclm_dVg) / Cclm;
                dT9_dVb = (dT0_dVb - T1 * dCclm_dVb) / Cclm;
                dT9_dVd = (dT0_dVd - T1 * dCclm_dVd) / Cclm;
                dIdsa_dVg = dIdsa_dVg * T9 + Idsa * dT9_dVg;
                dIdsa_dVb = dIdsa_dVb * T9 + Idsa * dT9_dVb;
                dIdsa_dVd = dIdsa_dVd * T9 + Idsa * dT9_dVd;
            end
`endif


        /* Substrate current begins */
        tmp = BSIM4alpha0 + BSIM4alpha1 * Leff;
        if ((tmp <= 0.0) || (BSIM4beta0 <= 0.0)) begin
            Isub = 0.0;
        end
        else begin
            T2 = tmp / Leff;
            if (diffVds > BSIM4beta0 / `EXP_THRESHOLD) begin
                T0 = -BSIM4beta0 / diffVds;
                T1 = T2 * diffVds * exp(T0);
                T3 = T1 / diffVds * (T0 - 1.0);
            end
            else begin
                T3 = T2 * `MIN_EXP;
                T1 = T3 * diffVds;
            end
            T4 = Idsa * Vdseff;
            Isub = T1 * T4;
        end

`ifdef NOISE_DERIVATIVES
            if ((BSIM4tnoiMod == 1) && analysis("noise") == `NOISE) begin
                // Derivatives only needed for this mode.
                if ((tmp <= 0.0) || (BSIM4beta0 <= 0.0)) begin
                    Isub = 0.0;
                end
                else begin
                    T2 = tmp / Leff;
                    if (diffVds > BSIM4beta0 / `EXP_THRESHOLD) begin
                        T0 = -BSIM4beta0 / diffVds;
                        T1 = T2 * diffVds * exp(T0);
                        T3 = T1 / diffVds * (T0 - 1.0);
                        dT1_dVg = T3 * dVdseff_dVg;
                        dT1_dVd = T3 * (dVdseff_dVd - 1.0);
                        dT1_dVb = T3 * dVdseff_dVb;
                    end
                    else begin
                        T3 = T2 * `MIN_EXP;
                        T1 = T3 * diffVds;
                        dT1_dVg = -T3 * dVdseff_dVg;
                        dT1_dVd = T3 * (1.0 - dVdseff_dVd);
                        dT1_dVb = -T3 * dVdseff_dVb;
                    end
                end
            end
`endif
        if (verbose == 1)
            $strobe("Isub=%g\n", Isub);

        /* Add SCBE to Ids */
        T9 = diffVds / VASCBE;
        T0 = 1.0 + T9;
        Ids = Idsa * T0;


`ifdef NOISE_DERIVATIVES
            if ((BSIM4tnoiMod == 1) && analysis("noise") == `NOISE) begin
                // Derivatives only needed for this mode.

                Gm = T0 * dIdsa_dVg - Idsa
                  * (dVdseff_dVg + T9 * dVASCBE_dVg) / VASCBE;
                Gds = T0 * dIdsa_dVd + Idsa
                   * (1.0 - dVdseff_dVd - T9 * dVASCBE_dVd) / VASCBE;
                Gmb = T0 * dIdsa_dVb - Idsa
                   * (dVdseff_dVb + T9 * dVASCBE_dVb) / VASCBE;

                tmp1 = Gds + Gm * dVgsteff_dVd;
                tmp2 = Gmb + Gm * dVgsteff_dVb;
                tmp3 = Gm;

                Gm = (Ids * dVdseff_dVg + Vdseff * tmp3) * dVgsteff_dVg;
                Gds = Ids * (dVdseff_dVd + dVdseff_dVg * dVgsteff_dVd)
                + Vdseff * tmp1;
                Gmb = (Ids * (dVdseff_dVb + dVdseff_dVg * dVgsteff_dVb)
                   + Vdseff * tmp2) * dVbseff_dVb;
            end
`endif

        cdrain = Ids * Vdseff;
        if (verbose == 1) begin
            $strobe("Ids=%g\n", Ids);
            $strobe("cdrain=%g\n", cdrain);
        end

        /* Source End Velocity Limit  */
        // VA: Needs better FPE protection...
        if (($param_given(vtl)) && (BSIM4vtl > 0.0)) begin
            T12 = 1.0 / Leff / CoxeffWovL;
            T11 = T12 / Vgsteff;
            vs = cdrain * T11;
            T0 = 2 * `MM;
            T1 = vs / (BSIM4vtl * BSIM4tfactor);
            if (T1 >0.0) begin
                T2 = 1.0 + exp(T0 * ln(T1));
                Fsevl = 1.0 / exp(ln(T2)/ T0);
            end
            else
                Fsevl = 1.0;

            //Fsevl = 1.0 / exp(ln(T2) / T0);
            cdrain = cdrain * Fsevl;
            if (verbose == 1)
                $strobe("cdrain (source end velocity limit)=%g\n", cdrain);
        end
        IdovVds = Ids;
        if ( IdovVds <= 1.0e-9)
            IdovVds = 1.0e-9;

        /* Calculate Rg */
        if ((BSIM4rgateMod > 1)  ||
            (BSIM4trnqsMod != 0) ||
            (BSIM4acnqsMod != 0)) begin

            T9 = BSIM4xrcrg2 * BSIM4vtm;
            T0 = T9 * beta;

            BSIM4gcrg = BSIM4xrcrg1 * (T0 + Ids);

            if (BSIM4nf != 1.0)
                BSIM4gcrg = BSIM4gcrg * BSIM4nf;

            if (BSIM4rgateMod == 2) begin
                T10 = BSIM4grgeltd * BSIM4grgeltd;
                T11 = BSIM4grgeltd + BSIM4gcrg;
                BSIM4gcrg = BSIM4grgeltd * BSIM4gcrg / T11;
            end
        end

        /* Calculate bias-dependent external S/D resistance */
        if (BSIM4rdsMod) begin
            /* Rs(V) */
            T0 = vgs - BSIM4vfbsd;
            T1 = sqrt(T0 * T0 + 1.0e-4);
            vgs_eff = 0.5 * (T0 + T1);

            T0 = 1.0 + BSIM4prwg * vgs_eff;
            T1 = -BSIM4prwb * vbs;

            T2 = 1.0 / T0 + T1;
            T3 = T2 + sqrt(T2 * T2 + 0.01);

            T4 = BSIM4rs0 * 0.5;
            Rs = BSIM4rswmin + T3 * T4;
            if (verbose == 1) begin
                $strobe("BSIM4vfbsd=%g\n",BSIM4vfbsd);
                $strobe("BSIM4prwg=%g\n",BSIM4prwg);
                $strobe("BSIM4prwb=%g\n",BSIM4prwb);
                $strobe("BSIM4rs0=%g\n",BSIM4rs0);
                $strobe("BSIM4rswmin=%g\n",BSIM4rswmin);
                $strobe("vgs_eff=%g\n",vgs_eff);
                $strobe("T0=%g\n",T0);
                $strobe("T1=%g\n",T1);
                $strobe("T2=%g\n",T2);
                $strobe("T3=%g\n",T3);
                $strobe("T4=%g\n",T4);
                $strobe("Rs=%g\n",Rs);
            end

            /* Rd(V) */
            T0 = vgd - BSIM4vfbsd;
            T1 = sqrt(T0 * T0 + 1.0e-4);
            vgd_eff = 0.5 * (T0 + T1);

            T0 = 1.0 + BSIM4prwg * vgd_eff;
            T1 = -BSIM4prwb * vbd;

            T2 = 1.0 / T0 + T1;
            T3 = T2 + sqrt(T2 * T2 + 0.01);

            T4 = BSIM4rd0 * 0.5;
            Rd = BSIM4rdwmin + T3 * T4;

        end

`ifdef NOISE_DERIVATIVES
            if ((BSIM4tnoiMod == 1) && analysis("noise") == `NOISE) begin
                // Derivatives only needed for this mode.
                dvgs_eff_dvg = vgs_eff / T1;

                T0 = 1.0 + BSIM4prwg * vgs_eff;
                dT0_dvg = -BSIM4prwg / T0 / T0 * dvgs_eff_dvg;
                T1 = -BSIM4prwb * vbs;

                T2 = 1.0 / T0 + T1;
                T3 = T2 + sqrt(T2 * T2 + 0.01);
                dT3_dvg = T3 / (T3 - T2);
                dT3_dvg = dT3_dvg * dT0_dvg;

                T4 = BSIM4rs0 * 0.5;

                T0 = 1.0 + BSIM4sourceConductance * Rs;
                BSIM4gstot = BSIM4sourceConductance / T0;
                if (verbose == 1)
                    $strobe("BSIM4gstot=%g\n",BSIM4gstot);

                T0 = -BSIM4gstot * BSIM4gstot;

                /* Rd(V) */
                T0 = vgd - BSIM4vfbsd;
                T1 = sqrt(T0 * T0 + 1.0e-4);
                vgd_eff = 0.5 * (T0 + T1);
                dvgd_eff_dvg = vgd_eff / T1;

                T0 = 1.0 + BSIM4prwg * vgd_eff;
                dT0_dvg = -BSIM4prwg / T0 / T0 * dvgd_eff_dvg;
                T1 = -BSIM4prwb * vbd;

                T2 = 1.0 / T0 + T1;
                T3 = T2 + sqrt(T2 * T2 + 0.01);
                dT3_dvg = T3 / (T3 - T2);
                dT3_dvg = dT3_dvg * dT0_dvg;

                T4 = BSIM4rd0 * 0.5;

                T0 = 1.0 + BSIM4drainConductance * Rd;
                BSIM4gdtot = BSIM4drainConductance / T0;
                T0 = -BSIM4gdtot * BSIM4gdtot;
            end
`endif
        /* GIDL/GISL Models */
        if (BSIM4mtrlmod == 0)
            T0 = 3.0 * toxel;
        else
            T0 = BSIM4epsrsub * toxel / epsroxl;

        /* Calculate GIDL current */
        if (BSIM4gidlMod==0) begin
            if (BSIM4mtrlmod ==0)
                T1 = (vds - vgs_eff - BSIM4egidl ) / T0;
            else
                T1 = (vds - vgs_eff - BSIM4egidl + BSIM4vfbsd) / T0;

            if ((BSIM4agidl <= 0.0) || (BSIM4bgidl <= 0.0)
                || (T1 <= 0.0) || (BSIM4cgidl <= 0.0) || (vbd > 0.0))
                Igidl = 0.0;
            else begin
                T2 = BSIM4bgidl / T1;
                if (T2 < 100.0) begin
                    Igidl = BSIM4agidl * BSIM4weffCJ * T1 * exp(-T2);
                    T3 = Igidl * (1.0 + T2) / T1;
                end
                else begin
                    Igidl = BSIM4agidl * BSIM4weffCJ * 3.720075976e-44;
                    Igidl = Igidl * T1;
                end

                T4 = vbd * vbd;
                T5 = -vbd * T4;
                T6 = BSIM4cgidl + T5;
                T7 = T5 / T6;
                //T8 = 3.0 * BSIM4cgidl * T4 / T6 / T6;
                Igidl = Igidl * T7;
            end

            /* Calculate GISL current: bugfix recommended by TI  -JX */
            if (BSIM4mtrlmod ==0)
                T1 = (-vds - vgd_eff - BSIM4egisl ) / T0;
            else
                T1 = (-vds - vgd_eff - BSIM4egisl + BSIM4vfbsd ) / T0;

            if ((BSIM4agisl <= 0.0) || (BSIM4bgisl <= 0.0)
                || (T1 <= 0.0) || (BSIM4cgisl <= 0.0) || (vbs > 0.0))
                Igisl = 0.0;
            else begin
                T2 = BSIM4bgisl / T1;
                if (T2 < 100.0) begin
                    Igisl = BSIM4agisl * BSIM4weffCJ * T1 * exp(-T2);
                    //T3 = Igisl * (1.0 + T2) / T1;
                end
                else begin
                    Igisl = BSIM4agisl * BSIM4weffCJ * 3.720075976e-44;
                    Igisl = Igisl * T1;
                end
                T4 = vbs * vbs;
                T5 = -vbs * T4;
                T6 = BSIM4cgisl + T5;
                T7 = T5 / T6;
                Igisl = Igisl * T7;
            end
        end
        else begin
            /* v4.7 New Gidl/GISL model */

            /* GISL */
            if (BSIM4mtrlmod==0)
                T1 = (-vds - BSIM4rgisl * vgd_eff - BSIM4egisl) / T0;
            else
                T1 = (-vds - BSIM4rgisl * vgd_eff - BSIM4egisl + BSIM4vfbsd) / T0;

            if ((BSIM4agisl <= 0.0) ||
                            (BSIM4bgisl <= 0.0) || (T1 <= 0.0) ||
                            (BSIM4cgisl < 0.0)  )
                Igisl = 0.0;
            else
            begin
                T2 = BSIM4bgisl / T1;
                if (T2 < `EXPL_THRESHOLD)
                    Igisl = BSIM4weffCJ * BSIM4agisl * T1 * exp(-T2);
                else
                begin
                    T3 = BSIM4weffCJ * BSIM4agisl * `MIN_EXPL;
                    Igisl = T3 * T1 ;

                end
                T4 = vbs - BSIM4fgisl;

                if (T4==0)
                    T5 = `EXPL_THRESHOLD;
                else
                    T5 = BSIM4kgisl / T4;
                if (T5<`EXPL_THRESHOLD)
                    T6 = exp(T5);
                else
                    T6 = `MAX_EXPL;
                Igisl=Igisl*T6;

            end
            /* End of GISL */

            /* GIDL */
            if (BSIM4mtrlmod==0)
                T1 = (vds - BSIM4rgidl * vgs_eff - BSIM4egidl) /  T0;
            else
                T1 = (vds - BSIM4rgidl * vgs_eff - BSIM4egidl + BSIM4vfbsd) / T0;

            if ((BSIM4agidl <= 0.0) ||
                            (BSIM4bgidl <= 0.0) || (T1 <= 0.0) ||
                            (BSIM4cgidl < 0.0)  )
                Igidl = 0.0;
            else
            begin
                dT1_dVd = 1 / T0;
                dT1_dVg = - BSIM4rgidl * dT1_dVd * dvgs_eff_dvg;
                T2 = BSIM4bgidl / T1;
                if (T2 < `EXPL_THRESHOLD)
                begin
                    Igidl = BSIM4weffCJ * BSIM4agidl * T1 * exp(-T2);
                end else
                begin
                    T3 = BSIM4weffCJ * BSIM4agidl * `MIN_EXPL;
                    Igidl = T3 * T1 ;
                end
                T4 = vbd - BSIM4fgidl;
                if (T4==0)
                    T5 = `EXPL_THRESHOLD;
                else
                    T5 = BSIM4kgidl / T4;
                if (T5<`EXPL_THRESHOLD)
                    T6 = exp(T5);
                else
                    T6 = `MAX_EXPL;
                Igidl = Igidl*T6;
            end
            /* End of New GIDL */
        end
        if (verbose == 1) begin
            $strobe("Igisl=%g\n", Igisl);
            $strobe("Igidl=%g\n", Igidl);
        end
        /*End of Gidl*/

        /* Calculate gate tunneling current */
        if ((BSIM4igcMod != 0) || (BSIM4igbMod != 0)) begin
            Vfb = here_BSIM4vfbzb;
            V3 = Vfb - Vgs_eff + Vbseff - `DELTA_3;
            if (Vfb <= 0.0)
                T0 = sqrt(V3 * V3 - 4.0 * `DELTA_3 * Vfb);
            else
                T0 = sqrt(V3 * V3 + 4.0 * `DELTA_3 * Vfb);

            T1 = 0.5 * (1.0 + V3 / T0);
            Vfbeff = Vfb - 0.5 * (V3 + T0);

            Voxacc = Vfb - Vfbeff;
            if (Voxacc < 0.0) /* WDLiu: Avoiding numerical instability. */
                Voxacc = 0.0;

            T0 = 0.5 * BSIM4k1ox;
            T3 = Vgs_eff - Vfbeff - Vbseff - Vgsteff;
            if (BSIM4k1ox == 0.0)
                Voxdepinv = 0.0;
            else if (T3 < 0.0)
                Voxdepinv = -T3;
            else begin
                T1 = sqrt(T0 * T0 + T3);
                //T2 = T0 / T1;
                Voxdepinv = BSIM4k1ox * (T1 - T0);
            end

            Voxdepinv = Voxdepinv + Vgsteff;
        end

`ifdef NOISE_DERIVATIVES
            if ((BSIM4tnoiMod == 1) && analysis("noise") == `NOISE) begin
                // Derivatives only needed for this mode.
                if ((BSIM4igcMod != 0) || (BSIM4igbMod != 0)) begin
                    V3 = Vfb - Vgs_eff + Vbseff - `DELTA_3;
                    if (Vfb <= 0.0)
                        T0 = sqrt(V3 * V3 - 4.0 * `DELTA_3 * Vfb);
                    else
                        T0 = sqrt(V3 * V3 + 4.0 * `DELTA_3 * Vfb);
                    T1 = 0.5 * (1.0 + V3 / T0);
                    dVfbeff_dVg = T1 * dVgs_eff_dVg;
                    dVfbeff_dVb = -T1; /* WDLiu: -No surprise? No. -Good! */

                    dVoxacc_dVg = -dVfbeff_dVg;
                    dVoxacc_dVb = -dVfbeff_dVb;
                    if (Voxacc < 0.0) begin
                        dVoxacc_dVg = 0.0;
                        dVoxacc_dVb = 0.0;
                    end

                    T0 = 0.5 * BSIM4k1ox;
                    T3 = Vgs_eff - Vfbeff - Vbseff - Vgsteff;
                    if (BSIM4k1ox == 0.0) begin
                        dVoxdepinv_dVd = 0.0;
                        dVoxdepinv_dVg = 0.0;
                        dVoxdepinv_dVd = 0.0;
                        dVoxdepinv_dVb = 0.0;
                    end
                    else if (T3 < 0.0) begin
                        dVoxdepinv_dVg = -dVgs_eff_dVg + dVfbeff_dVg + dVgsteff_dVg;
                        dVoxdepinv_dVd = dVgsteff_dVd;
                        dVoxdepinv_dVb = dVfbeff_dVb + 1.0 + dVgsteff_dVb;
                    end
                    else begin
                        T1 = sqrt(T0 * T0 + T3);
                        T2 = T0 / T1;
                        dVoxdepinv_dVg = T2 * (dVgs_eff_dVg - dVfbeff_dVg
                                           - dVgsteff_dVg);
                        dVoxdepinv_dVd = -T2 * dVgsteff_dVd;
                        dVoxdepinv_dVb = -T2 * (dVfbeff_dVb + 1.0 + dVgsteff_dVb);
                    end

                    dVoxdepinv_dVg = dVoxdepinv_dVg + (  dVgsteff_dVg);
                    dVoxdepinv_dVd = dVoxdepinv_dVd + (  dVgsteff_dVd);
                    dVoxdepinv_dVb = dVoxdepinv_dVb + (  dVgsteff_dVb);
                end
            end
`endif

        if (verbose == 1)
            $strobe("Voxdepinv=%g\n", Voxdepinv);

        if (BSIM4tempMod < 2)
            tmp = Vtm;
        else /* model->BSIM4tempMod = 2 , 3*/
            tmp = Vtm0;

        if (BSIM4igcMod) begin
            T0 = tmp * BSIM4nigc;
            if (BSIM4igcMod == 1) begin
                VxNVt = (Vgs_eff - BSIM4type * here_BSIM4vth0) / T0;
                if (VxNVt > `EXP_THRESHOLD)
                    Vaux = Vgs_eff - BSIM4type * here_BSIM4vth0;
            end else if (BSIM4igcMod == 2) begin
                VxNVt = (Vgs_eff - Vth) / T0;
                if (VxNVt > `EXP_THRESHOLD)
                    Vaux = Vgs_eff - Vth;
            end
            if (VxNVt < -`EXP_THRESHOLD)
            begin
                Vaux = T0 * ln(1.0 + `MIN_EXP);
                //dVaux_dVg = dVaux_dVd = dVaux_dVb = 0.0;
            end
            else if ((VxNVt >= -`EXP_THRESHOLD) && (VxNVt <= `EXP_THRESHOLD))
            begin
                ExpVxNVt = exp(VxNVt);
                Vaux = T0 * ln(1.0 + ExpVxNVt);
                //dVaux_dVg = ExpVxNVt / (1.0 + ExpVxNVt);
                //if(BSIM4igcMod == 1) begin
                //    dVaux_dVd = 0.0;
                //  dVaux_dVb = 0.0;
                //end else if (BSIM4igcMod == 2) begin
                //    dVaux_dVd = -dVaux_dVg* dVth_dVd;  /* Synopsys 08/30/2013 modify */
                //    dVaux_dVb = -dVaux_dVg* dVth_dVb;  /* Synopsys 08/30/2013 modify */
                //end
                //dVaux_dVg *= dVgs_eff_dVg;
            end


            T2 = Vgs_eff * Vaux;
            T11 = BSIM4Aechvb;
            T3 = BSIM4aigc * BSIM4cigc - BSIM4bigc;
            T4 = BSIM4bigc * BSIM4cigc;
            T5 = BSIM4Bechvb * (BSIM4aigc + T3 * Voxdepinv
            - T4 * Voxdepinv * Voxdepinv);

            if (T5 > `EXP_THRESHOLD)
                T6 = `MAX_EXP;
            else if (T5 < -`EXP_THRESHOLD)
                T6 = `MIN_EXP;
            else
                T6 = exp(T5);

            Igc = T11 * T2 * T6;

            if ($param_given(pigcd))
                Pigcd = BSIM4pigcd;
            else begin
                /*T11 = BSIM4Bechvb * BSIM4toxe; v4.7 */
                T11 = -BSIM4Bechvb;
                T12 = Vgsteff + 1.0e-20;
                T13 = T11 / T12 / T12;
                T14 = -T13 / T12;
                Pigcd = T13 * (1.0 - 0.5 * Vdseff / T12);
            end

            T7 = -Pigcd * Vdseff;
            T8 = T7 * T7 + 2.0e-4;

            if (T7 > `EXP_THRESHOLD)
                T9 = `MAX_EXP;
            else if (T7 < -`EXP_THRESHOLD)
                T9 = `MIN_EXP;
            else
                T9 = exp(T7);

            T0 = T8 * T8;
            T1 = T9 - 1.0 + 1.0e-4;
            T10 = (T1 - T7) / T8;

            Igcs = Igc * T10;

            T1 = T9 - 1.0 - 1.0e-4;
            T10 = (T7 * T9 - T1) / T8;
            Igcd = Igc * T10;

            T0 = vgs - (BSIM4vfbsd + BSIM4vfbsdoff);
            vgs_eff = sqrt(T0 * T0 + 1.0e-4);

            T2 = vgs * vgs_eff;
            T11 = BSIM4AechvbEdgeS;
            T12 = BSIM4BechvbEdge;
            T3 = BSIM4aigs * BSIM4cigs - BSIM4bigs;
            T4 = BSIM4bigs * BSIM4cigs;
            T5 = T12 * (BSIM4aigs + T3 * vgs_eff - T4 * vgs_eff * vgs_eff);
            if (T5 > `EXP_THRESHOLD)
                T6 = `MAX_EXP;
            else if (T5 < -`EXP_THRESHOLD)
                T6 = `MIN_EXP;
            else
                T6 = exp(T5);
            Igs = T11 * T2 * T6;
            if (verbose == 1)
                $strobe("Igs=%g,%g,%g,%g,%g,%g,%g,%g,%g,%g\n", Igs,T11,  T2,  T6, BSIM4aigsd,T5, T3, T4,T12,vgs_eff);

            T0 = vgd - (BSIM4vfbsd + BSIM4vfbsdoff);
            vgd_eff = sqrt(T0 * T0 + 1.0e-4);

            T2 = vgd * vgd_eff;
            T11 = BSIM4AechvbEdgeD;
            T3 = BSIM4aigd * BSIM4cigd
                 - BSIM4bigd;
            T4 = BSIM4bigd * BSIM4cigd;
            T5 = T12 * (BSIM4aigd + T3 * vgd_eff - T4 * vgd_eff * vgd_eff);
            if (T5 > `EXP_THRESHOLD)
                T6 = `MAX_EXP;
            else if (T5 < -`EXP_THRESHOLD)
                T6 = `MIN_EXP;
            else
                T6 = exp(T5);

            Igd = T11 * T2 * T6;
            if (verbose == 1)
                $strobe("Igd=%g,%g,%g,%g\n", Igd,T11,  T2,  T6);
        end
        else begin //BSIM4igcMod == 0
            Igcs = 0.0;
            Igs = 0.0;
            Igcd = 0.0;
            Igd = 0.0;
        end

        if (BSIM4igbMod) begin
            T0 = tmp * BSIM4nigbacc;
            T1 = -Vgs_eff + Vbseff + Vfb;
            VxNVt = T1 / T0;
            if (VxNVt > `EXP_THRESHOLD)
                Vaux = T1;
            else if (VxNVt < -`EXP_THRESHOLD)
                Vaux = T0 * ln(1.0 + `MIN_EXP);
            else begin
                ExpVxNVt = exp(VxNVt);
                Vaux = T0 * ln(1.0 + ExpVxNVt);
            end

            T2 = (Vgs_eff - Vbseff) * Vaux;
            T11 = 4.97232e-7 * BSIM4weff * BSIM4leff * BSIM4ToxRatio;
            T12 = -7.45669e11 * toxel;
            T3 = BSIM4aigbacc * BSIM4cigbacc - BSIM4bigbacc;
            T4 = BSIM4bigbacc * BSIM4cigbacc;
            T5 = T12 * (BSIM4aigbacc + T3 * Voxacc - T4 * Voxacc * Voxacc);

            if (T5 > `EXP_THRESHOLD)
                T6 = `MAX_EXP;
            else if (T5 < -`EXP_THRESHOLD)
                T6 = `MIN_EXP;
            else
                T6 = exp(T5);

            Igbacc = T11 * T2 * T6;
            if (verbose == 1)
                $strobe("Igbacc=%g\n", Igbacc);

            T0 = tmp * BSIM4nigbinv;
            T1 = Voxdepinv - BSIM4eigbinv;
            VxNVt = T1 / T0;
            if (VxNVt > `EXP_THRESHOLD)
                Vaux = T1;
            else if (VxNVt < -`EXP_THRESHOLD)
                Vaux = T0 * ln(1.0 + `MIN_EXP);
            else begin
                ExpVxNVt = exp(VxNVt);
                Vaux = T0 * ln(1.0 + ExpVxNVt);
            end

            T2 = (Vgs_eff - Vbseff) * Vaux;
            T11 = T11 * (0.75610);
            T12 = T12 * (1.31724);
            T3 = BSIM4aigbinv * BSIM4cigbinv - BSIM4bigbinv;
            T4 = BSIM4bigbinv * BSIM4cigbinv;
            T5 = T12 * (BSIM4aigbinv + T3 * Voxdepinv - T4 *
                Voxdepinv * Voxdepinv);

            if (T5 > `EXP_THRESHOLD)
                T6 = `MAX_EXP;
            else if (T5 < -`EXP_THRESHOLD)
                T6 = `MIN_EXP;
            else
                T6 = exp(T5);

            Igbinv = T11 * T2 * T6;
            if (verbose == 1)
                $strobe("Igbinv=%g\n", Igbinv);

            Igb = Igbinv + Igbacc;

        end  /* End of Gate current */
        else
            Igb = 0.0;


`ifdef NOISE_DERIVATIVES
            if ((BSIM4tnoiMod == 1) && analysis("noise") == `NOISE) begin
                // Derivatives only needed for this mode.

                if (BSIM4igcMod) begin
                    T0 = Vtm * BSIM4nigc;
                    VxNVt = (Vgs_eff - BSIM4type * BSIM4vth0) / T0;
                    if (VxNVt > `EXP_THRESHOLD) begin
                        dVaux_dVg = dVgs_eff_dVg;
                        dVaux_dVd = 0.0;
                        dVaux_dVb = 0.0;
                    end
                    else if (VxNVt < -`EXP_THRESHOLD) begin
                        dVaux_dVg = 0.0;
                        dVaux_dVd = 0.0;
                        dVaux_dVb = 0.0;
                    end
                    else begin
                        dVaux_dVg = ExpVxNVt / (1.0 + ExpVxNVt);
                        dVaux_dVd = 0.0;
                        dVaux_dVb = 0.0;
                        dVaux_dVg = dVaux_dVg * (  dVgs_eff_dVg);
                    end

                    dT2_dVg = dVgs_eff_dVg * Vaux + Vgs_eff * dVaux_dVg;
                    dT2_dVd = Vgs_eff * dVaux_dVd;
                    dT2_dVb = Vgs_eff * dVaux_dVb;

                    T11 = BSIM4Aechvb;
                    T12 = BSIM4Bechvb;
                    T3 = BSIM4aigc * BSIM4cigc - BSIM4bigc;
                    T4 = BSIM4bigc * BSIM4cigc;
                    T5 = T12 * (BSIM4aigc + T3 * Voxdepinv - T4 *
                    Voxdepinv * Voxdepinv);

                    if (T5 > `EXP_THRESHOLD) begin
                        T6 = `MAX_EXP;
                        dT6_dVg = 0.0;
                        dT6_dVb = 0.0;
                    end
                    else if (T5 < -`EXP_THRESHOLD) begin
                        T6 = `MIN_EXP;
                        dT6_dVg = 0.0;
                        dT6_dVb = 0.0;
                    end
                    else begin
                        T6 = exp(T5);
                        dT6_dVg = T6 * T12 * (T3 - 2.0 * T4 * Voxdepinv);
                        dT6_dVb = dT6_dVg * dVoxdepinv_dVb;
                        dT6_dVg = dT6_dVg * (  dVoxdepinv_dVg);
                    end

                    if ($param_given(pigcd)) begin
                        dPigcd_dVg = 0.0;
                        dPigcd_dVd = 0.0;
                        dPigcd_dVb = 0.0;
                    end
                    else begin
                        T11 = BSIM4Bechvb * toxel;
                        T12 = Vgsteff + 1.0e-20;
                        T13 = T11 / T12 / T12;
                        T14 = -T13 / T12;
                        Pigcd = T13 * (1.0 - 0.5 * Vdseff / T12);
                        dPigcd_dVg = T14 * (2.0 + 0.5 * (dVdseff_dVg *
                        Vgsteff - 3.0 * Vdseff) / T12);
                        dPigcd_dVd = 0.5 * T14 * dVdseff_dVd +
                        dPigcd_dVg * dVgsteff_dVd;
                        dPigcd_dVb = 0.5 * T14 * dVdseff_dVb +
                        dPigcd_dVg * dVgsteff_dVb;
                        dPigcd_dVg = dPigcd_dVg * (  dVgsteff_dVg);
                    end

                    T7 = -Pigcd * Vds;
                    dT7_dVg = -Vds * dPigcd_dVg;
                    dT7_dVd = -Pigcd - Vds * dPigcd_dVd;
                    dT7_dVb = -Vds * dPigcd_dVb;
                    T8 = T7 * T7 + 2.0e-4;
                    dT8_dVg = 2.0 * T7;
                    dT8_dVd = dT8_dVg * dT7_dVd;
                    dT8_dVb = dT8_dVg * dT7_dVb;
                    dT8_dVg = dT8_dVg * (  dT7_dVg);

                    if (T7 > `EXP_THRESHOLD) begin
                        T9 = `MAX_EXP;
                        dT9_dVg = 0.0;
                        dT9_dVd = 0.0;
                        dT9_dVb = 0.0;
                    end
                    else if (T7 < -`EXP_THRESHOLD) begin
                        T9 = `MIN_EXP;
                        dT9_dVg = 0.0;
                        dT9_dVd = 0.0;
                        dT9_dVb = 0.0;
                    end
                    else begin
                        T9 = exp(T7);
                        dT9_dVg = T9 * dT7_dVg;
                        dT9_dVd = T9 * dT7_dVd;
                        dT9_dVb = T9 * dT7_dVb;
                    end

                    T0 = T8 * T8;
                    T1 = T9 - 1.0 + 1.0e-4;
                    T10 = (T1 - T7) / T8;
                    dT10_dVg = (dT9_dVg - dT7_dVg - T10 * dT8_dVg) / T8;
                    dT10_dVd = (dT9_dVd - dT7_dVd - T10 * dT8_dVd) / T8;
                    dT10_dVb = (dT9_dVb - dT7_dVb - T10 * dT8_dVb) / T8;

                    Igcs = Igc * T10;

                    T1 = T9 - 1.0 - 1.0e-4;
                    T10 = (T7 * T9 - T1) / T8;
                    dT10_dVg = (dT7_dVg * T9 + (T7 - 1.0) * dT9_dVg -
                    T10 * dT8_dVg) / T8;
                    dT10_dVd = (dT7_dVd * T9 + (T7 - 1.0) * dT9_dVd -
                    T10 * dT8_dVd) / T8;
                    dT10_dVb = (dT7_dVb * T9 + (T7 - 1.0) * dT9_dVb -
                    T10 * dT8_dVb) / T8;
                    Igcd = Igc * T10;

                    T0 = vgs - BSIM4vfbsd;
                    vgs_eff = sqrt(T0 * T0 + 1.0e-4);
                    dvgs_eff_dvg = T0 / vgs_eff;

                    T2 = vgs * vgs_eff;
                    dT2_dVg = vgs * dvgs_eff_dvg + vgs_eff;
                    T11 = BSIM4AechvbEdgeS;
                    T12 = BSIM4BechvbEdge;
                    T3 = BSIM4aigsd * BSIM4cigsd - BSIM4bigsd;
                    T4 = BSIM4bigsd * BSIM4cigsd;
                    T5 = T12 * (BSIM4aigsd + T3 * vgs_eff - T4 * vgs_eff * vgs_eff);
                    if (T5 > `EXP_THRESHOLD) begin
                        T6 = `MAX_EXP;
                        dT6_dVg = 0.0;
                    end
                    else if (T5 < -`EXP_THRESHOLD) begin
                        T6 = `MIN_EXP;
                        dT6_dVg = 0.0;
                    end
                    else begin
                        T6 = exp(T5);
                        dT6_dVg = T6 * T12 * (T3 - 2.0 * T4 * vgs_eff) * dvgs_eff_dvg;
                    end

                    T0 = vgd - BSIM4vfbsd;
                    vgd_eff = sqrt(T0 * T0 + 1.0e-4);
                    dvgd_eff_dvg = T0 / vgd_eff;

                    T2 = vgd * vgd_eff;
                    dT2_dVg = vgd * dvgd_eff_dvg + vgd_eff;
                    T5 = T12 * (BSIM4aigsd + T3 * vgd_eff - T4 * vgd_eff * vgd_eff);
                    if (T5 > `EXP_THRESHOLD) begin
                        T6 = `MAX_EXP;
                        dT6_dVg = 0.0;
                    end
                    else if (T5 < -`EXP_THRESHOLD) begin
                        T6 = `MIN_EXP;
                        dT6_dVg = 0.0;
                    end
                    else begin
                        T6 = exp(T5);
                        dT6_dVg = T6 * T12 * (T3 - 2.0 * T4 * vgd_eff) * dvgd_eff_dvg;
                    end
                end

                if (BSIM4igbMod) begin
                    T0 = Vtm * BSIM4nigbacc;
                    T1 = -Vgs_eff + Vbseff + Vfb;
                    VxNVt = T1 / T0;
                    if (VxNVt > `EXP_THRESHOLD) begin
                        Vaux = T1;
                        dVaux_dVg = -dVgs_eff_dVg;
                        dVaux_dVb = 1.0;
                    end
                    else if (VxNVt < -`EXP_THRESHOLD) begin
                        Vaux = T0 * ln(1.0 + `MIN_EXP);
                        dVaux_dVg = 0.0;
                        dVaux_dVb = 0.0;
                    end
                    else begin
                        ExpVxNVt = exp(VxNVt);
                        Vaux = T0 * ln(1.0 + ExpVxNVt);
                        dVaux_dVb = ExpVxNVt / (1.0 + ExpVxNVt);
                        dVaux_dVg = -dVaux_dVb * dVgs_eff_dVg;
                    end

                    T2 = (Vgs_eff - Vbseff) * Vaux;
                    dT2_dVg = dVgs_eff_dVg * Vaux + (Vgs_eff - Vbseff) * dVaux_dVg;
                    dT2_dVb = -Vaux + (Vgs_eff - Vbseff) * dVaux_dVb;

                    T11 = 4.97232e-7 * BSIM4weff * BSIM4leff * BSIM4ToxRatio;
                    T12 = -7.45669e11 * toxel;
                    T3 = BSIM4aigbacc * BSIM4cigbacc - BSIM4bigbacc;
                    T4 = BSIM4bigbacc * BSIM4cigbacc;
                    T5 = T12 * (BSIM4aigbacc + T3 * Voxacc - T4 * Voxacc * Voxacc);

                    if (T5 > `EXP_THRESHOLD) begin
                        T6 = `MAX_EXP;
                        dT6_dVg = 0.0;
                        dT6_dVb = 0.0;
                    end
                    else if (T5 < -`EXP_THRESHOLD) begin
                        T6 = `MIN_EXP;
                        dT6_dVg = 0.0;
                        dT6_dVb = 0.0;
                    end
                    else begin
                        T6 = exp(T5);
                        dT6_dVg = T6 * T12 * (T3 - 2.0 * T4 * Voxacc);
                        dT6_dVb = dT6_dVg * dVoxacc_dVb;
                        dT6_dVg = dT6_dVg * (  dVoxacc_dVg);
                    end

                    T0 = Vtm * BSIM4nigbinv;
                    T1 = Voxdepinv - BSIM4eigbinv;
                    VxNVt = T1 / T0;
                    if (VxNVt > `EXP_THRESHOLD) begin
                        Vaux = T1;
                        dVaux_dVg = dVoxdepinv_dVg;
                        dVaux_dVd = dVoxdepinv_dVd;
                        dVaux_dVb = dVoxdepinv_dVb;
                    end
                    else if (VxNVt < -`EXP_THRESHOLD) begin
                        Vaux = T0 * ln(1.0 + `MIN_EXP);
                        dVaux_dVg = 0.0;
                        dVaux_dVd = 0.0;
                        dVaux_dVb = 0.0;
                    end
                    else begin
                        ExpVxNVt = exp(VxNVt);
                        Vaux = T0 * ln(1.0 + ExpVxNVt);
                        dVaux_dVg = ExpVxNVt / (1.0 + ExpVxNVt);
                        dVaux_dVd = dVaux_dVg * dVoxdepinv_dVd;
                        dVaux_dVb = dVaux_dVg * dVoxdepinv_dVb;
                        dVaux_dVg = dVaux_dVg * (  dVoxdepinv_dVg);
                    end

                    T2 = (Vgs_eff - Vbseff) * Vaux;
                    dT2_dVg = dVgs_eff_dVg * Vaux + (Vgs_eff - Vbseff) * dVaux_dVg;
                    dT2_dVd = (Vgs_eff - Vbseff) * dVaux_dVd;
                    dT2_dVb = -Vaux + (Vgs_eff - Vbseff) * dVaux_dVb;

                    T11 = T11 * 0.75610;
                    T12 = T12 * 1.31724;
                    T3 = BSIM4aigbinv * BSIM4cigbinv - BSIM4bigbinv;
                    T4 = BSIM4bigbinv * BSIM4cigbinv;
                    T5 = T12 * (BSIM4aigbinv + T3 * Voxdepinv - T4 *
                    Voxdepinv * Voxdepinv);

                    if (T5 > `EXP_THRESHOLD) begin
                        T6 = `MAX_EXP;
                        dT6_dVg = 0.0;
                        dT6_dVb = 0.0;
                    end
                    else if (T5 < -`EXP_THRESHOLD) begin
                        T6 = `MIN_EXP;
                        dT6_dVg = 0.0;
                        dT6_dVb = 0.0;
                    end
                    else begin
                        T6 = exp(T5);
                        dT6_dVg = T6 * T12 * (T3 - 2.0 * T4 * Voxdepinv);
                        dT6_dVb = dT6_dVg * dVoxdepinv_dVb;
                        dT6_dVg = dT6_dVg * (  dVoxdepinv_dVg);
                    end

                end
            end
`endif


        if (BSIM4nf != 1.0) begin
            cdrain = cdrain * BSIM4nf;
            IdovVds =IdovVds * BSIM4nf;
            Isub = Isub * BSIM4nf;
            Igidl = Igidl * BSIM4nf;
            Igisl = Igisl * BSIM4nf;
            Igcs = Igcs * BSIM4nf;
            Igs = Igs * BSIM4nf;
            Igcd = Igcd * BSIM4nf;
            Igd = Igd * BSIM4nf;
            Igb = Igb * BSIM4nf;
        end

        if (BSIM4tnoiMod == 0) begin
            Abulk = Abulk0 * BSIM4abulkCVfactor;
            Vdsat = Vgsteff / Abulk;
            T0 = Vdsat - Vds - `DELTA_4;
            T1 = sqrt(T0 * T0 + 4.0 * `DELTA_4 * Vdsat);
            if (T0 >= 0.0)
                Vdseff = Vdsat - 0.5 * (T0 + T1);
            else begin
                T3 = (`DELTA_4 + `DELTA_4) / (T1 - T0);
                T4 = 1.0 - T3;
                T5 = Vdsat * T3 / (T1 - T0);
                Vdseff = Vdsat * T4;
            end
            if (Vds == 0.0)
                Vdseff = 0.0;

            T0 = Abulk * Vdseff;
            T1 = 12.0 * (Vgsteff - 0.5 * T0 + 1.0e-20);
            T2 = Vdseff / T1;
            T3 = T0 * T2;

            BSIM4qinv = Coxeff * BSIM4weffCV * BSIM4nf * BSIM4leffCV *
            (Vgsteff - 0.5 * T0 + Abulk * T3);
        end

        /*   BSIM4 C-V begins    */

        if (BSIM4xpart < 0) begin
            qgate  = 0.0;
            qdrn = 0.0;
            qsrc = 0.0;
            qbulk = 0.0;
        end
        else if (BSIM4capMod == 0) begin

            if (Vbseff < 0.0)
                VbseffCV = Vbs;
            else
                VbseffCV = BSIM4phi - Phis;

            Vfb = BSIM4vfbcv;
            Vth = Vfb + BSIM4phi + BSIM4k1ox * sqrtPhis;
            Vgst = Vgs_eff - Vth;

            CoxWL = BSIM4coxe * BSIM4weffCV * BSIM4leffCV * BSIM4nf;
            Arg1 = Vgs_eff - VbseffCV - Vfb;

            if (Arg1 <= 0.0) begin
                qgate = CoxWL * Arg1;
                qbulk = -qgate;
                qdrn = 0.0;
            end  /* Arg1 <= 0.0, end of accumulation */
            else if (Vgst <= 0.0) begin
                T1 = 0.5 * BSIM4k1ox;
                T2 = sqrt(T1 * T1 + Arg1);
                qgate = CoxWL * BSIM4k1ox * (T2 - T1);
                qbulk = -qgate;
                qdrn = 0.0;
            end  /* Vgst <= 0.0, end of depletion */
            else begin
                One_Third_CoxWL = CoxWL / 3.0;
                Two_Third_CoxWL = 2.0 * One_Third_CoxWL;
                AbulkCV = Abulk0 * BSIM4abulkCVfactor;
                Vdsat = Vgst / AbulkCV;

                if (BSIM4xpart > 0.5) begin
                    /* 0/100 Charge partition model */
                    if (Vdsat <= Vds)
                    begin
                        /* saturation region */
                        T1 = Vdsat / 3.0;
                        qgate = CoxWL * (Vgs_eff - Vfb - BSIM4phi - T1);
                        T2 = -Two_Third_CoxWL * Vgst;
                        qbulk = -(qgate + T2);
                        qdrn = 0.0;
                    end
                    else begin
                        /* linear region */
                        Alphaz = Vgst / Vdsat;
                        T1 = 2.0 * Vdsat - Vds;
                        T2 = Vds / (3.0 * T1);
                        T3 = T2 * Vds;
                        T9 = 0.25 * CoxWL;
                        T4 = T9 * Alphaz;
                        T7 = 2.0 * Vds - T1 - 3.0 * T3;
                        T8 = T3 - T1 - 2.0 * Vds;
                        qgate = CoxWL * (Vgs_eff - Vfb - BSIM4phi - 0.5 * (Vds - T3));
                        T10 = T4 * T8;
                        qdrn = T4 * T7;
                        qbulk = -(qgate + qdrn + T10);
                    end
                end
                else if (BSIM4xpart < 0.5) begin
                    /* 40/60 Charge partition model */
                    if (Vds >= Vdsat) begin
                        /* saturation region */
                        T1 = Vdsat / 3.0;
                        qgate = CoxWL * (Vgs_eff - Vfb - BSIM4phi - T1);
                        T2 = -Two_Third_CoxWL * Vgst;
                        qbulk = -(qgate + T2);
                        qdrn = 0.4 * T2;
                    end
                    else begin
                        /* linear region  */
                        Alphaz = Vgst / Vdsat;
                        T1 = 2.0 * Vdsat - Vds;
                        T2 = Vds / (3.0 * T1);
                        T3 = T2 * Vds;
                        T9 = 0.25 * CoxWL;
                        T4 = T9 * Alphaz;
                        qgate = CoxWL * (Vgs_eff - Vfb - BSIM4phi - 0.5 * (Vds - T3));

                        T6 = 8.0 * Vdsat * Vdsat - 6.0 * Vdsat * Vds + 1.2 * Vds * Vds;
                        T8 = T2 / T1;
                        T7 = Vds - T1 - T8 * T6;
                        qdrn = T4 * T7;

                        T7 = 2.0 * (T1 + T3);
                        qbulk = -(qgate - T4 * T7);
                    end
                end
                else begin
                    /* 50/50 partitioning */
                    if (Vds >= Vdsat) begin
                        /* saturation region */
                        T1 = Vdsat / 3.0;
                        qgate = CoxWL * (Vgs_eff - Vfb - BSIM4phi - T1);
                        T2 = -Two_Third_CoxWL * Vgst;
                        qbulk = -(qgate + T2);
                        qdrn = 0.5 * T2;
                    end
                    else begin
                        /* linear region */
                        Alphaz = Vgst / Vdsat;
                        T1 = 2.0 * Vdsat - Vds;
                        T2 = Vds / (3.0 * T1);
                        T3 = T2 * Vds;
                        T9 = 0.25 * CoxWL;
                        T4 = T9 * Alphaz;
                        qgate = CoxWL * (Vgs_eff - Vfb - BSIM4phi - 0.5 * (Vds - T3));
                        T7 = T1 + T3;
                        qdrn = -T4 * T7;
                        qbulk = - (qgate + qdrn + qdrn);
                    end  /* end of linear region */
                end  /* end of 50/50 partition */
            end  /* end of inversion */
        end  /* end of capMod=0 */
        else begin
            if (Vbseff < 0.0)
                VbseffCV = Vbseff;
            else
                VbseffCV = BSIM4phi - Phis;

            CoxWL = BSIM4coxe * BSIM4weffCV * BSIM4leffCV * BSIM4nf;

            if (BSIM4cvchargeMod == 0) begin
                /* Separate VgsteffCV with noff and voffcv */
                local_noff = n * BSIM4noff;
                T0 = Vtm * local_noff;
                local_voffcv = BSIM4voffcv;
                VgstNVt = (Vgst - local_voffcv) / T0;

                if (VgstNVt > `EXP_THRESHOLD) begin
                    Vgsteff = Vgst - local_voffcv;
                end
                else if (VgstNVt < -`EXP_THRESHOLD) begin
                    Vgsteff = T0 * ln(1.0 + `MIN_EXP);
                end
                else begin
                    ExpVgst = exp(VgstNVt);
                    Vgsteff = T0 * ln(1.0 + ExpVgst);
                end  /* End of VgsteffCV */
            end /* End of VgsteffCV for cvchargeMod = 0 */
            else begin
                T0 = n * Vtm;
                T1 = BSIM4mstarcv * Vgst;
                T2 = T1 / T0;
                if (T2 > `EXP_THRESHOLD)
                    T10 = T1;
                else if (T2 < -`EXP_THRESHOLD)
                begin
                    T10 = Vtm * ln(1.0 + `MIN_EXP);
                    T10 = T10 * n;
                end
                else
                begin
                    ExpVgst = exp(T2);
                    T3 = Vtm * ln(1.0 + ExpVgst);
                    T10 = n * T3;
                end

                T1 = BSIM4voffcbncv - (1.0 - BSIM4mstarcv) * Vgst;
                T2 = T1 / T0;
                if (T2 < -`EXP_THRESHOLD)
                begin
                    T3 = BSIM4coxe * `MIN_EXP / BSIM4cdep0;
                    T9 = BSIM4mstarcv + T3 * n;
                end
                else if (T2 > `EXP_THRESHOLD)
                begin
                    T3 = BSIM4coxe * `MAX_EXP / BSIM4cdep0;
                    T9 = BSIM4mstarcv + T3 * n;
                end
                else
                begin
                    ExpVgst = exp(T2);
                    T3 = BSIM4coxe / BSIM4cdep0;
                    T4 = T3 * ExpVgst;
                    T5 = T1 * T4 / T0;
                    T9 = BSIM4mstarcv + n * T4;
                end

                Vgsteff = T10 / T9;
            end /* End of VgsteffCV for cvchargeMod = 1 */

            if (BSIM4capMod == 1) begin
                Vfb = here_BSIM4vfbzb;
                V3 = Vfb - Vgs_eff + VbseffCV - `DELTA_3;
                if (Vfb <= 0.0)
                    T0 = sqrt(V3 * V3 - 4.0 * `DELTA_3 * Vfb);
                else
                    T0 = sqrt(V3 * V3 + 4.0 * `DELTA_3 * Vfb);

                Vfbeff = Vfb - 0.5 * (V3 + T0);
                Qac0 = CoxWL * (Vfbeff - Vfb);
                T0 = 0.5 * BSIM4k1ox;
                T3 = Vgs_eff - Vfbeff - VbseffCV - Vgsteff;
                if (BSIM4k1ox == 0.0) begin
                    T1 = 0.0;
                end
                else if (T3 < 0.0) begin
                    T1 = T0 + T3 / BSIM4k1ox;
                end
                else begin
                    T1 = sqrt(T0 * T0 + T3);
                end

                Qsub0 = CoxWL * BSIM4k1ox * (T1 - T0);
                AbulkCV = Abulk0 * BSIM4abulkCVfactor;
                VdsatCV = Vgsteff / AbulkCV;

                T0 = VdsatCV - Vds - `DELTA_4;
                T1 = sqrt(T0 * T0 + 4.0 * `DELTA_4 * VdsatCV);
                if (T0 >= 0.0) begin
                    VdseffCV = VdsatCV - 0.5 * (T0 + T1);
                end
                else begin
                    T3 = (`DELTA_4 + `DELTA_4) / (T1 - T0);
                    T4 = 1.0 - T3;
                    VdseffCV = VdsatCV * T4;
                end

                if (Vds == 0.0)
                    VdseffCV = 0.0;

                T0 = AbulkCV * VdseffCV;
                T1 = 12.0 * (Vgsteff - 0.5 * T0 + 1.0e-20);
                T2 = VdseffCV / T1;
                T3 = T0 * T2;

                qgate = CoxWL * (Vgsteff - 0.5 * VdseffCV + T3);
                T7 = 1.0 - AbulkCV;
                qbulk = CoxWL * T7 * (0.5 * VdseffCV - T3);

                if (BSIM4xpart > 0.5) begin
                    /* 0/100 Charge petition model */
                    T1 = T1 + T1;
                    qsrc = -CoxWL * (0.5 * Vgsteff + 0.25 * T0 - T0 * T0 / T1);
                end
                else if (BSIM4xpart < 0.5) begin
                    /* 40/60 Charge petition model */
                    T1 = T1 / 12.0;
                    T2 = 0.5 * CoxWL / (T1 * T1);
                    T3 = Vgsteff * (2.0 * T0 * T0 / 3.0 + Vgsteff *
                    (Vgsteff - 4.0 * T0 / 3.0)) - 2.0 * T0 * T0 * T0 / 15.0;
                    qsrc = -T2 * T3;
                end
                else begin
                    /* 50/50 Charge petition model */
                    qsrc = -0.5 * (qgate + qbulk);
                end

                qgate = qgate + (Qac0 + Qsub0);
                qbulk = qbulk - (Qac0 + Qsub0);
                qdrn  = -(qgate + qbulk + qsrc);

            end

            /* Charge-Thickness capMod (CTM) begins */
            else if (BSIM4capMod == 2) begin
                V3 = here_BSIM4vfbzb - Vgs_eff + VbseffCV - `DELTA_3;
                if (here_BSIM4vfbzb <= 0.0)
                    T0 = sqrt(V3 * V3 - 4.0 * `DELTA_3 * here_BSIM4vfbzb);
                else
                    T0 = sqrt(V3 * V3 + 4.0 * `DELTA_3 * here_BSIM4vfbzb);

                T1 = 0.5 * (1.0 + V3 / T0);
                Vfbeff = here_BSIM4vfbzb - 0.5 * (V3 + T0);

                Cox = BSIM4coxp;
                Tox = 1.0e8 * BSIM4toxp;
                T0 = (Vgs_eff - VbseffCV - here_BSIM4vfbzb) / Tox;

                tmp = T0 * BSIM4acde;
                if ((-`EXP_THRESHOLD < tmp) && (tmp < `EXP_THRESHOLD)) begin
                    Tcen = BSIM4ldeb * exp(tmp);
                end
                else if (tmp <= -`EXP_THRESHOLD) begin
                    Tcen = BSIM4ldeb * `MIN_EXP;
                end
                else begin
                    Tcen = BSIM4ldeb * `MAX_EXP;
                end

                LINK = 1.0e-3 * BSIM4toxp;
                V3 = BSIM4ldeb - Tcen - LINK;
                V4 = sqrt(V3 * V3 + 4.0 * LINK * BSIM4ldeb);
                Tcen = BSIM4ldeb - 0.5 * (V3 + V4);

                Ccen = epssubl / Tcen;
                T2 = Cox / (Cox + Ccen);
                Coxeff = T2 * Ccen;
                T3 = -Ccen / Tcen;
                CoxWLcen = CoxWL * Coxeff / BSIM4coxe;

                Qac0 = CoxWLcen * (Vfbeff - here_BSIM4vfbzb);

                T0 = 0.5 * BSIM4k1ox;
                T3 = Vgs_eff - Vfbeff - VbseffCV - Vgsteff;
                if (BSIM4k1ox == 0.0) begin
                    T1 = 0.0;
                    T2 = 0.0;
                end
                else if (T3 < 0.0) begin
                    T1 = T0 + T3 / BSIM4k1ox;
                    T2 = CoxWLcen;
                end
                else begin
                    T1 = sqrt(T0 * T0 + T3);
                    T2 = CoxWLcen * T0 / T1;
                end

                Qsub0 = CoxWLcen * BSIM4k1ox * (T1 - T0);

                /* Gate-bias dependent delta Phis begins */
                if (BSIM4k1ox <= 0.0) begin
                    Denomi = 0.25 * BSIM4moin * Vtm;
                    T0 = 0.5 * BSIM4sqrtPhi;
                end
                else begin
                    Denomi = BSIM4moin * Vtm * BSIM4k1ox * BSIM4k1ox;
                    T0 = BSIM4k1ox * BSIM4sqrtPhi;
                end
                T1 = 2.0 * T0 + Vgsteff;

                DeltaPhi = Vtm * ln(1.0 + T1 * Vgsteff / Denomi);
                /* End of delta Phis */

                /* VgDP = Vgsteff - DeltaPhi */
                T0 = Vgsteff - DeltaPhi - 0.001;
                T1 = sqrt(T0 * T0 + Vgsteff * 0.004);
                VgDP = 0.5 * (T0 + T1);

                Tox = Tox + Tox; /* WDLiu: Tcen reevaluated below due to different Vgsteff */
                T0 = (Vgsteff + here_BSIM4vtfbphi2) / Tox;
                tmp = exp(BSIM4bdos * 0.7 * ln(T0));
                T1 = 1.0 + tmp;
                Tcen = BSIM4ados * 1.9e-9 / T1;

                Ccen = epssubl  / Tcen;
                T0 = Cox / (Cox + Ccen);
                Coxeff = T0 * Ccen;
                CoxWLcen = CoxWL * Coxeff / BSIM4coxe;

                AbulkCV = Abulk0 * BSIM4abulkCVfactor;
                VdsatCV = VgDP / AbulkCV;

                T0 = VdsatCV - Vds - `DELTA_4;
                T1 = sqrt(T0 * T0 + 4.0 * `DELTA_4 * VdsatCV);
                if (T0 >= 0.0) begin
                    VdseffCV = VdsatCV - 0.5 * (T0 + T1);
                end
                else begin
                    T3 = (`DELTA_4 + `DELTA_4) / (T1 - T0);
                    T4 = 1.0 - T3;
                    VdseffCV = VdsatCV * T4;
                end

                if (Vds == 0.0)
                    VdseffCV = 0.0;

                T0 = AbulkCV * VdseffCV;
                T1 = VgDP;
                T2 = 12.0 * (T1 - 0.5 * T0 + 1.0e-20);
                T3 = T0 / T2;
                qgate = CoxWLcen * (T1 - T0 * (0.5 - T3));
                T7 = 1.0 - AbulkCV;
                qbulk = CoxWLcen * T7 * (0.5 * VdseffCV - T0 * VdseffCV / T2);

                if (BSIM4xpart > 0.5) begin
                    /* 0/100 partition */
                    qsrc = -CoxWLcen * (T1 / 2.0 + T0 / 4.0 - 0.5 * T0 * T0 / T2);
                end
                else if (BSIM4xpart < 0.5) begin
                    /* 40/60 partition */
                    T2 = T2 / 12.0;
                    T3 = 0.5 * CoxWLcen / (T2 * T2);
                    T4 = T1 * (2.0 * T0 * T0 / 3.0 + T1 * (T1 - 4.0 *
                    T0 / 3.0)) - 2.0 * T0 * T0 * T0 / 15.0;
                    qsrc = -T3 * T4;
                end
                else begin
                    /* 50/50 partition */
                    qsrc = -0.5 * qgate;
                end

                qgate = qgate + (Qac0 + Qsub0 - qbulk);
                qbulk = qbulk - (Qac0 + Qsub0);
                qdrn = -(qgate + qbulk + qsrc);

            end   /* End of CTM */
        end


        /* NQS begins */
        if ((BSIM4trnqsMod) || (BSIM4acnqsMod)) begin
            //BSIM4qchqs = -(qbulk + qgate);

            CoxWL = BSIM4coxe * BSIM4weffCV * BSIM4nf * BSIM4leffCV;
            T1 = BSIM4gcrg / CoxWL; /* 1 / tau */

            //if (BSIM4acnqsMod)
            //    BSIM4taunet = 1.0 / T1;
        end // if ((BSIM4trnqsMod) || (BSIM4acnqsMod))
        //finished:

        /* Calculate junction C-V */
        czbd = BSIM4DunitAreaTempJctCap * BSIM4Adeff; /* bug fix */
        czbs = BSIM4SunitAreaTempJctCap * BSIM4Aseff;
        czbdsw = BSIM4DunitLengthSidewallTempJctCap * BSIM4Pdeff;
        czbdswg = BSIM4DunitLengthGateSidewallTempJctCap *
        BSIM4weffCJ * BSIM4nf;
        czbssw = BSIM4SunitLengthSidewallTempJctCap * BSIM4Pseff;
        czbsswg = BSIM4SunitLengthGateSidewallTempJctCap * BSIM4weffCJ * BSIM4nf;

        MJS = BSIM4SbulkJctBotGradingCoeff;
        MJSWS = BSIM4SbulkJctSideGradingCoeff;
        MJSWGS = BSIM4SbulkJctGateSideGradingCoeff;

        MJD = BSIM4DbulkJctBotGradingCoeff;
        MJSWD = BSIM4DbulkJctSideGradingCoeff;
        MJSWGD = BSIM4DbulkJctGateSideGradingCoeff;

        /* Source Bulk Junction */
        if (vbs_jct == 0.0)
            BSIM4qbs = 0.0;
        else if (vbs_jct < 0.0) begin
            if (czbs > 0.0) begin
                arg = 1.0 - vbs_jct / BSIM4PhiBS;
                if (MJS == 0.5)
                    sarg = 1.0 / sqrt(arg);
                else
                    sarg = exp(-MJS * ln(arg));
                BSIM4qbs = BSIM4PhiBS * czbs * (1.0 - arg * sarg) / (1.0 - MJS);
            end
            else begin
                BSIM4qbs = 0.0;
            end
            if (czbssw > 0.0) begin
                arg = 1.0 - vbs_jct / BSIM4PhiBSWS;
                if (MJSWS == 0.5)
                    sarg = 1.0 / sqrt(arg);
                else
                    sarg = exp(-MJSWS * ln(arg));
                BSIM4qbs = BSIM4qbs + (BSIM4PhiBSWS * czbssw) * (1.0 - arg * sarg) / (1.0 - MJSWS);
            end
            if (czbsswg > 0.0) begin
                arg = 1.0 - vbs_jct / BSIM4PhiBSWGS;
                if (MJSWGS == 0.5)
                    sarg = 1.0 / sqrt(arg);
                else
                    sarg = exp(-MJSWGS * ln(arg));
                BSIM4qbs = BSIM4qbs + (BSIM4PhiBSWGS * czbsswg) * (1.0 - arg * sarg) / (1.0 - MJSWGS);
            end
        end
        else begin
            T0 = czbs + czbssw + czbsswg;
            T1 = vbs_jct * (czbs * MJS / BSIM4PhiBS + czbssw * MJSWS /
            BSIM4PhiBSWS + czbsswg * MJSWGS / BSIM4PhiBSWGS);
            BSIM4qbs = vbs_jct * (T0 + 0.5 * T1);

        end // else: !if(vbs_jct < 0.0)

        /* Drain Bulk Junction */
        if (vbd_jct == 0.0) begin
            BSIM4qbd = 0.0;
        end
        else if (vbd_jct < 0.0) begin
            if (czbd > 0.0) begin
                arg = 1.0 - vbd_jct / BSIM4PhiBD;
                if (MJD == 0.5)
                    sarg = 1.0 / sqrt(arg);
                else
                    sarg = exp(-MJD * ln(arg));
                BSIM4qbd = BSIM4PhiBD* czbd * (1.0 - arg * sarg) / (1.0 - MJD);
            end
            else begin
                BSIM4qbd = 0.0;
            end
            if (czbdsw > 0.0) begin
                arg = 1.0 - vbd_jct / BSIM4PhiBSWD;
                if (MJSWD == 0.5)
                    sarg = 1.0 / sqrt(arg);
                else
                    sarg = exp(-MJSWD * ln(arg));

                BSIM4qbd = BSIM4qbd + (BSIM4PhiBSWD * czbdsw)       * (1.0 - arg * sarg) / (1.0 - MJSWD);
            end
            if (czbdswg > 0.0) begin
                arg = 1.0 - vbd_jct / BSIM4PhiBSWGD;
                if (MJSWGD == 0.5)
                    sarg = 1.0 / sqrt(arg);
                else
                    sarg = exp(-MJSWGD * ln(arg));

                BSIM4qbd = BSIM4qbd + (BSIM4PhiBSWGD * czbdswg)  * (1.0 - arg * sarg) / (1.0 - MJSWGD);
            end
        end // if (vbd_jct < 0.0)
        else begin
            T0 = czbd + czbdsw + czbdswg;
            T1 = vbd_jct * (czbd * MJD / BSIM4PhiBD + czbdsw * MJSWD /
            BSIM4PhiBSWD + czbdswg * MJSWGD / BSIM4PhiBSWGD);
            BSIM4qbd = vbd_jct * (T0 + 0.5 * T1);
        end

        if (BSIM4rgateMod == 3)
        begin
            vgdx = vgmd;
            vgsx = vgms;
        end
        else  /* For rgateMod == 0, 1 and 2 */
        begin
            vgdx = vgd;
            vgsx = vgs;
        end
        if (BSIM4capMod == 0) begin
            qgdo = BSIM4cgdo * vgdx;
            qgso = BSIM4cgso * vgsx;
        end
        else begin
            /* For both capMod == 1 and 2 */
            T0 = vgdx + `DELTA_1;
            T1 = sqrt(T0 * T0 + 4.0 * `DELTA_1);
            T2 = 0.5 * (T0 - T1);
            T3 = BSIM4weffCV * BSIM4cgdl;
            T4 = sqrt(1.0 - 4.0 * T2 / BSIM4ckappad);
            qgdo = (BSIM4cgdo + T3) * vgdx - T3 * (T2 + 0.5 * BSIM4ckappad *
            (T4 - 1.0));
            T0 = vgsx + `DELTA_1;
            T1 = sqrt(T0 * T0 + 4.0 * `DELTA_1);
            T2 = 0.5 * (T0 - T1);
            T3 = BSIM4weffCV * BSIM4cgsl;
            T4 = sqrt(1.0 - 4.0 * T2 / BSIM4ckappas);
            qgso = (BSIM4cgso + T3) * vgsx - T3 * (T2 + 0.5 * BSIM4ckappas *
            (T4 - 1.0));
        end

        if (BSIM4nf != 1.0) begin
            qgdo = qgdo * BSIM4nf;
            qgso = qgso * BSIM4nf;
        end

        if (BSIM4mode > 0) begin
            if (BSIM4trnqsMod == 0) begin
                qdrn = qdrn - qgdo;
                if (BSIM4rgateMod == 3) begin
                    qgmb = BSIM4cgbo * vgmb;
                    qgmid = qgdo + qgso + qgmb;
                    qbulk = qbulk - qgmb;
                    qsrc = -(qgate + qgmid + qbulk + qdrn);
                end
                else begin
                    qgb = BSIM4cgbo * vgb;
                    qgate = qgate + qgdo + qgso + qgb;
                    qbulk = qbulk - qgb;
                    qsrc = -(qgate + qbulk + qdrn);
                end
            end
            else begin
                //BSIM4trnqsMod >0
                //CoxWL = BSIM4coxe * BSIM4weffCV * BSIM4nf
                //            * BSIM4leffCV;

                if (BSIM4rgateMod == 3) begin
                    qgmb = BSIM4cgbo * vgmb;
                    qgmid = qgdo + qgso + qgmb;
                    qgate = 0.0;
                    qbulk = -qgmb;
                    qdrn = -qgdo;
                    qsrc = -(qgmid + qbulk + qdrn);
                end
                else begin
                    qgb = BSIM4cgbo * vgb;
                    qgate = qgdo + qgso + qgb;
                    qbulk = -qgb;
                    qdrn = -qgdo;
                    qsrc = -(qgate + qbulk + qdrn);
                end
            end
        end /* end of BSIM4mode >0 */
        else begin
            if (BSIM4trnqsMod == 0) begin
                qsrc = qdrn - qgso;
                if (BSIM4rgateMod == 3) begin
                    qgmb = BSIM4cgbo * vgmb;
                    qgmid = qgdo + qgso + qgmb;
                    qbulk = qbulk - qgmb;
                    qdrn = -(qgate + qgmid + qbulk + qsrc);
                end
                else begin
                    qgb = BSIM4cgbo * vgb;
                    qgate = qgate + qgdo + qgso + qgb;
                    qbulk = qbulk - qgb;
                    qdrn = -(qgate + qbulk + qsrc);
                end
            end
            else begin
                if (BSIM4rgateMod == 3) begin
                    qgmb = BSIM4cgbo * vgmb;
                    qgmid = qgdo + qgso + qgmb;
                    qgate = 0.0;
                    qbulk = -qgmb;
                    qdrn = -qgdo;
                    qsrc = -qgso;
                end
                else begin
                    qgb = BSIM4cgbo * vgb;
                    qgate = qgdo + qgso + qgb;
                    qbulk = -qgb;
                    qdrn = -qgdo;
                    qsrc = -qgso;
                end

            end // else: !if(BSIM4trnqsMod == 0)

        end // else: !if(BSIM4mode > 0)

        if (BSIM4mode < 0) begin
            cdrain = - cdrain;
            //BSIM4cbs = - BSIM4cbs;
            //BSIM4cbd = - BSIM4cbd;
            //Igidl = - Igidl; //TODO check?
        end

        I(di,si) <+ BSIM4type * cdrain;
        I(gi,si) <+ BSIM4type * Igs;
        I(gi,di) <+ BSIM4type * Igd;
        I(di,bi) <+ BSIM4type * (Isub + Igidl);
        I(si,bi) <+ BSIM4type * Igisl;

        if (BSIM4igcMod) begin
            I(gi,si) <+ BSIM4type * Igcs;
            I(gi,di) <+ BSIM4type * Igcd;
        end

        I(gi, bi)   <+ BSIM4type * Igb;

        if ((BSIM4rdsMod != 0) || (BSIM4tnoiMod == 1)) begin
            Issi = V(s,si) * (BSIM4sourceConductance /
            (1 + Rs * BSIM4sourceConductance));
            Iddi = V(d,di) * (BSIM4drainConductance /
            (1 + Rd * BSIM4drainConductance));
            if (verbose == 1) begin
                $strobe("In rdsmod=1 Issi=%g\n", Issi);
                $strobe("In rdsmod Iddi=%g\n", Iddi);
            end
            I(br_i_s_si) <+ Issi;
            I(br_i_d_di) <+ Iddi;
        end
        else begin
            V(br_v_s_si) <+ 0.0;
            V(br_v_d_di) <+ 0.0;
        end

        case (BSIM4rgateMod)
            0: begin // No gate resistance
                V(g,gm)  <+ 0.0;
                V(gm,gi) <+ 0.0;
            end
            1: begin // Constant resistance
                I(g,gm)  <+ V(g,gm) * BSIM4grgeltd;
                V(gm,gi) <+ 0.0;
            end
            2: begin // Variable resistance
                V(g,gm)   <+ 0.0;
                I(gm,gi)  <+ V(gm,gi) * (BSIM4gcrg + BSIM4grgeltd);
            end
            3: begin // 2 internal gate nodes, TODO check `gcgmgmb needs?
                if (verbose == 1) begin
                    $strobe("BSIM4grgeltd=%g\n",BSIM4grgeltd);
                    $strobe("BSIM4gcrg=%g\n",BSIM4gcrg);
                end
                I(g,gm)  <+ V(g,gm)  * BSIM4grgeltd;
                I(gm,gi) <+ V(gm,gi) * BSIM4gcrg;
            end
        endcase // case(BSIM4rgateMod)

        if (BSIM4rbodyMod) begin
            //using I(a,b)<+... instead of V(a,b)<+.. for node collapse condition, or else Xyce fail
            I(sbulk,bi) <+ V(sbulk,bi) * BSIM4grbps;
            I(sbulk,b)  <+ V(sbulk,b)  * BSIM4grbsb;
            I(b,bi)     <+ V(b,bi)     * BSIM4grbpb;
            I(b,dbulk)  <+ V(b,dbulk)  * BSIM4grbdb;
            I(bi,dbulk) <+ V(bi,dbulk) * BSIM4grbpd;
        end
        else begin
            V(sbulk,b)  <+ 0.0;
            V(b,bi)     <+ 0.0;
            V(b,dbulk)  <+ 0.0;
            //remove 2 below to avoid voltage loop
            //V(sbulk,bi) <+ 0.0;
            //V(bi,dbulk) <+ 0.0;
        end
        //using the same notation for both topologies
        I(sbulk,si) <+ BSIM4type*BSIM4cbs;
        I(dbulk,di) <+ BSIM4type*BSIM4cbd;

        if (verbose == 1) begin
            $strobe("BSIM4Ibs,gbs=%g,%g\n", BSIM4cbs, BSIM4gbs);
            $strobe("BSIM4Ibd,gbd=%g,%g\n", BSIM4cbd, BSIM4gbd);
            if (BSIM4rbodyMod) begin
                $strobe("Vbody(bi,db,sb)=%g,%g,%g\n", V(bi,s),V(dbulk,s),V(sbulk,s));
                $strobe("rbodymod,grbxx=%g,%g,%g,%g,%g,%g\n", BSIM4rbodyMod,BSIM4grbps,BSIM4grbsb,BSIM4grbpb,BSIM4grbdb,BSIM4grbpd);
            end
        end
        // Charge contributions
        //
        I(gi,si) <+ BSIM4type * ddt(qgate);
        I(di,si) <+ BSIM4type * ddt(qdrn);
        I(bi,si) <+ BSIM4type * ddt(qbulk);

        I(sbulk,si) <+ BSIM4type * ddt(BSIM4qbs);
        I(dbulk,di) <+ BSIM4type * ddt(BSIM4qbd);

        if (verbose == 1) begin
            $strobe("qgate=%g\n", qgate);
            $strobe("qdrn =%g\n", qdrn);
            $strobe("qsrc =%g\n", qsrc);
            $strobe("qgmid=%g\n", qgmid);
            $strobe("qbulk=%g\n", qbulk);
            $strobe("qgb  =%g\n", qgb);
            $strobe("qgmb =%g\n", qgmb);
            $strobe("qgdo =%g\n", qgdo);
            $strobe("qgso =%g\n", qgso);
            $strobe("here->BSIM4qbs=%g\n", BSIM4qbs);
            $strobe("here->BSIM4qbd=%g\n", BSIM4qbd);
            $strobe("BSIM4type=%d\n", BSIM4type);
            $strobe("BSIM4mode=%d\n", BSIM4mode);
        end

        // Noise
        if (BSIM4tnoiMod == 0) begin
            if (BSIM4rdsMod == 0) begin
                if (BSIM4sourceConductance != 1000)
                    gspr = BSIM4sourceConductance;
                else
                    gspr = 0;
                if (BSIM4drainConductance != 1000)
                    gdpr = BSIM4drainConductance;
                else
                    gspr = 0;

                if (grdsw > 0.0)
                    inv_grdsw = 1.0 / grdsw; /* used below */
                else
                    inv_grdsw = 0.0;
            end
            else begin
                gspr = BSIM4gstot;
                gdpr = BSIM4gdtot;
                inv_grdsw = 0.0;
            end
            npart_beta = 0.0;
            npart_theta = 0.0;
        end
        else begin
            T5 = here_Vgsteff / EsatL;
            T5 = T5 * T5;

            npart_beta  = BSIM4rnoia * (1.0 + T5 * BSIM4tnoia * Leff);
            npart_theta = BSIM4rnoib * (1.0 + T5 * BSIM4tnoib * Leff);

            if (BSIM4rdsMod == 0) begin
                gspr = BSIM4sourceConductance;
                gdpr = BSIM4drainConductance;
            end
            else begin
                gspr = BSIM4gstot;
                gdpr = BSIM4gdtot;
            end
            if (vds >= 0.0)
                gspr = gspr / (1.0 + npart_theta * npart_theta * gspr / IdovVds);
            else
                gdpr = gdpr / (1.0 + npart_theta * npart_theta * gdpr / IdovVds);
        end

        I(br_i_d_di) <+ white_noise(4 * `P_K * T * gdpr, "Rd");
        I(br_i_s_si) <+ white_noise(4 * `P_K * T * gspr, "Rs");

        if ((BSIM4rgateMod == 1) || (BSIM4rgateMod == 2))
            I(gi, g) <+ white_noise(4 * `P_K * T * BSIM4grgeltd, "Rg");
        else if (BSIM4rgateMod == 3)
            I(gm, g) <+ white_noise(4 * `P_K * T * BSIM4grgeltd, "Rg");

        if (BSIM4rbodyMod) begin
            I(bi, sbulk) <+ white_noise(4 * `P_K * T / BSIM4rbps, "Rbulk");
            I(bi, dbulk) <+ white_noise(4 * `P_K * T / BSIM4rbpd, "Rbulk");
            I(bi, b)     <+ white_noise(4 * `P_K * T / BSIM4rbpb, "Rbulk");
            I(b, sbulk)  <+ white_noise(4 * `P_K * T / BSIM4rbsb, "Rbulk");
            I(b, dbulk)  <+ white_noise(4 * `P_K * T / BSIM4rbdb, "Rbulk");
        end

        case (BSIM4tnoiMod)
            0: begin
                T0 = ueff * abs(BSIM4qinv);
                T1 = T0 * inv_grdsw + Leff * Leff;
                thermalNoiseContrib = (T0 / T1) * BSIM4ntnoi;
            end
            1: begin
                T0 = Gm + Gmb + Gds;
                T0 = T0 * T0;
                igsquare = npart_theta * npart_theta * T0 / IdovVds;
                T1 = npart_beta * (Gm + Gmb) + Gds;
                T2 = T1 * T1 / IdovVds;
                thermalNoiseContrib = T2 - igsquare;
            end
        endcase

        I(di,si) <+ white_noise(4 * `P_K * T * thermalNoiseContrib,
        "thermal");

        if (BSIM4mode >= 0) begin
            I(gi,si) <+ white_noise(2 * `P_Q * abs(Igs + Igcs), "shot");
            I(gi,di) <+ white_noise(2 * `P_Q * abs(Igd + Igcd), "shot");
        end
        else begin
            I(gi,si) <+ white_noise(2 * `P_Q * abs(Igs + Igcs), "shot");
            I(gi,di) <+ white_noise(2 * `P_Q * abs(Igd + Igcd), "shot");
        end
        I(gi,bi) <+ white_noise(2 * `P_Q * abs(Igb), "shot");

        case (BSIM4fnoiMod)
            0: begin
                flickerNoiseContrib = BSIM4kf * pow(abs(cdrain), BSIM4af) /
                (BSIM4coxe * Leff * Leff);
            end
            1: begin
                if (vds < 0.0)
                    vds = -vds;
                esat = 2.0 * BSIM4vsattemp / ueff;
                if (BSIM4em<=0.0)
                    DelClm = 0.0;
                else begin
                    T0 = ((((Vds - here_Vdseff) / BSIM4litl) + BSIM4em) / esat);
                    DelClm = BSIM4litl * ln(max(T0, `N_MINLOG));
                end
                T1 = `P_Q * `P_Q * `P_K * abs(cdrain) * T * ueff;
                T2 = 1.0e10 * here_Abulk * BSIM4coxe * Leff * Leff;
                N0 = BSIM4coxe * here_Vgsteff / `P_Q;
                Nl = BSIM4coxe * here_Vgsteff *
                (1.0 - AbovVgst2Vtm * here_Vdseff) / `P_Q;
                T3 = BSIM4oxideTrapDensityA * ln(max(((N0 + BSIM4nstar) /
                (Nl + BSIM4nstar)), `N_MINLOG));
                T4 = BSIM4oxideTrapDensityB * (N0 - Nl);
                T5 = BSIM4oxideTrapDensityC * 0.5 * (N0 * N0 - Nl * Nl);
                T6 = `P_K * T * cdrain * cdrain;
                T7 = 1.0e10 * Leff * Leff * Weff;
                T8 = BSIM4oxideTrapDensityA + BSIM4oxideTrapDensityB * Nl +
                BSIM4oxideTrapDensityC * Nl * Nl;
                T9 = (Nl + BSIM4nstar) * (Nl + BSIM4nstar);
                Ssi = T1 / T2 * (T3 + T4 + T5) + T6 / T7 * DelClm * T8 / T9;

                T10 = BSIM4oxideTrapDensityA * `P_K * T;
                T11 = Weff * Leff * 1.0e10 * BSIM4nstar * BSIM4nstar;
                Swi = T10 / T11 * cdrain * cdrain;
                T1 = Swi + Ssi;
                if (T1 > 0.0)
                    flickerNoiseContrib = (Ssi * Swi) / T1;
                else
                    flickerNoiseContrib = 0.0;
            end
        endcase

        I(di,si) <+ flicker_noise(flickerNoiseContrib, BSIM4ef, "flicker");

    end

endmodule // end of bsim4_va





